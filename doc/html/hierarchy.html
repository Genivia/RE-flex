<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta http-equiv="cache-control" content="no-cache">
<title>Class Hierarchy</title>
<link href="doxygen_tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="doxygen_content.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top">
 <div id="titlearea">
  <table height="72px" width="100%" cellspacing="0" cellpadding="0">
   <tbody>
    <tr>
     <td width="10%">&nbsp;</td>
     <td><a href="https://github.com/Genivia/RE-flex"><img src="reflex-logo.png"/></a></td>
     <td>
      <div style="float: right; font-size: 18px; font-weight: bold;">Class Hierarchy</div>
      <br>
      <div style="float: right; font-size: 10px;">updated Mon Feb 3 2025 by Robert van Engelen</div>
     </td>
     <td width="10%">&nbsp;</td>
    </tr>
   </tbody>
  </table>
 </div>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li class="current"><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Class Hierarchy</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock">
<p><a href="inherits.html">Go to the graphical class hierarchy</a></p>
This inheritance list is sorted roughly, but not completely, alphabetically:</div><div class="directory">
<div class="levels">[detail level <span onclick="javascript:toggleLevel(1);">1</span><span onclick="javascript:toggleLevel(2);">2</span><span onclick="javascript:toggleLevel(3);">3</span><span onclick="javascript:toggleLevel(4);">4</span>]</div><table class="directory">
<tr id="row_0_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_0_" class="arrow" onclick="toggleFolder('0_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classreflex_1_1_abstract_lexer.html" target="_self">reflex::AbstractLexer&lt; M &gt;</a></td><td class="desc">The abstract lexer class template that is the abstract root class of all reflex-generated scanners </td></tr>
<tr id="row_0_0_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classreflex_1_1_flex_lexer.html" target="_self">reflex::FlexLexer&lt; M &gt;</a></td><td class="desc">Flex-compatible <a class="el" href="classreflex_1_1_flex_lexer.html" title="Flex-compatible FlexLexer abstract base class template derived from reflex::AbstractMatcher for the r...">FlexLexer</a> abstract base class template derived from <a class="el" href="classreflex_1_1_abstract_matcher.html" title="The abstract matcher base class template defines an interface for all pattern matcher engines...">reflex::AbstractMatcher</a> for the reflex-generated yyFlexLexer scanner class </td></tr>
<tr id="row_1_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_1_" class="arrow" onclick="toggleFolder('1_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classreflex_1_1_abstract_matcher.html" target="_self">reflex::AbstractMatcher</a></td><td class="desc">The abstract matcher base class template defines an interface for all pattern matcher engines </td></tr>
<tr id="row_1_0_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_1_0_" class="arrow" onclick="toggleFolder('1_0_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classreflex_1_1_pattern_matcher.html" target="_self">reflex::PatternMatcher&lt; boost::regex &gt;</a></td><td class="desc"></td></tr>
<tr id="row_1_0_0_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span id="arr_1_0_0_" class="arrow" onclick="toggleFolder('1_0_0_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classreflex_1_1_boost_matcher.html" target="_self">reflex::BoostMatcher</a></td><td class="desc">Boost matcher engine class implements <a class="el" href="classreflex_1_1_pattern_matcher.html" title="The pattern matcher class template extends abstract matcher base class. ">reflex::PatternMatcher</a> pattern matching interface with scan, find, split functors and iterators, using the Boost::regex library </td></tr>
<tr id="row_1_0_0_0_"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classreflex_1_1_boost_perl_matcher.html" target="_self">reflex::BoostPerlMatcher</a></td><td class="desc">Boost matcher engine class, extends <a class="el" href="classreflex_1_1_boost_matcher.html" title="Boost matcher engine class implements reflex::PatternMatcher pattern matching interface with scan...">reflex::BoostMatcher</a> for Boost Perl regex matching </td></tr>
<tr id="row_1_0_0_1_" class="even"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classreflex_1_1_boost_posix_matcher.html" target="_self">reflex::BoostPosixMatcher</a></td><td class="desc">Boost matcher engine class, extends <a class="el" href="classreflex_1_1_boost_matcher.html" title="Boost matcher engine class implements reflex::PatternMatcher pattern matching interface with scan...">reflex::BoostMatcher</a> for Boost POSIX regex matching </td></tr>
<tr id="row_1_1_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_1_1_" class="arrow" onclick="toggleFolder('1_1_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classreflex_1_1_pattern_matcher.html" target="_self">reflex::PatternMatcher&lt; reflex::Pattern &gt;</a></td><td class="desc"></td></tr>
<tr id="row_1_1_0_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span id="arr_1_1_0_" class="arrow" onclick="toggleFolder('1_1_0_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classreflex_1_1_matcher.html" target="_self">reflex::Matcher</a></td><td class="desc">RE/flex matcher engine class, implements <a class="el" href="classreflex_1_1_pattern_matcher.html" title="The pattern matcher class template extends abstract matcher base class. ">reflex::PatternMatcher</a> pattern matching interface with scan, find, split functors and iterators </td></tr>
<tr id="row_1_1_0_0_"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classreflex_1_1_fuzzy_matcher.html" target="_self">reflex::FuzzyMatcher</a></td><td class="desc">RE/flex fuzzy matcher engine class, implements <a class="el" href="classreflex_1_1_matcher.html" title="RE/flex matcher engine class, implements reflex::PatternMatcher pattern matching interface with scan...">reflex::Matcher</a> fuzzy pattern matching interface with scan, find, split functors and iterators </td></tr>
<tr id="row_1_2_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_1_2_" class="arrow" onclick="toggleFolder('1_2_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classreflex_1_1_pattern_matcher.html" target="_self">reflex::PatternMatcher&lt; std::regex &gt;</a></td><td class="desc"></td></tr>
<tr id="row_1_2_0_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span id="arr_1_2_0_" class="arrow" onclick="toggleFolder('1_2_0_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classreflex_1_1_std_matcher.html" target="_self">reflex::StdMatcher</a></td><td class="desc">Std matcher engine class implements <a class="el" href="classreflex_1_1_pattern_matcher.html" title="The pattern matcher class template extends abstract matcher base class. ">reflex::PatternMatcher</a> pattern matching interface with scan, find, split functors and iterators, using the C++11 std::regex library </td></tr>
<tr id="row_1_2_0_0_" class="even"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classreflex_1_1_std_ecma_matcher.html" target="_self">reflex::StdEcmaMatcher</a></td><td class="desc">Std matcher engine class, extends <a class="el" href="classreflex_1_1_std_matcher.html" title="std matcher engine class implements reflex::PatternMatcher pattern matching interface with scan...">reflex::StdMatcher</a> for ECMA std::regex::ECMAScript syntax and regex matching </td></tr>
<tr id="row_1_2_0_1_"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classreflex_1_1_std_posix_matcher.html" target="_self">reflex::StdPosixMatcher</a></td><td class="desc">Std matcher engine class, extends <a class="el" href="classreflex_1_1_std_matcher.html" title="std matcher engine class implements reflex::PatternMatcher pattern matching interface with scan...">reflex::StdMatcher</a> for POSIX ERE std::regex::awk syntax and regex matching </td></tr>
<tr id="row_1_3_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classreflex_1_1_line_matcher.html" target="_self">reflex::LineMatcher</a></td><td class="desc">Line matcher engine class implements <a class="el" href="classreflex_1_1_pattern_matcher.html" title="The pattern matcher class template extends abstract matcher base class. ">reflex::PatternMatcher</a> pattern matching interface with scan, find, split functors and iterators for matching lines only, use option 'A' to include newline with FIND, option 'N' to also FIND empty lines and option 'W' to only FIND empty lines </td></tr>
<tr id="row_1_4_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classreflex_1_1_pattern_matcher.html" target="_self">reflex::PatternMatcher&lt; P &gt;</a></td><td class="desc">The pattern matcher class template extends abstract matcher base class </td></tr>
<tr id="row_1_5_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_1_5_" class="arrow" onclick="toggleFolder('1_5_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classreflex_1_1_pattern_matcher_3_01std_1_1string_01_4.html" target="_self">reflex::PatternMatcher&lt; std::string &gt;</a></td><td class="desc">A specialization of the pattern matcher class template for std::string, extends abstract matcher base class </td></tr>
<tr id="row_1_5_0_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span id="arr_1_5_0_" class="arrow" onclick="toggleFolder('1_5_0_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classreflex_1_1_p_c_r_e2_matcher.html" target="_self">reflex::PCRE2Matcher</a></td><td class="desc">PCRE2 JIT-optimized matcher engine class implements <a class="el" href="classreflex_1_1_pattern_matcher.html" title="The pattern matcher class template extends abstract matcher base class. ">reflex::PatternMatcher</a> pattern matching interface with scan, find, split functors and iterators, using the PCRE2 library </td></tr>
<tr id="row_1_5_0_0_" class="even"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classreflex_1_1_p_c_r_e2_u_t_f_matcher.html" target="_self">reflex::PCRE2UTFMatcher</a></td><td class="desc">PCRE2 JIT-optimized native PCRE2_UTF+PCRE2_UCP matcher engine class, extends <a class="el" href="classreflex_1_1_p_c_r_e2_matcher.html" title="PCRE2 JIT-optimized matcher engine class implements reflex::PatternMatcher pattern matching interface...">PCRE2Matcher</a> </td></tr>
<tr id="row_2_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structreflex_1_1_fuzzy_matcher_1_1_backtrack_point.html" target="_self">reflex::FuzzyMatcher::BacktrackPoint</a></td><td class="desc">Backtrack point </td></tr>
<tr id="row_3_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structreflex_1_1_bits_1_1_bitref.html" target="_self">reflex::Bits::Bitref</a></td><td class="desc">References a single bit, returned by operator[] </td></tr>
<tr id="row_4_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classreflex_1_1_bits.html" target="_self">reflex::Bits</a></td><td class="desc">RE/flex <a class="el" href="classreflex_1_1_bits.html" title="RE/flex Bits class for dynamic bit vectors. ">Bits</a> class for dynamic bit vectors </td></tr>
<tr id="row_5_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structreflex_1_1_pattern_1_1_chars.html" target="_self">reflex::Pattern::Chars</a></td><td class="desc">Set of chars and meta chars </td></tr>
<tr id="row_6_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="struct_reflex_1_1_code.html" target="_self">Reflex::Code</a></td><td class="desc">Line of code fragment in lex specifications </td></tr>
<tr id="row_7_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html" target="_self">reflex::AbstractMatcher::Const</a></td><td class="desc"><a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html" title="AbstractMatcher::Const common constants. ">AbstractMatcher::Const</a> common constants </td></tr>
<tr id="row_8_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structreflex_1_1_pattern_1_1_const.html" target="_self">reflex::Pattern::Const</a></td><td class="desc">Common constants </td></tr>
<tr id="row_9_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structreflex_1_1_abstract_matcher_1_1_context.html" target="_self">reflex::AbstractMatcher::Context</a></td><td class="desc"><a class="el" href="structreflex_1_1_abstract_matcher_1_1_context.html" title="Context returned by before() and after() ">Context</a> returned by <a class="el" href="classreflex_1_1_abstract_matcher.html#ae08cc80655fe7c723dd15da0ac80eb35" title="Get the buffered context before the matching line. ">before()</a> and <a class="el" href="classreflex_1_1_abstract_matcher.html#a1422cc4d5a78f997393081a1416b1f52" title="Get the buffered context after EOF is reached. ">after()</a> </td></tr>
<tr id="row_10_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structreflex_1_1_pattern_1_1_d_f_a.html" target="_self">reflex::Pattern::DFA</a></td><td class="desc"><a class="el" href="structreflex_1_1_pattern_1_1_d_f_a.html" title="DFA created by subset construction from regex patterns. ">DFA</a> created by subset construction from regex patterns </td></tr>
<tr id="row_11_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_11_" class="arrow" onclick="toggleFolder('11_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><b>std::exception</b></td><td class="desc">STL class </td></tr>
<tr id="row_11_0_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_11_0_" class="arrow" onclick="toggleFolder('11_0_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><b>std::runtime_error</b></td><td class="desc">STL class </td></tr>
<tr id="row_11_0_0_" class="even"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classreflex_1_1regex__error.html" target="_self">reflex::regex_error</a></td><td class="desc">Regex syntax error exceptions </td></tr>
<tr id="row_12_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structreflex_1_1_input_1_1file__encoding.html" target="_self">reflex::Input::file_encoding</a></td><td class="desc">Common <a class="el" href="structreflex_1_1_input_1_1file__encoding.html" title="Common file_encoding constants. ">file_encoding</a> constants </td></tr>
<tr id="row_13_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" target="_self">reflex::Matcher::FSM</a></td><td class="desc"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> data for <a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code </td></tr>
<tr id="row_14_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structreflex_1_1_abstract_matcher_1_1_handler.html" target="_self">reflex::AbstractMatcher::Handler</a></td><td class="desc">Event handler functor base class to invoke when the buffer contents are shifted out, e.g. for logging the data searched </td></tr>
<tr id="row_15_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structreflex_1_1_input_1_1_handler.html" target="_self">reflex::Input::Handler</a></td><td class="desc">FILE* handler functor base class to handle FILE* errors and non-blocking FILE* reads </td></tr>
<tr id="row_16_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structreflex_1_1_pattern_1_1_h_f_a.html" target="_self">reflex::Pattern::HFA</a></td><td class="desc">Indexing hash finite state automaton for indexed file search </td></tr>
<tr id="row_17_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_17_" class="arrow" onclick="toggleFolder('17_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classreflex_1_1_input.html" target="_self">reflex::Input</a></td><td class="desc"><a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> character sequence class for unified access to sources of input text </td></tr>
<tr id="row_17_0_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classreflex_1_1_buffered_input.html" target="_self">reflex::BufferedInput</a></td><td class="desc">Buffered input </td></tr>
<tr id="row_18_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structreflex_1_1lazy__union_1_1iterator.html" target="_self">reflex::lazy_union&lt; S1, S2 &gt;::iterator</a></td><td class="desc">Iterator to lazely get elements of a set union </td></tr>
<tr id="row_19_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classreflex_1_1_abstract_matcher_1_1_iterator.html" target="_self">reflex::AbstractMatcher::Iterator&lt; T &gt;</a></td><td class="desc"><a class="el" href="classreflex_1_1_abstract_matcher_1_1_iterator.html" title="AbstractMatcher::Iterator class for scanning, searching, and splitting input character sequences...">AbstractMatcher::Iterator</a> class for scanning, searching, and splitting input character sequences </td></tr>
<tr id="row_20_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structreflex_1_1lazy__intersection_1_1iterator.html" target="_self">reflex::lazy_intersection&lt; S1, S2 &gt;::iterator</a></td><td class="desc">Iterator to lazely get elements of a set intersection </td></tr>
<tr id="row_21_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structreflex_1_1lazy__intersection.html" target="_self">reflex::lazy_intersection&lt; S1, S2 &gt;</a></td><td class="desc">Intersection of two ordered sets, with an iterator to get elements lazely </td></tr>
<tr id="row_22_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structreflex_1_1lazy__union.html" target="_self">reflex::lazy_union&lt; S1, S2 &gt;</a></td><td class="desc">Union of two ordered sets, with an iterator to get elements lazely </td></tr>
<tr id="row_23_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="struct_reflex_1_1_library.html" target="_self">Reflex::Library</a></td><td class="desc">A library entry to describe regex library properties </td></tr>
<tr id="row_24_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structreflex_1_1_posix_1_1_tables_1_1lt.html" target="_self">reflex::Posix::Tables::lt</a></td><td class="desc"></td></tr>
<tr id="row_25_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_25_" class="arrow" onclick="toggleFolder('25_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><b>M</b></td><td class="desc"></td></tr>
<tr id="row_25_0_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_25_0_" class="arrow" onclick="toggleFolder('25_0_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html" target="_self">reflex::AbstractLexer&lt; M &gt;::Matcher</a></td><td class="desc">Extend matcher class M with a member pointing to the instantiating lexer class </td></tr>
<tr id="row_25_0_0_"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classreflex_1_1_flex_lexer_1_1_matcher.html" target="_self">reflex::FlexLexer&lt; M &gt;::Matcher</a></td><td class="desc">Extends reflex::AbstractLexer&lt;M&gt;::Matcher for Flex-compatibility </td></tr>
<tr id="row_26_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structreflex_1_1_pattern_1_1_d_f_a_1_1_meta_edges_closure.html" target="_self">reflex::Pattern::DFA::MetaEdgesClosure</a></td><td class="desc"></td></tr>
<tr id="row_27_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structreflex_1_1_pattern_1_1_mod_const.html" target="_self">reflex::Pattern::ModConst</a></td><td class="desc">Modifiers 'i', 'm', 'q', 's', 'u' (enable) 'I', 'M', 'Q', 'S', 'U' (disable) </td></tr>
<tr id="row_28_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classreflex_1_1_abstract_matcher_1_1_operation.html" target="_self">reflex::AbstractMatcher::Operation</a></td><td class="desc"><a class="el" href="classreflex_1_1_abstract_matcher_1_1_operation.html" title="AbstractMatcher::Operation functor to match input to a pattern, also provides a (const) AbstractMatch...">AbstractMatcher::Operation</a> functor to match input to a pattern, also provides a (const) <a class="el" href="classreflex_1_1_abstract_matcher.html#a7237c1fb8ab2a2283117739e6516c31f" title="std::input_iterator for scanning, searching, and splitting input character sequences ...">AbstractMatcher::iterator</a> to iterate over matches </td></tr>
<tr id="row_29_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structreflex_1_1_abstract_matcher_1_1_option.html" target="_self">reflex::AbstractMatcher::Option</a></td><td class="desc">AbstractMatcher::Options for matcher engines </td></tr>
<tr id="row_30_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structreflex_1_1_pattern_1_1_option.html" target="_self">reflex::Pattern::Option</a></td><td class="desc">Global modifier modes, syntax flags, and compiler options </td></tr>
<tr id="row_31_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classreflex_1_1_pattern.html" target="_self">reflex::Pattern</a></td><td class="desc"><a class="el" href="classreflex_1_1_pattern.html" title="Pattern class holds a regex pattern and its compiled FSM opcode table or code for the reflex::Matcher...">Pattern</a> class holds a regex pattern and its compiled FSM opcode table or code for the <a class="el" href="classreflex_1_1_matcher.html" title="RE/flex matcher engine class, implements reflex::PatternMatcher pattern matching interface with scan...">reflex::Matcher</a> engine </td></tr>
<tr id="row_32_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structreflex_1_1_pattern_1_1_position.html" target="_self">reflex::Pattern::Position</a></td><td class="desc">Finite state machine construction position information </td></tr>
<tr id="row_33_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structreflex_1_1range__compare.html" target="_self">reflex::range_compare&lt; T &gt;</a></td><td class="desc">Functor to define a total order on ranges (intervals) represented by pairs </td></tr>
<tr id="row_34_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_reflex.html" target="_self">Reflex</a></td><td class="desc">RE/flex scanner generator class, a variation of the classic "lex" tool to generate scanners </td></tr>
<tr id="row_35_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="struct_reflex_1_1_rule.html" target="_self">Reflex::Rule</a></td><td class="desc">A regex pattern and action pair that forms a rule </td></tr>
<tr id="row_36_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structreflex_1_1_fuzzy_matcher_1_1_save_state.html" target="_self">reflex::FuzzyMatcher::SaveState</a></td><td class="desc">Save state to restore fuzzy matcher state after a second pass </td></tr>
<tr id="row_37_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_37_" class="arrow" onclick="toggleFolder('37_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><b>std::set&lt; K &gt;</b></td><td class="desc">STL class </td></tr>
<tr id="row_37_0_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_37_0_" class="arrow" onclick="toggleFolder('37_0_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classreflex_1_1_ranges.html" target="_self">reflex::Ranges&lt; T &gt;</a></td><td class="desc">RE/flex <a class="el" href="classreflex_1_1_ranges.html" title="RE/flex Ranges template class. ">Ranges</a> template class </td></tr>
<tr id="row_37_0_0_"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classreflex_1_1_o_ranges.html" target="_self">reflex::ORanges&lt; T &gt;</a></td><td class="desc">RE/flex <a class="el" href="classreflex_1_1_o_ranges.html" title="RE/flex ORanges (open-ended, ordinal value range) template class. ">ORanges</a> (open-ended, ordinal value range) template class </td></tr>
<tr id="row_38_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_38_" class="arrow" onclick="toggleFolder('38_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><b>streambuf</b></td><td class="desc"></td></tr>
<tr id="row_38_0_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classreflex_1_1_buffered_input_1_1dos__streambuf.html" target="_self">reflex::BufferedInput::dos_streambuf</a></td><td class="desc">Buffered stream buffer for <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a> to read DOS files, replaces CRLF by LF, derived from std::streambuf </td></tr>
<tr id="row_38_1_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classreflex_1_1_buffered_input_1_1streambuf.html" target="_self">reflex::BufferedInput::streambuf</a></td><td class="desc">Buffered stream buffer for <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a>, derived from std::streambuf </td></tr>
<tr id="row_38_2_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classreflex_1_1_input_1_1dos__streambuf.html" target="_self">reflex::Input::dos_streambuf</a></td><td class="desc">Stream buffer for <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a> to read DOS files, replaces CRLF by LF, derived from std::streambuf </td></tr>
<tr id="row_38_3_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classreflex_1_1_input_1_1streambuf.html" target="_self">reflex::Input::streambuf</a></td><td class="desc">Stream buffer for <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a>, derived from std::streambuf </td></tr>
<tr id="row_39_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_39_" class="arrow" onclick="toggleFolder('39_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classreflex_1_1_posix_1_1_tables.html" target="_self">reflex::Posix::Tables</a></td><td class="desc"></td></tr>
<tr id="row_39_0_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classreflex_1_1_unicode_1_1_tables.html" target="_self">reflex::Unicode::Tables</a></td><td class="desc"></td></tr>
<tr id="row_40_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structreflex_1_1_type_op.html" target="_self">reflex::TypeOp&lt; T &gt;</a></td><td class="desc"><a class="el" href="structreflex_1_1_type_op.html#a02e39f4769e38a61fc8e913f021630ca" title="TypeOp&lt;T&gt;::Type = T. ">TypeOp&lt;T&gt;::Type</a> = T, <a class="el" href="structreflex_1_1_type_op.html#a5d72c0bbda0b00fab2b38581a198f41d" title="TypeOp&lt;T&gt;::ConstType = const T. ">TypeOp&lt;T&gt;::ConstType</a> = const T, <a class="el" href="structreflex_1_1_type_op.html#a32e6baa1761b90ab91461d64f047693c" title="TypeOp&lt;T&gt;::NonConstType = non-const T. ">TypeOp&lt;T&gt;::NonConstType</a> = non-const T </td></tr>
<tr id="row_41_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structreflex_1_1_type_op_3_01const_01_t_01_4.html" target="_self">reflex::TypeOp&lt; const T &gt;</a></td><td class="desc">Template specialization of <a class="el" href="structreflex_1_1_type_op.html" title="TypeOp&lt;T&gt;::Type = T, TypeOp&lt;T&gt;::ConstType = const T, TypeOp&lt;T&gt;::NonConstType = non-const T...">reflex::TypeOp</a> </td></tr>
<tr id="row_42_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_42_" class="arrow" onclick="toggleFolder('42_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><b>std::vector&lt; T &gt;</b></td><td class="desc">STL class </td></tr>
<tr id="row_42_0_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structreflex_1_1_pattern_1_1_d_f_a_1_1_state.html" target="_self">reflex::Pattern::DFA::State</a></td><td class="desc"></td></tr>
</table>
</div><!-- directory -->
</div><!-- contents -->
<hr class="footer">
<address class="footer"><small>
Converted on Mon Feb 3 2025 13:39:55 by <a target="_blank" href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.11</small></address>
<br>
<div style="height: 246px; background: #DBDBDB;">
</body>
</html>
