<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta http-equiv="cache-control" content="no-cache">
<title>reflex Namespace Reference</title>
<link href="doxygen_tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="doxygen_content.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top">
 <div id="titlearea">
  <table height="72px" width="100%" cellspacing="0" cellpadding="0">
   <tbody>
    <tr>
     <td width="10%">&nbsp;</td>
     <td><a href="https://github.com/Genivia/RE-flex"><img src="reflex-logo.png"/></a></td>
     <td>
      <div style="float: right; font-size: 18px; font-weight: bold;">reflex Namespace Reference</div>
      <br>
      <div style="float: right; font-size: 10px;">updated Mon Feb 3 2025 by Robert van Engelen</div>
     </td>
     <td width="10%">&nbsp;</td>
    </tr>
   </tbody>
  </table>
 </div>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">reflex Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacereflex_1_1convert__flag"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacereflex_1_1convert__flag.html">convert_flag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacereflex_1_1_posix"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacereflex_1_1_posix.html">Posix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacereflex_1_1_unicode"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacereflex_1_1_unicode.html">Unicode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract lexer class template that is the abstract root class of all reflex-generated scanners.  <a href="classreflex_1_1_abstract_lexer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html">AbstractMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract matcher base class template defines an interface for all pattern matcher engines.  <a href="classreflex_1_1_abstract_matcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html">Bits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RE/flex <a class="el" href="classreflex_1_1_bits.html" title="RE/flex Bits class for dynamic bit vectors. ">Bits</a> class for dynamic bit vectors.  <a href="classreflex_1_1_bits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_boost_matcher.html">BoostMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boost matcher engine class implements <a class="el" href="classreflex_1_1_pattern_matcher.html" title="The pattern matcher class template extends abstract matcher base class. ">reflex::PatternMatcher</a> pattern matching interface with scan, find, split functors and iterators, using the Boost::regex library.  <a href="classreflex_1_1_boost_matcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_boost_perl_matcher.html">BoostPerlMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boost matcher engine class, extends <a class="el" href="classreflex_1_1_boost_matcher.html" title="Boost matcher engine class implements reflex::PatternMatcher pattern matching interface with scan...">reflex::BoostMatcher</a> for Boost Perl regex matching.  <a href="classreflex_1_1_boost_perl_matcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_boost_posix_matcher.html">BoostPosixMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boost matcher engine class, extends <a class="el" href="classreflex_1_1_boost_matcher.html" title="Boost matcher engine class implements reflex::PatternMatcher pattern matching interface with scan...">reflex::BoostMatcher</a> for Boost POSIX regex matching.  <a href="classreflex_1_1_boost_posix_matcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_buffered_input.html">BufferedInput</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffered input.  <a href="classreflex_1_1_buffered_input.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html">FlexLexer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flex-compatible <a class="el" href="classreflex_1_1_flex_lexer.html" title="Flex-compatible FlexLexer abstract base class template derived from reflex::AbstractMatcher for the r...">FlexLexer</a> abstract base class template derived from <a class="el" href="classreflex_1_1_abstract_matcher.html" title="The abstract matcher base class template defines an interface for all pattern matcher engines...">reflex::AbstractMatcher</a> for the reflex-generated yyFlexLexer scanner class.  <a href="classreflex_1_1_flex_lexer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_fuzzy_matcher.html">FuzzyMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RE/flex fuzzy matcher engine class, implements <a class="el" href="classreflex_1_1_matcher.html" title="RE/flex matcher engine class, implements reflex::PatternMatcher pattern matching interface with scan...">reflex::Matcher</a> fuzzy pattern matching interface with scan, find, split functors and iterators.  <a href="classreflex_1_1_fuzzy_matcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html">Input</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> character sequence class for unified access to sources of input text.  <a href="classreflex_1_1_input.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreflex_1_1lazy__intersection.html">lazy_intersection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersection of two ordered sets, with an iterator to get elements lazely.  <a href="structreflex_1_1lazy__intersection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreflex_1_1lazy__union.html">lazy_union</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union of two ordered sets, with an iterator to get elements lazely.  <a href="structreflex_1_1lazy__union.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_line_matcher.html">LineMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Line matcher engine class implements <a class="el" href="classreflex_1_1_pattern_matcher.html" title="The pattern matcher class template extends abstract matcher base class. ">reflex::PatternMatcher</a> pattern matching interface with scan, find, split functors and iterators for matching lines only, use option 'A' to include newline with FIND, option 'N' to also FIND empty lines and option 'W' to only FIND empty lines.  <a href="classreflex_1_1_line_matcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html">Matcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RE/flex matcher engine class, implements <a class="el" href="classreflex_1_1_pattern_matcher.html" title="The pattern matcher class template extends abstract matcher base class. ">reflex::PatternMatcher</a> pattern matching interface with scan, find, split functors and iterators.  <a href="classreflex_1_1_matcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RE/flex <a class="el" href="classreflex_1_1_o_ranges.html" title="RE/flex ORanges (open-ended, ordinal value range) template class. ">ORanges</a> (open-ended, ordinal value range) template class.  <a href="classreflex_1_1_o_ranges.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_pattern.html">Pattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classreflex_1_1_pattern.html" title="Pattern class holds a regex pattern and its compiled FSM opcode table or code for the reflex::Matcher...">Pattern</a> class holds a regex pattern and its compiled FSM opcode table or code for the <a class="el" href="classreflex_1_1_matcher.html" title="RE/flex matcher engine class, implements reflex::PatternMatcher pattern matching interface with scan...">reflex::Matcher</a> engine.  <a href="classreflex_1_1_pattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_pattern_matcher.html">PatternMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pattern matcher class template extends abstract matcher base class.  <a href="classreflex_1_1_pattern_matcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_pattern_matcher_3_01std_1_1string_01_4.html">PatternMatcher&lt; std::string &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialization of the pattern matcher class template for std::string, extends abstract matcher base class.  <a href="classreflex_1_1_pattern_matcher_3_01std_1_1string_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_p_c_r_e2_matcher.html">PCRE2Matcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PCRE2 JIT-optimized matcher engine class implements <a class="el" href="classreflex_1_1_pattern_matcher.html" title="The pattern matcher class template extends abstract matcher base class. ">reflex::PatternMatcher</a> pattern matching interface with scan, find, split functors and iterators, using the PCRE2 library.  <a href="classreflex_1_1_p_c_r_e2_matcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_p_c_r_e2_u_t_f_matcher.html">PCRE2UTFMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PCRE2 JIT-optimized native PCRE2_UTF+PCRE2_UCP matcher engine class, extends <a class="el" href="classreflex_1_1_p_c_r_e2_matcher.html" title="PCRE2 JIT-optimized matcher engine class implements reflex::PatternMatcher pattern matching interface...">PCRE2Matcher</a>.  <a href="classreflex_1_1_p_c_r_e2_u_t_f_matcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreflex_1_1range__compare.html">range_compare</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor to define a total order on ranges (intervals) represented by pairs.  <a href="structreflex_1_1range__compare.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html">Ranges</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RE/flex <a class="el" href="classreflex_1_1_ranges.html" title="RE/flex Ranges template class. ">Ranges</a> template class.  <a href="classreflex_1_1_ranges.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1regex__error.html">regex_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regex syntax error exceptions.  <a href="classreflex_1_1regex__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_std_ecma_matcher.html">StdEcmaMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">std matcher engine class, extends <a class="el" href="classreflex_1_1_std_matcher.html" title="std matcher engine class implements reflex::PatternMatcher pattern matching interface with scan...">reflex::StdMatcher</a> for ECMA std::regex::ECMAScript syntax and regex matching.  <a href="classreflex_1_1_std_ecma_matcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_std_matcher.html">StdMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">std matcher engine class implements <a class="el" href="classreflex_1_1_pattern_matcher.html" title="The pattern matcher class template extends abstract matcher base class. ">reflex::PatternMatcher</a> pattern matching interface with scan, find, split functors and iterators, using the C++11 std::regex library.  <a href="classreflex_1_1_std_matcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_std_posix_matcher.html">StdPosixMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">std matcher engine class, extends <a class="el" href="classreflex_1_1_std_matcher.html" title="std matcher engine class implements reflex::PatternMatcher pattern matching interface with scan...">reflex::StdMatcher</a> for POSIX ERE std::regex::awk syntax and regex matching.  <a href="classreflex_1_1_std_posix_matcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreflex_1_1_type_op.html">TypeOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_type_op.html#a02e39f4769e38a61fc8e913f021630ca" title="TypeOp&lt;T&gt;::Type = T. ">TypeOp&lt;T&gt;::Type</a> = T, <a class="el" href="structreflex_1_1_type_op.html#a5d72c0bbda0b00fab2b38581a198f41d" title="TypeOp&lt;T&gt;::ConstType = const T. ">TypeOp&lt;T&gt;::ConstType</a> = const T, <a class="el" href="structreflex_1_1_type_op.html#a32e6baa1761b90ab91461d64f047693c" title="TypeOp&lt;T&gt;::NonConstType = non-const T. ">TypeOp&lt;T&gt;::NonConstType</a> = non-const T.  <a href="structreflex_1_1_type_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreflex_1_1_type_op_3_01const_01_t_01_4.html">TypeOp&lt; const T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization of <a class="el" href="structreflex_1_1_type_op.html" title="TypeOp&lt;T&gt;::Type = T, TypeOp&lt;T&gt;::ConstType = const T, TypeOp&lt;T&gt;::NonConstType = non-const T...">reflex::TypeOp</a>.  <a href="structreflex_1_1_type_op_3_01const_01_t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab659f1b759d66631c2e2e32771af1200"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacereflex.html#ab659f1b759d66631c2e2e32771af1200">convert_flag_type</a></td></tr>
<tr class="memdesc:ab659f1b759d66631c2e2e32771af1200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion flags for <a class="el" href="namespacereflex.html#ab15e99233257097b3c83c47d9ce3f9e6" title="Returns the converted regex string given a regex library signature and conversion flags...">reflex::convert</a>.  <a href="#ab659f1b759d66631c2e2e32771af1200">More...</a><br /></td></tr>
<tr class="separator:ab659f1b759d66631c2e2e32771af1200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776c689092282b15974a151328083b2d"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacereflex.html#a776c689092282b15974a151328083b2d">regex_error_type</a></td></tr>
<tr class="memdesc:a776c689092282b15974a151328083b2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regex syntax error exception error code.  <a href="#a776c689092282b15974a151328083b2d">More...</a><br /></td></tr>
<tr class="separator:a776c689092282b15974a151328083b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87040a2fe4499e9b735f2564a50c58b9"><td class="memItemLeft" align="right" valign="top">typedef timeval&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacereflex.html#a87040a2fe4499e9b735f2564a50c58b9">timer_type</a></td></tr>
<tr class="separator:a87040a2fe4499e9b735f2564a50c58b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a10f9faa3bb7ef4d3cee8339b8e647875"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacereflex.html#a10f9faa3bb7ef4d3cee8339b8e647875">isword</a> (int c)</td></tr>
<tr class="memdesc:a10f9faa3bb7ef4d3cee8339b8e647875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check ASCII word-like character <code>[A-Za-z0-9_]</code>, permitting the character range 0..303 (0x12f) and EOF.  <a href="#a10f9faa3bb7ef4d3cee8339b8e647875">More...</a><br /></td></tr>
<tr class="separator:a10f9faa3bb7ef4d3cee8339b8e647875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15e99233257097b3c83c47d9ce3f9e6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacereflex.html#ab15e99233257097b3c83c47d9ce3f9e6">convert</a> (const char *pattern, const char *signature, <a class="el" href="namespacereflex.html#ab659f1b759d66631c2e2e32771af1200">convert_flag_type</a> flags=<a class="el" href="namespacereflex_1_1convert__flag.html#af5c6fe22fc79bb893e135d583d525930">convert_flag::none</a>, bool *multiline=NULL, const std::map&lt; std::string, std::string &gt; *macros=NULL)</td></tr>
<tr class="memdesc:ab15e99233257097b3c83c47d9ce3f9e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the converted regex string given a regex library signature and conversion flags, throws <a class="el" href="classreflex_1_1regex__error.html" title="Regex syntax error exceptions. ">regex_error</a>.  <a href="#ab15e99233257097b3c83c47d9ce3f9e6">More...</a><br /></td></tr>
<tr class="separator:ab15e99233257097b3c83c47d9ce3f9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f99860b0eb4399bff6606da99a04d0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacereflex.html#a37f99860b0eb4399bff6606da99a04d0">convert</a> (const std::string &amp;pattern, const char *signature, <a class="el" href="namespacereflex.html#ab659f1b759d66631c2e2e32771af1200">convert_flag_type</a> flags=<a class="el" href="namespacereflex_1_1convert__flag.html#af5c6fe22fc79bb893e135d583d525930">convert_flag::none</a>, bool *multiline=NULL, const std::map&lt; std::string, std::string &gt; *macros=NULL)</td></tr>
<tr class="separator:a37f99860b0eb4399bff6606da99a04d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ddc0e05a07aef0bf8aaba5e9f3f864"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacereflex.html#a02ddc0e05a07aef0bf8aaba5e9f3f864">supports_modifier</a> (const char *signature, int modchar)</td></tr>
<tr class="separator:a02ddc0e05a07aef0bf8aaba5e9f3f864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc06313cb03adf38f0cbf1a4667dbf3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacereflex.html#a2cc06313cb03adf38f0cbf1a4667dbf3">supports_escape</a> (const char *signature, int escape)</td></tr>
<tr class="separator:a2cc06313cb03adf38f0cbf1a4667dbf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28a7d81300acbe54be048b558352c22"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacereflex.html#af28a7d81300acbe54be048b558352c22">ztoa</a> (size_t n)</td></tr>
<tr class="separator:af28a7d81300acbe54be048b558352c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3deed9d6b147d91074913f47c330d232"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 &gt; </td></tr>
<tr class="memitem:a3deed9d6b147d91074913f47c330d232"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacereflex.html#a3deed9d6b147d91074913f47c330d232">is_disjoint</a> (const S1 &amp;s1, const S2 &amp;s2)</td></tr>
<tr class="memdesc:a3deed9d6b147d91074913f47c330d232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if sets <code>s1</code> and <code>s2</code> are disjoint.  <a href="#a3deed9d6b147d91074913f47c330d232">More...</a><br /></td></tr>
<tr class="separator:a3deed9d6b147d91074913f47c330d232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a990336f7c3c72595d034bd685ee5c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:a53a990336f7c3c72595d034bd685ee5c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacereflex.html#a53a990336f7c3c72595d034bd685ee5c">is_in_set</a> (const T &amp;x, const S &amp;s)</td></tr>
<tr class="memdesc:a53a990336f7c3c72595d034bd685ee5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if value <code>x</code> is in set <code>s</code>.  <a href="#a53a990336f7c3c72595d034bd685ee5c">More...</a><br /></td></tr>
<tr class="separator:a53a990336f7c3c72595d034bd685ee5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088abc7ab84436832139b9c106cad426"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 &gt; </td></tr>
<tr class="memitem:a088abc7ab84436832139b9c106cad426"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacereflex.html#a088abc7ab84436832139b9c106cad426">is_subset</a> (const S1 &amp;s1, const S2 &amp;s2)</td></tr>
<tr class="memdesc:a088abc7ab84436832139b9c106cad426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if set <code>s1</code> is a subset of set <code>s2</code>.  <a href="#a088abc7ab84436832139b9c106cad426">More...</a><br /></td></tr>
<tr class="separator:a088abc7ab84436832139b9c106cad426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f035f9bac92cfcc709fd34844805d4"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 &gt; </td></tr>
<tr class="memitem:ae6f035f9bac92cfcc709fd34844805d4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacereflex.html#ae6f035f9bac92cfcc709fd34844805d4">set_insert</a> (S1 &amp;s1, const S2 &amp;s2)</td></tr>
<tr class="memdesc:ae6f035f9bac92cfcc709fd34844805d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert set <code>s2</code> into set <code>s1</code>.  <a href="#ae6f035f9bac92cfcc709fd34844805d4">More...</a><br /></td></tr>
<tr class="separator:ae6f035f9bac92cfcc709fd34844805d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88de06cf5dcc21d8bace132a66d0753"><td class="memTemplParams" colspan="2">template&lt;typename S , typename E &gt; </td></tr>
<tr class="memitem:ab88de06cf5dcc21d8bace132a66d0753"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacereflex.html#ab88de06cf5dcc21d8bace132a66d0753">set_add</a> (S &amp;s, const E &amp;e)</td></tr>
<tr class="memdesc:ab88de06cf5dcc21d8bace132a66d0753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert element <code>e</code> into set <code>s</code>.  <a href="#ab88de06cf5dcc21d8bace132a66d0753">More...</a><br /></td></tr>
<tr class="separator:ab88de06cf5dcc21d8bace132a66d0753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677294e5ecf35a97b41e72370672f3bc"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 &gt; </td></tr>
<tr class="memitem:a677294e5ecf35a97b41e72370672f3bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacereflex.html#a677294e5ecf35a97b41e72370672f3bc">set_delete</a> (S1 &amp;s1, const S2 &amp;s2)</td></tr>
<tr class="memdesc:a677294e5ecf35a97b41e72370672f3bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete elements of set <code>s2</code> from set <code>s1</code>.  <a href="#a677294e5ecf35a97b41e72370672f3bc">More...</a><br /></td></tr>
<tr class="separator:a677294e5ecf35a97b41e72370672f3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab818b62aa222cc288dfdd6b72198b0e4"><td class="memTemplParams" colspan="2">template&lt;typename S , typename E &gt; </td></tr>
<tr class="memitem:ab818b62aa222cc288dfdd6b72198b0e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacereflex.html#ab818b62aa222cc288dfdd6b72198b0e4">set_erase</a> (S &amp;s, const E &amp;e)</td></tr>
<tr class="memdesc:ab818b62aa222cc288dfdd6b72198b0e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove element <code>e</code> from set <code>s</code> when present.  <a href="#ab818b62aa222cc288dfdd6b72198b0e4">More...</a><br /></td></tr>
<tr class="separator:ab818b62aa222cc288dfdd6b72198b0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d50452d59b78229c800cffff315525"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacereflex.html#a52d50452d59b78229c800cffff315525">nlcount</a> (const char *s, const char *e)</td></tr>
<tr class="memdesc:a52d50452d59b78229c800cffff315525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count newlines in string s up to position e in the string.  <a href="#a52d50452d59b78229c800cffff315525">More...</a><br /></td></tr>
<tr class="separator:a52d50452d59b78229c800cffff315525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74e91cfc995859be6e69f954c0bcc10"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacereflex.html#ab74e91cfc995859be6e69f954c0bcc10">isutf8</a> (const char *s, const char *e)</td></tr>
<tr class="memdesc:ab74e91cfc995859be6e69f954c0bcc10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if valid UTF-8 encoding and does not include a NUL, but accept surrogates and 3/4 byte overlongs.  <a href="#ab74e91cfc995859be6e69f954c0bcc10">More...</a><br /></td></tr>
<tr class="separator:ab74e91cfc995859be6e69f954c0bcc10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71864a441be594417621cd31599387fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacereflex.html#a71864a441be594417621cd31599387fa">timer_start</a> (<a class="el" href="namespacereflex.html#a87040a2fe4499e9b735f2564a50c58b9">timer_type</a> &amp;t)</td></tr>
<tr class="memdesc:a71864a441be594417621cd31599387fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start timer.  <a href="#a71864a441be594417621cd31599387fa">More...</a><br /></td></tr>
<tr class="separator:a71864a441be594417621cd31599387fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf44e022201a15a81b11e2c13892176a"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacereflex.html#adf44e022201a15a81b11e2c13892176a">timer_elapsed</a> (<a class="el" href="namespacereflex.html#a87040a2fe4499e9b735f2564a50c58b9">timer_type</a> &amp;t)</td></tr>
<tr class="memdesc:adf44e022201a15a81b11e2c13892176a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return elapsed time in milliseconds (ms) with microsecond precision since the last call up to 1 minute (wraps if elapsed time exceeds 1 minute!)  <a href="#adf44e022201a15a81b11e2c13892176a">More...</a><br /></td></tr>
<tr class="separator:adf44e022201a15a81b11e2c13892176a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc2e91b0f3e1b8bb2611304c8c0e6ee"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacereflex.html#a5cc2e91b0f3e1b8bb2611304c8c0e6ee">latin1</a> (int a, int b, int esc= 'x', bool brackets=true)</td></tr>
<tr class="memdesc:a5cc2e91b0f3e1b8bb2611304c8c0e6ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an 8-bit ASCII + Latin-1 Supplement range [a,b] to a regex pattern.  <a href="#a5cc2e91b0f3e1b8bb2611304c8c0e6ee">More...</a><br /></td></tr>
<tr class="separator:a5cc2e91b0f3e1b8bb2611304c8c0e6ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bef462a65804089ae20c74dede75782"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacereflex.html#a7bef462a65804089ae20c74dede75782">utf8</a> (int a, int b, int esc= 'x', const char *par=&quot;(&quot;, bool strict=true)</td></tr>
<tr class="memdesc:a7bef462a65804089ae20c74dede75782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a UCS-4 range [a,b] to a UTF-8 regex pattern.  <a href="#a7bef462a65804089ae20c74dede75782">More...</a><br /></td></tr>
<tr class="separator:a7bef462a65804089ae20c74dede75782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225d16c59f5f54f400412ed6cd4f340a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacereflex.html#a225d16c59f5f54f400412ed6cd4f340a">utf8</a> (int c, char *s)</td></tr>
<tr class="memdesc:a225d16c59f5f54f400412ed6cd4f340a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert UCS-4 to UTF-8, fills with REFLEX_NONCHAR_UTF8 when out of range, or unrestricted UTF-8 with WITH_UTF8_UNRESTRICTED.  <a href="#a225d16c59f5f54f400412ed6cd4f340a">More...</a><br /></td></tr>
<tr class="separator:a225d16c59f5f54f400412ed6cd4f340a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe93907a6b71a3e0b7688bec72638e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacereflex.html#a2fe93907a6b71a3e0b7688bec72638e4">utf8</a> (const char *s, const char **r=NULL)</td></tr>
<tr class="memdesc:a2fe93907a6b71a3e0b7688bec72638e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert UTF-8 to UCS, returns REFLEX_NONCHAR for invalid UTF-8 except for MUTF-8 U+0000 and 0xD800-0xDFFF surrogate halves (use WITH_UTF8_UNRESTRICTED to remove any limits on UTF-8 encodings up to 6 bytes).  <a href="#a2fe93907a6b71a3e0b7688bec72638e4">More...</a><br /></td></tr>
<tr class="separator:a2fe93907a6b71a3e0b7688bec72638e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b96269b32fa93759f21bf76427aa3fd"><td class="memItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacereflex.html#a0b96269b32fa93759f21bf76427aa3fd">wcs</a> (const char *s, size_t n)</td></tr>
<tr class="memdesc:a0b96269b32fa93759f21bf76427aa3fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert UTF-8 string to wide string.  <a href="#a0b96269b32fa93759f21bf76427aa3fd">More...</a><br /></td></tr>
<tr class="separator:a0b96269b32fa93759f21bf76427aa3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713b79db623aa036afa3aa7f4fda8d5b"><td class="memItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacereflex.html#a713b79db623aa036afa3aa7f4fda8d5b">wcs</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a713b79db623aa036afa3aa7f4fda8d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert UTF-8 string to wide string.  <a href="#a713b79db623aa036afa3aa7f4fda8d5b">More...</a><br /></td></tr>
<tr class="separator:a713b79db623aa036afa3aa7f4fda8d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3e83e0fe35315269713462330b0fe05b"><td class="memItemLeft" align="right" valign="top">const unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacereflex.html#a3e83e0fe35315269713462330b0fe05b">codepages</a> [][256]</td></tr>
<tr class="separator:a3e83e0fe35315269713462330b0fe05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ab659f1b759d66631c2e2e32771af1200"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="namespacereflex.html#ab659f1b759d66631c2e2e32771af1200">reflex::convert_flag_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Conversion flags for <a class="el" href="namespacereflex.html#ab15e99233257097b3c83c47d9ce3f9e6" title="Returns the converted regex string given a regex library signature and conversion flags...">reflex::convert</a>. </p>

</div>
</div>
<a class="anchor" id="a776c689092282b15974a151328083b2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="namespacereflex.html#a776c689092282b15974a151328083b2d">reflex::regex_error_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Regex syntax error exception error code. </p>

</div>
</div>
<a class="anchor" id="a87040a2fe4499e9b735f2564a50c58b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef timeval <a class="el" href="namespacereflex.html#a87040a2fe4499e9b735f2564a50c58b9">reflex::timer_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ab15e99233257097b3c83c47d9ce3f9e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string reflex::convert </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacereflex.html#ab659f1b759d66631c2e2e32771af1200">convert_flag_type</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespacereflex_1_1convert__flag.html#af5c6fe22fc79bb893e135d583d525930">convert_flag::none</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>multiline</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; *&#160;</td>
          <td class="paramname"><em>macros</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the converted regex string given a regex library signature and conversion flags, throws <a class="el" href="classreflex_1_1regex__error.html" title="Regex syntax error exceptions. ">regex_error</a>. </p>
<p>A regex library signature is a string of the form <code>"decls:escapes?+."</code>.</p>
<p>The optional <code>"decls:"</code> part specifies which modifiers and other special <code>(?...)</code> constructs are supported:</p><ul>
<li>non-capturing group <code>(?:...)</code> is supported</li>
<li>letters and digits specify which modifiers e.g. (?ismx) are supported:</li>
<li>'i' specifies that <code>(?i...)</code> case-insensitive matching is supported</li>
<li>'m' specifies that <code>(?m...)</code> multiline mode is supported for the ^ and $ anchors</li>
<li>'s' specifies that <code>(?s...)</code> dotall mode is supported</li>
<li>'x' specifies that <code>(?x...)</code> freespace mode is supported</li>
<li>... any other letter or digit modifier, where digit modifiers support <code>(?123)</code> for example</li>
<li><code>#</code> specifies that <code>(?#...)</code> comments are supported</li>
<li><code>=</code> specifies that <code>(?=...)</code> lookahead is supported</li>
<li><code>&lt;</code> specifies that `(?'...)` 'name' groups are supported</li>
<li><code>&lt;</code> specifies that <code>(?&lt;...)</code> lookbehind and &lt;name&gt; groups are supported</li>
<li><code>&gt;</code> specifies that <code>(?&gt;...)</code> atomic groups are supported</li>
<li><code>&gt;</code> specifies that <code>(?|...)</code> group resets are supported</li>
<li><code>&gt;</code> specifies that <code>(?&amp;...)</code> subroutines are supported</li>
<li><code>&gt;</code> specifies that <code>(?(...)</code> conditionals are supported</li>
<li><code>!</code> specifies that <code>(?!=...)</code> and <code>(?!&lt;...)</code> are supported</li>
<li><code>^</code> specifies that <code>(?^...)</code> negative (reflex) patterns are supported</li>
<li><code>*</code> specifies that <code>(*VERB)</code> verbs are supported</li>
</ul>
<p>The <code>"escapes"</code> characters specify which standard escapes are supported:</p><ul>
<li><code>a</code> for <code>\a</code> (BEL U+0007)</li>
<li><code>b</code> for <code>\b</code> the <code>\b</code> word boundary</li>
<li><code>c</code> for <code>\cX</code> control character specified by <code>X</code> modulo 32</li>
<li><code>d</code> for <code>\d</code> digit <code>[0-9]</code> ASCII or <a class="el" href="namespacereflex_1_1_unicode.html">Unicode</a> digit</li>
<li><code>e</code> for <code>\e</code> ESC U+001B</li>
<li><code>f</code> for <code>\f</code> FF U+000C</li>
<li><code>j</code> for <code>\g</code> group capture e.g. {1}</li>
<li><code>h</code> for <code>\h</code> ASCII blank <code>[ \t]</code> (SP U+0020 or TAB U+0009)</li>
<li><code>i</code> for <code>\i</code> reflex indent anchor</li>
<li><code>j</code> for <code>\j</code> reflex dedent anchor</li>
<li><code>j</code> for <code>\k</code> reflex undent anchor or group capture e.g. {1}</li>
<li><code>l</code> for <code>\l</code> lower case letter <code>[a-z]</code> ASCII or <a class="el" href="namespacereflex_1_1_unicode.html">Unicode</a> letter</li>
<li><code>n</code> for <code>\n</code> LF U+000A</li>
<li><code>o</code> for <code>\o</code> octal ASCII or <a class="el" href="namespacereflex_1_1_unicode.html">Unicode</a> code</li>
<li><code>p</code> for <code>\p{C}</code> <a class="el" href="namespacereflex_1_1_unicode.html">Unicode</a> character classes, also implies <a class="el" href="namespacereflex_1_1_unicode.html">Unicode</a> ., {X}, , , , , , and UTF-8 patterns</li>
<li><code>r</code> for <code>\r</code> CR U+000D</li>
<li><code>s</code> for <code>\s</code> space (SP, TAB, LF, VT, FF, or CR)</li>
<li><code>t</code> for <code>\t</code> TAB U+0009</li>
<li><code>u</code> for <code>\u</code> ASCII upper case letter <code>[A-Z]</code> (when not followed by <code>{XXXX}</code>)</li>
<li><code>v</code> for <code>\v</code> VT U+000B</li>
<li><code>w</code> for <code>\w</code> ASCII word-like character <code>[0-9A-Z_a-z]</code></li>
<li><code>x</code> for <code>\xXX</code> 8-bit character encoding in hexadecimal</li>
<li><code>y</code> for <code>\y</code> word boundary</li>
<li><code>z</code> for <code>\z</code> end of input anchor</li>
<li>`<code>for `\</code> begin of input anchor</li>
<li><code>'</code> for <code>\'</code> end of input anchor</li>
<li><code>&lt;</code> for <code>\&lt;</code> left word boundary</li>
<li><code>&gt;</code> for <code>\&gt;</code> right word boundary</li>
<li><code>A</code> for <code>\A</code> begin of input anchor</li>
<li><code>B</code> for <code>\B</code> non-word boundary</li>
<li><code>D</code> for <code>\D</code> ASCII non-digit <code>[^0-9]</code></li>
<li><code>H</code> for <code>\H</code> ASCII non-blank <code>[^ \t]</code></li>
<li><code>L</code> for <code>\L</code> ASCII non-lower case letter <code>[^a-z]</code></li>
<li><code>N</code> for <code>\N</code> not a newline</li>
<li><code>P</code> for <code>\P{C}</code> <a class="el" href="namespacereflex_1_1_unicode.html">Unicode</a> inverse character classes, see 'p'</li>
<li><code>Q</code> for <code>\Q...\E</code> quotations</li>
<li><code>R</code> for <code>\R</code> <a class="el" href="namespacereflex_1_1_unicode.html">Unicode</a> line break</li>
<li><code>S</code> for <code>\S</code> ASCII non-space (no SP, TAB, LF, VT, FF, or CR)</li>
<li><code>U</code> for <code>\U</code> ASCII non-upper case letter <code>[^A-Z]</code></li>
<li><code>W</code> for <code>\W</code> ASCII non-word-like character <code>[^0-9A-Z_a-z]</code></li>
<li><code>X</code> for <code>\X</code> any <a class="el" href="namespacereflex_1_1_unicode.html">Unicode</a> character</li>
<li><code>Z</code> for <code>\Z</code> end of input anchor, before the final line break</li>
<li><code>0</code> for <code>\0nnn</code> 8-bit character encoding in octal requires a leading <code>0</code></li>
<li>'1' to '9' for backreferences (not applicable to lexer specifications)</li>
</ul>
<p>Note that 'p' is a special case to support Unicode-based matchers that natively support UTF8 patterns and <a class="el" href="namespacereflex_1_1_unicode.html">Unicode</a> classes <code></code>{C}, {C}, , , , , , , , , , and {X}. Basically, 'p' prevents conversion of <a class="el" href="namespacereflex_1_1_unicode.html">Unicode</a> patterns to UTF8. This special case does not support {NAME} expansions in bracket lists such as [a-z||{upper}] and {lower}{+}{upper} used in lexer specifications.</p>
<p>The optional <code>"?+"</code> specify lazy and possessive support:</p><ul>
<li><code>?</code> lazy quantifiers for repeats are supported</li>
<li><code>+</code> possessive quantifiers for repeats are supported</li>
</ul>
<p>An optional <code>"."</code> (dot) specifies that dot matches any character except newline. A dot is implied by the presence of the 's' modifier, and can be omitted in that case.</p>
<p>An optional <code>"["</code> specifies that bracket list union, intersection, and subtraction are supported, i.e. [&ndash;[a-z]]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>regex string pattern to convert </td></tr>
    <tr><td class="paramname">signature</td><td>regex library signature </td></tr>
    <tr><td class="paramname">flags</td><td>conversion flags </td></tr>
    <tr><td class="paramname">multiline</td><td>set to true if pattern may be multiline </td></tr>
    <tr><td class="paramname">macros</td><td>{name} macros to expand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a37f99860b0eb4399bff6606da99a04d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string reflex::convert </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacereflex.html#ab659f1b759d66631c2e2e32771af1200">convert_flag_type</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespacereflex_1_1convert__flag.html#af5c6fe22fc79bb893e135d583d525930">convert_flag::none</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>multiline</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; *&#160;</td>
          <td class="paramname"><em>macros</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3deed9d6b147d91074913f47c330d232"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S1 , typename S2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::is_disjoint </td>
          <td>(</td>
          <td class="paramtype">const S1 &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S2 &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if sets <code>s1</code> and <code>s2</code> are disjoint. </p>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

</div>
</div>
<a class="anchor" id="a53a990336f7c3c72595d034bd685ee5c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::is_in_set </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if value <code>x</code> is in set <code>s</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

</div>
</div>
<a class="anchor" id="a088abc7ab84436832139b9c106cad426"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S1 , typename S2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::is_subset </td>
          <td>(</td>
          <td class="paramtype">const S1 &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S2 &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if set <code>s1</code> is a subset of set <code>s2</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

</div>
</div>
<a class="anchor" id="ab74e91cfc995859be6e69f954c0bcc10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::isutf8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if valid UTF-8 encoding and does not include a NUL, but accept surrogates and 3/4 byte overlongs. </p>

</div>
</div>
<a class="anchor" id="a10f9faa3bb7ef4d3cee8339b8e647875"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int reflex::isword </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check ASCII word-like character <code>[A-Za-z0-9_]</code>, permitting the character range 0..303 (0x12f) and EOF. </p>
<dl class="section return"><dt>Returns</dt><dd>nonzero if argument c is in <code>[A-Za-z0-9_]</code>, zero otherwise </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Character to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5cc2e91b0f3e1b8bb2611304c8c0e6ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string reflex::latin1 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>esc</em> = <code>'x'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>brackets</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an 8-bit ASCII + Latin-1 Supplement range [a,b] to a regex pattern. </p>
<dl class="section return"><dt>Returns</dt><dd>regex string to match the UCS range encoded in UTF-8 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>lower bound of UCS range </td></tr>
    <tr><td class="paramname">b</td><td>upper bound of UCS range </td></tr>
    <tr><td class="paramname">esc</td><td>escape char 'x' for hex , or '0' or '\0' for octal \0nnn and  </td></tr>
    <tr><td class="paramname">brackets</td><td>place in [ brackets ] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a52d50452d59b78229c800cffff315525"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::nlcount </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count newlines in string s up to position e in the string. </p>

</div>
</div>
<a class="anchor" id="ab88de06cf5dcc21d8bace132a66d0753"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::set_add </td>
          <td>(</td>
          <td class="paramtype">S &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert element <code>e</code> into set <code>s</code>. </p>

</div>
</div>
<a class="anchor" id="a677294e5ecf35a97b41e72370672f3bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S1 , typename S2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void reflex::set_delete </td>
          <td>(</td>
          <td class="paramtype">S1 &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S2 &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete elements of set <code>s2</code> from set <code>s1</code>. </p>

</div>
</div>
<a class="anchor" id="ab818b62aa222cc288dfdd6b72198b0e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void reflex::set_erase </td>
          <td>(</td>
          <td class="paramtype">S &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove element <code>e</code> from set <code>s</code> when present. </p>

</div>
</div>
<a class="anchor" id="ae6f035f9bac92cfcc709fd34844805d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S1 , typename S2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::set_insert </td>
          <td>(</td>
          <td class="paramtype">S1 &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S2 &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert set <code>s2</code> into set <code>s1</code>. </p>

</div>
</div>
<a class="anchor" id="a2cc06313cb03adf38f0cbf1a4667dbf3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::supports_escape </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>escape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a02ddc0e05a07aef0bf8aaba5e9f3f864"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::supports_modifier </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>modchar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adf44e022201a15a81b11e2c13892176a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float reflex::timer_elapsed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacereflex.html#a87040a2fe4499e9b735f2564a50c58b9">timer_type</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return elapsed time in milliseconds (ms) with microsecond precision since the last call up to 1 minute (wraps if elapsed time exceeds 1 minute!) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>timer to be updated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a71864a441be594417621cd31599387fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::timer_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacereflex.html#a87040a2fe4499e9b735f2564a50c58b9">timer_type</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>timer to be initialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7bef462a65804089ae20c74dede75782"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string reflex::utf8 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>esc</em> = <code>'x'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>par</em> = <code>&quot;(&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a UCS-4 range [a,b] to a UTF-8 regex pattern. </p>
<dl class="section return"><dt>Returns</dt><dd>regex string to match the UCS range encoded in UTF-8 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>lower bound of UCS range </td></tr>
    <tr><td class="paramname">b</td><td>upper bound of UCS range </td></tr>
    <tr><td class="paramname">esc</td><td>escape char 'x' for hex , or '0' or '\0' for octal \0nnn and  </td></tr>
    <tr><td class="paramname">par</td><td>capturing or non-capturing parenthesis "(?:" </td></tr>
    <tr><td class="paramname">strict</td><td>returned regex is strict UTF-8 (true) or permissive and lean UTF-8 (false) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a225d16c59f5f54f400412ed6cd4f340a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::utf8 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert UCS-4 to UTF-8, fills with REFLEX_NONCHAR_UTF8 when out of range, or unrestricted UTF-8 with WITH_UTF8_UNRESTRICTED. </p>
<dl class="section return"><dt>Returns</dt><dd>length (in bytes) of UTF-8 character sequence stored in s </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>UCS-4 character U+0000 to U+10ffff (unless WITH_UTF8_UNRESTRICTED) </td></tr>
    <tr><td class="paramname">s</td><td>points to the buffer to populate with UTF-8 (1 to 6 bytes) not NUL-terminated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2fe93907a6b71a3e0b7688bec72638e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int reflex::utf8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>r</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert UTF-8 to UCS, returns REFLEX_NONCHAR for invalid UTF-8 except for MUTF-8 U+0000 and 0xD800-0xDFFF surrogate halves (use WITH_UTF8_UNRESTRICTED to remove any limits on UTF-8 encodings up to 6 bytes). </p>
<dl class="section return"><dt>Returns</dt><dd>UCS character </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>points to the buffer with UTF-8 (1 to 6 bytes) </td></tr>
    <tr><td class="paramname">r</td><td>points to pointer to set to the new position in s after the UTF-8 sequence, optional </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0b96269b32fa93759f21bf76427aa3fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring reflex::wcs </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert UTF-8 string to wide string. </p>
<dl class="section return"><dt>Returns</dt><dd>wide string </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>string with UTF-8 to convert </td></tr>
    <tr><td class="paramname">n</td><td>length of the string to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a713b79db623aa036afa3aa7f4fda8d5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring reflex::wcs </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert UTF-8 string to wide string. </p>
<dl class="section return"><dt>Returns</dt><dd>wide string </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>string with UTF-8 to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af28a7d81300acbe54be048b558352c22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string reflex::ztoa </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a3e83e0fe35315269713462330b0fe05b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned short reflex::codepages[][256]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<hr class="footer">
<address class="footer"><small>
Converted on Mon Feb 3 2025 13:39:53 by <a target="_blank" href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.11</small></address>
<br>
<div style="height: 246px; background: #DBDBDB;">
</body>
</html>
