<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta http-equiv="cache-control" content="no-cache">
<title>reflex::ORanges&lt; T &gt; Class Template Reference</title>
<link href="doxygen_tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="doxygen_content.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top">
 <div id="titlearea">
  <table height="72px" width="100%" cellspacing="0" cellpadding="0">
   <tbody>
    <tr>
     <td width="10%">&nbsp;</td>
     <td><a href="https://github.com/Genivia/RE-flex"><img src="reflex-logo.png"/></a></td>
     <td>
      <div style="float: right; font-size: 18px; font-weight: bold;">reflex::ORanges&lt; T &gt; Class Template Reference</div>
      <br>
      <div style="float: right; font-size: 10px;">updated Tue Oct 29 2024 by Robert van Engelen</div>
     </td>
     <td width="10%">&nbsp;</td>
    </tr>
   </tbody>
  </table>
 </div>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacereflex.html">reflex</a></li><li class="navelem"><a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="classreflex_1_1_o_ranges-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">reflex::ORanges&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>RE/flex <a class="el" href="classreflex_1_1_o_ranges.html" title="RE/flex ORanges (open-ended, ordinal value range) template class. ">ORanges</a> (open-ended, ordinal value range) template class.  
 <a href="classreflex_1_1_o_ranges.html#details">More...</a></p>

<p><code>#include &lt;ranges.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for reflex::ORanges&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classreflex_1_1_o_ranges__inherit__graph.png" border="0" usemap="#reflex_1_1_o_ranges_3_01_t_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="reflex_1_1_o_ranges_3_01_t_01_4_inherit__map" id="reflex_1_1_o_ranges_3_01_t_01_4_inherit__map">
<area shape="rect" id="node2" href="classreflex_1_1_ranges.html" title="RE/flex Ranges template class. " alt="" coords="21,109,159,136"/>
<area shape="rect" id="node3" title="STL class. " alt="" coords="5,5,175,61"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for reflex::ORanges&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classreflex_1_1_o_ranges__coll__graph.png" border="0" usemap="#reflex_1_1_o_ranges_3_01_t_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="reflex_1_1_o_ranges_3_01_t_01_4_coll__map" id="reflex_1_1_o_ranges_3_01_t_01_4_coll__map">
<area shape="rect" id="node2" href="classreflex_1_1_ranges.html" title="RE/flex Ranges template class. " alt="" coords="21,200,159,227"/>
<area shape="rect" id="node3" title="STL class. " alt="" coords="5,95,175,151"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9306ca6343c93417ee45602d1e854a0f"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#a9306ca6343c93417ee45602d1e854a0f">bound_type</a></td></tr>
<tr class="memdesc:a9306ca6343c93417ee45602d1e854a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the bounds.  <a href="#a9306ca6343c93417ee45602d1e854a0f">More...</a><br /></td></tr>
<tr class="separator:a9306ca6343c93417ee45602d1e854a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2279c7fc683a9719345e6150c9720e2a"><td class="memItemLeft" align="right" valign="top">typedef std::set&lt; std::pair&lt; T, T &gt;, <a class="el" href="structreflex_1_1range__compare.html">range_compare</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#a2279c7fc683a9719345e6150c9720e2a">container_type</a></td></tr>
<tr class="memdesc:a2279c7fc683a9719345e6150c9720e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym type defining the base class container std::set.  <a href="#a2279c7fc683a9719345e6150c9720e2a">More...</a><br /></td></tr>
<tr class="separator:a2279c7fc683a9719345e6150c9720e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34350a20bbd8f9f719e2f3144df55942"><td class="memItemLeft" align="right" valign="top">typedef container_type::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#a34350a20bbd8f9f719e2f3144df55942">value_type</a></td></tr>
<tr class="memdesc:a34350a20bbd8f9f719e2f3144df55942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym type defining the base class container std::set::value_type.  <a href="#a34350a20bbd8f9f719e2f3144df55942">More...</a><br /></td></tr>
<tr class="separator:a34350a20bbd8f9f719e2f3144df55942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0f99be50ac378e9a9c8fb0257b833c"><td class="memItemLeft" align="right" valign="top">typedef container_type::key_compare&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#a4a0f99be50ac378e9a9c8fb0257b833c">key_compare</a></td></tr>
<tr class="memdesc:a4a0f99be50ac378e9a9c8fb0257b833c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym type defining the key/value comparison std::set::key_compare.  <a href="#a4a0f99be50ac378e9a9c8fb0257b833c">More...</a><br /></td></tr>
<tr class="separator:a4a0f99be50ac378e9a9c8fb0257b833c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53348dfe78ee8b514273aaea6f6e6fb"><td class="memItemLeft" align="right" valign="top">typedef container_type::value_compare&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#af53348dfe78ee8b514273aaea6f6e6fb">value_compare</a></td></tr>
<tr class="separator:af53348dfe78ee8b514273aaea6f6e6fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a822980610d3f4deb3cb0e42ad49a85"><td class="memItemLeft" align="right" valign="top">typedef container_type::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#a2a822980610d3f4deb3cb0e42ad49a85">iterator</a></td></tr>
<tr class="memdesc:a2a822980610d3f4deb3cb0e42ad49a85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym type defining the base class container std::set::iterator.  <a href="#a2a822980610d3f4deb3cb0e42ad49a85">More...</a><br /></td></tr>
<tr class="separator:a2a822980610d3f4deb3cb0e42ad49a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7ea78d89f343eaeb7329d9f73e7f47"><td class="memItemLeft" align="right" valign="top">typedef container_type::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#add7ea78d89f343eaeb7329d9f73e7f47">const_iterator</a></td></tr>
<tr class="memdesc:add7ea78d89f343eaeb7329d9f73e7f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym type defining the base class container std::set::const_iterator.  <a href="#add7ea78d89f343eaeb7329d9f73e7f47">More...</a><br /></td></tr>
<tr class="separator:add7ea78d89f343eaeb7329d9f73e7f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classreflex_1_1_ranges"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classreflex_1_1_ranges')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classreflex_1_1_ranges.html">reflex::Ranges&lt; T &gt;</a></td></tr>
<tr class="memitem:a5932a3dc82b3b47baa01c205b40eec64 inherit pub_types_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a></td></tr>
<tr class="memdesc:a5932a3dc82b3b47baa01c205b40eec64 inherit pub_types_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the bounds.  <a href="#a5932a3dc82b3b47baa01c205b40eec64">More...</a><br /></td></tr>
<tr class="separator:a5932a3dc82b3b47baa01c205b40eec64 inherit pub_types_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed84540bbb395b6f0bc21cb8ea169f1 inherit pub_types_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">typedef std::set&lt; std::pair&lt; T, T &gt;, <a class="el" href="structreflex_1_1range__compare.html">range_compare</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a7ed84540bbb395b6f0bc21cb8ea169f1">container_type</a></td></tr>
<tr class="memdesc:a7ed84540bbb395b6f0bc21cb8ea169f1 inherit pub_types_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym type defining the base class container std::set.  <a href="#a7ed84540bbb395b6f0bc21cb8ea169f1">More...</a><br /></td></tr>
<tr class="separator:a7ed84540bbb395b6f0bc21cb8ea169f1 inherit pub_types_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18640a7ac6891e626c78cbda4ab80abe inherit pub_types_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">typedef container_type::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a18640a7ac6891e626c78cbda4ab80abe">value_type</a></td></tr>
<tr class="memdesc:a18640a7ac6891e626c78cbda4ab80abe inherit pub_types_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym type defining the base class container std::set::value_type.  <a href="#a18640a7ac6891e626c78cbda4ab80abe">More...</a><br /></td></tr>
<tr class="separator:a18640a7ac6891e626c78cbda4ab80abe inherit pub_types_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188adab06dd0d3ed7813ff8d6ad1a121 inherit pub_types_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">typedef container_type::key_compare&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a188adab06dd0d3ed7813ff8d6ad1a121">key_compare</a></td></tr>
<tr class="memdesc:a188adab06dd0d3ed7813ff8d6ad1a121 inherit pub_types_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym type defining the key/value comparison std::set::key_compare.  <a href="#a188adab06dd0d3ed7813ff8d6ad1a121">More...</a><br /></td></tr>
<tr class="separator:a188adab06dd0d3ed7813ff8d6ad1a121 inherit pub_types_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f622467be2e7f9df83a2d0f791bfd90 inherit pub_types_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">typedef container_type::value_compare&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a8f622467be2e7f9df83a2d0f791bfd90">value_compare</a></td></tr>
<tr class="separator:a8f622467be2e7f9df83a2d0f791bfd90 inherit pub_types_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f32a9642333820fd0b9b66af654cb6 inherit pub_types_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">typedef container_type::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#ac6f32a9642333820fd0b9b66af654cb6">iterator</a></td></tr>
<tr class="memdesc:ac6f32a9642333820fd0b9b66af654cb6 inherit pub_types_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym type defining the base class container std::set::iterator.  <a href="#ac6f32a9642333820fd0b9b66af654cb6">More...</a><br /></td></tr>
<tr class="separator:ac6f32a9642333820fd0b9b66af654cb6 inherit pub_types_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551bdfa41f5ba3dd5b91ddcb86b1acd2 inherit pub_types_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">typedef container_type::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a551bdfa41f5ba3dd5b91ddcb86b1acd2">const_iterator</a></td></tr>
<tr class="memdesc:a551bdfa41f5ba3dd5b91ddcb86b1acd2 inherit pub_types_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym type defining the base class container std::set::iterator.  <a href="#a551bdfa41f5ba3dd5b91ddcb86b1acd2">More...</a><br /></td></tr>
<tr class="separator:a551bdfa41f5ba3dd5b91ddcb86b1acd2 inherit pub_types_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a184e3ec1103949b48211effcabf5480d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#a184e3ec1103949b48211effcabf5480d">ORanges</a> ()</td></tr>
<tr class="memdesc:a184e3ec1103949b48211effcabf5480d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty range.  <a href="#a184e3ec1103949b48211effcabf5480d">More...</a><br /></td></tr>
<tr class="separator:a184e3ec1103949b48211effcabf5480d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8469444d467ae43394579d59e2e5e892"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#a8469444d467ae43394579d59e2e5e892">ORanges</a> (const <a class="el" href="classreflex_1_1_ranges.html#a18640a7ac6891e626c78cbda4ab80abe">value_type</a> &amp;r)</td></tr>
<tr class="memdesc:a8469444d467ae43394579d59e2e5e892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a copy of a range [lo,hi].  <a href="#a8469444d467ae43394579d59e2e5e892">More...</a><br /></td></tr>
<tr class="separator:a8469444d467ae43394579d59e2e5e892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcdf67ed7348a0181a8c0fd3090c45c1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#afcdf67ed7348a0181a8c0fd3090c45c1">ORanges</a> (const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;<a class="el" href="classreflex_1_1_ranges.html#aeb29f8017cd8617ed78e8d185a9e2a74">lo</a>, const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;<a class="el" href="classreflex_1_1_o_ranges.html#aebbc4ec485e34807b3f04d8569477bb4">hi</a>)</td></tr>
<tr class="memdesc:afcdf67ed7348a0181a8c0fd3090c45c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a range [lo,hi].  <a href="#afcdf67ed7348a0181a8c0fd3090c45c1">More...</a><br /></td></tr>
<tr class="separator:afcdf67ed7348a0181a8c0fd3090c45c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f15ce9529f5819bd92c4b7eaee1ef8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#a88f15ce9529f5819bd92c4b7eaee1ef8">ORanges</a> (const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;val)</td></tr>
<tr class="memdesc:a88f15ce9529f5819bd92c4b7eaee1ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a singleton range [val,val].  <a href="#a88f15ce9529f5819bd92c4b7eaee1ef8">More...</a><br /></td></tr>
<tr class="separator:a88f15ce9529f5819bd92c4b7eaee1ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab8cad7c40e07960001634985f2d050"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classreflex_1_1_ranges.html#ac6f32a9642333820fd0b9b66af654cb6">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#acab8cad7c40e07960001634985f2d050">insert</a> (const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;<a class="el" href="classreflex_1_1_ranges.html#aeb29f8017cd8617ed78e8d185a9e2a74">lo</a>, const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;<a class="el" href="classreflex_1_1_o_ranges.html#aebbc4ec485e34807b3f04d8569477bb4">hi</a>)</td></tr>
<tr class="memdesc:acab8cad7c40e07960001634985f2d050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update ranges to include range [lo,hi] by merging overlapping and adjacent ranges into one range.  <a href="#acab8cad7c40e07960001634985f2d050">More...</a><br /></td></tr>
<tr class="separator:acab8cad7c40e07960001634985f2d050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaae9f574a9332bf843e263c0f016582"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classreflex_1_1_ranges.html#ac6f32a9642333820fd0b9b66af654cb6">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#adaae9f574a9332bf843e263c0f016582">insert</a> (const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;val)</td></tr>
<tr class="memdesc:adaae9f574a9332bf843e263c0f016582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update ranges to include range [val,val] by merging overlapping and adjacent ranges into one range.  <a href="#adaae9f574a9332bf843e263c0f016582">More...</a><br /></td></tr>
<tr class="separator:adaae9f574a9332bf843e263c0f016582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1bb50ea13bc00cecd426c3c5117249"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#a0e1bb50ea13bc00cecd426c3c5117249">erase</a> (const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;<a class="el" href="classreflex_1_1_ranges.html#aeb29f8017cd8617ed78e8d185a9e2a74">lo</a>, const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;<a class="el" href="classreflex_1_1_o_ranges.html#aebbc4ec485e34807b3f04d8569477bb4">hi</a>)</td></tr>
<tr class="memdesc:a0e1bb50ea13bc00cecd426c3c5117249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update ranges by deleting the given range [lo,hi].  <a href="#a0e1bb50ea13bc00cecd426c3c5117249">More...</a><br /></td></tr>
<tr class="separator:a0e1bb50ea13bc00cecd426c3c5117249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7211b683be1d46062e9d188b781a72e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#af7211b683be1d46062e9d188b781a72e">erase</a> (const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;val)</td></tr>
<tr class="memdesc:af7211b683be1d46062e9d188b781a72e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update ranges by deleting the given range [val,val].  <a href="#af7211b683be1d46062e9d188b781a72e">More...</a><br /></td></tr>
<tr class="separator:af7211b683be1d46062e9d188b781a72e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e66f53d0aed9f1a0aafa7b707205281"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_ranges.html#a551bdfa41f5ba3dd5b91ddcb86b1acd2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#a7e66f53d0aed9f1a0aafa7b707205281">find</a> (const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;<a class="el" href="classreflex_1_1_ranges.html#aeb29f8017cd8617ed78e8d185a9e2a74">lo</a>, const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;<a class="el" href="classreflex_1_1_o_ranges.html#aebbc4ec485e34807b3f04d8569477bb4">hi</a>) const </td></tr>
<tr class="memdesc:a7e66f53d0aed9f1a0aafa7b707205281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first range that overlaps the given range.  <a href="#a7e66f53d0aed9f1a0aafa7b707205281">More...</a><br /></td></tr>
<tr class="separator:a7e66f53d0aed9f1a0aafa7b707205281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d52c358414c1339a6e26d06235f5992"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_ranges.html#a551bdfa41f5ba3dd5b91ddcb86b1acd2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#a8d52c358414c1339a6e26d06235f5992">find</a> (const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;val) const </td></tr>
<tr class="memdesc:a8d52c358414c1339a6e26d06235f5992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the range that includes the given value.  <a href="#a8d52c358414c1339a6e26d06235f5992">More...</a><br /></td></tr>
<tr class="separator:a8d52c358414c1339a6e26d06235f5992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e399bf2042c81e928e283566097f8b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#a6e399bf2042c81e928e283566097f8b9">operator-=</a> (const <a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a> &amp;rs)</td></tr>
<tr class="memdesc:a6e399bf2042c81e928e283566097f8b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update ranges to remove ranges rs, has lower complexity than repeating <a class="el" href="classreflex_1_1_o_ranges.html#a0e1bb50ea13bc00cecd426c3c5117249" title="Update ranges by deleting the given range [lo,hi]. ">erase()</a>.  <a href="#a6e399bf2042c81e928e283566097f8b9">More...</a><br /></td></tr>
<tr class="separator:a6e399bf2042c81e928e283566097f8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59deda9697985a3c07af43a6204e4fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#ad59deda9697985a3c07af43a6204e4fd">operator&amp;=</a> (const <a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a> &amp;rs)</td></tr>
<tr class="memdesc:ad59deda9697985a3c07af43a6204e4fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update ranges to intersect the ranges of the given range set.  <a href="#ad59deda9697985a3c07af43a6204e4fd">More...</a><br /></td></tr>
<tr class="separator:ad59deda9697985a3c07af43a6204e4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2dc1305d1dc89e8043b1867d00e89c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#a4f2dc1305d1dc89e8043b1867d00e89c">operator|</a> (const <a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a> &amp;rs) const </td></tr>
<tr class="memdesc:a4f2dc1305d1dc89e8043b1867d00e89c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the union of two range sets.  <a href="#a4f2dc1305d1dc89e8043b1867d00e89c">More...</a><br /></td></tr>
<tr class="separator:a4f2dc1305d1dc89e8043b1867d00e89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e2177782a200135ec63a4bc12df2c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#a36e2177782a200135ec63a4bc12df2c6">operator+</a> (const <a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a> &amp;rs) const </td></tr>
<tr class="memdesc:a36e2177782a200135ec63a4bc12df2c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the union of two range sets.  <a href="#a36e2177782a200135ec63a4bc12df2c6">More...</a><br /></td></tr>
<tr class="separator:a36e2177782a200135ec63a4bc12df2c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11bc3908554b1604f953d3001820a46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#aa11bc3908554b1604f953d3001820a46">operator-</a> (const <a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a> &amp;rs) const </td></tr>
<tr class="memdesc:aa11bc3908554b1604f953d3001820a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the difference of two open-ended range sets.  <a href="#aa11bc3908554b1604f953d3001820a46">More...</a><br /></td></tr>
<tr class="separator:aa11bc3908554b1604f953d3001820a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289c62f602d438c6ef63a3c32dbd5292"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#a289c62f602d438c6ef63a3c32dbd5292">operator&amp;</a> (const <a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a> &amp;rs) const </td></tr>
<tr class="memdesc:a289c62f602d438c6ef63a3c32dbd5292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the intersection of two open-ended range sets.  <a href="#a289c62f602d438c6ef63a3c32dbd5292">More...</a><br /></td></tr>
<tr class="separator:a289c62f602d438c6ef63a3c32dbd5292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafab298888e6e86590afb7b6e00ea56c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#aafab298888e6e86590afb7b6e00ea56c">intersects</a> (const <a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a> &amp;rs) const </td></tr>
<tr class="memdesc:aafab298888e6e86590afb7b6e00ea56c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this set of ranges intersects with ranges rs, i.e. this set has at least one range [lo',hi'] that overlaps with a range [lo,hi] in rs such that lo &lt;= hi' and lo' &lt;= hi.  <a href="#aafab298888e6e86590afb7b6e00ea56c">More...</a><br /></td></tr>
<tr class="separator:aafab298888e6e86590afb7b6e00ea56c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebbc4ec485e34807b3f04d8569477bb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#aebbc4ec485e34807b3f04d8569477bb4">hi</a> () const </td></tr>
<tr class="memdesc:aebbc4ec485e34807b3f04d8569477bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the highest value in the set of ranges (the set cannot be empty)  <a href="#aebbc4ec485e34807b3f04d8569477bb4">More...</a><br /></td></tr>
<tr class="separator:aebbc4ec485e34807b3f04d8569477bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111ba731966af84356477ef5d2b062dd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#a111ba731966af84356477ef5d2b062dd">count</a> () const </td></tr>
<tr class="memdesc:a111ba731966af84356477ef5d2b062dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of items stored in ranges.  <a href="#a111ba731966af84356477ef5d2b062dd">More...</a><br /></td></tr>
<tr class="separator:a111ba731966af84356477ef5d2b062dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classreflex_1_1_ranges"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classreflex_1_1_ranges')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classreflex_1_1_ranges.html">reflex::Ranges&lt; T &gt;</a></td></tr>
<tr class="memitem:a113a3eed86ce245a93626b1f5b84c5ad inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a113a3eed86ce245a93626b1f5b84c5ad">Ranges</a> ()</td></tr>
<tr class="memdesc:a113a3eed86ce245a93626b1f5b84c5ad inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty range.  <a href="#a113a3eed86ce245a93626b1f5b84c5ad">More...</a><br /></td></tr>
<tr class="separator:a113a3eed86ce245a93626b1f5b84c5ad inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36353497e22513c992cc68d7057ed209 inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a36353497e22513c992cc68d7057ed209">Ranges</a> (const <a class="el" href="classreflex_1_1_ranges.html#a18640a7ac6891e626c78cbda4ab80abe">value_type</a> &amp;r)</td></tr>
<tr class="memdesc:a36353497e22513c992cc68d7057ed209 inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a copy of a range [lo,hi].  <a href="#a36353497e22513c992cc68d7057ed209">More...</a><br /></td></tr>
<tr class="separator:a36353497e22513c992cc68d7057ed209 inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c27d82deac4a616b3c7f50dc11a66b4 inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a7c27d82deac4a616b3c7f50dc11a66b4">Ranges</a> (const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;<a class="el" href="classreflex_1_1_ranges.html#aeb29f8017cd8617ed78e8d185a9e2a74">lo</a>, const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;<a class="el" href="classreflex_1_1_ranges.html#a467a43c765cf87ed17c0b888f445c9fc">hi</a>)</td></tr>
<tr class="memdesc:a7c27d82deac4a616b3c7f50dc11a66b4 inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a range [lo,hi].  <a href="#a7c27d82deac4a616b3c7f50dc11a66b4">More...</a><br /></td></tr>
<tr class="separator:a7c27d82deac4a616b3c7f50dc11a66b4 inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab375bf376f87fb4f75d20e5af68166f1 inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#ab375bf376f87fb4f75d20e5af68166f1">Ranges</a> (const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;val)</td></tr>
<tr class="memdesc:ab375bf376f87fb4f75d20e5af68166f1 inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a singleton range [val,val].  <a href="#ab375bf376f87fb4f75d20e5af68166f1">More...</a><br /></td></tr>
<tr class="separator:ab375bf376f87fb4f75d20e5af68166f1 inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b80affbf56f12faafae17b0c64dc00 inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classreflex_1_1_ranges.html#ac6f32a9642333820fd0b9b66af654cb6">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a45b80affbf56f12faafae17b0c64dc00">insert</a> (const <a class="el" href="classreflex_1_1_ranges.html#a18640a7ac6891e626c78cbda4ab80abe">value_type</a> &amp;r)</td></tr>
<tr class="memdesc:a45b80affbf56f12faafae17b0c64dc00 inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update ranges to include range [lo,hi] by merging overlapping ranges into one range.  <a href="#a45b80affbf56f12faafae17b0c64dc00">More...</a><br /></td></tr>
<tr class="separator:a45b80affbf56f12faafae17b0c64dc00 inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf55cde7658ed085e54f1c695cb9910 inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classreflex_1_1_ranges.html#ac6f32a9642333820fd0b9b66af654cb6">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#acbf55cde7658ed085e54f1c695cb9910">insert</a> (const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;<a class="el" href="classreflex_1_1_ranges.html#aeb29f8017cd8617ed78e8d185a9e2a74">lo</a>, const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;<a class="el" href="classreflex_1_1_ranges.html#a467a43c765cf87ed17c0b888f445c9fc">hi</a>)</td></tr>
<tr class="memdesc:acbf55cde7658ed085e54f1c695cb9910 inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update ranges to include range [lo,hi] by merging overlapping ranges into one range.  <a href="#acbf55cde7658ed085e54f1c695cb9910">More...</a><br /></td></tr>
<tr class="separator:acbf55cde7658ed085e54f1c695cb9910 inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e9676740f9dee983de782774f077f0 inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classreflex_1_1_ranges.html#ac6f32a9642333820fd0b9b66af654cb6">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#af0e9676740f9dee983de782774f077f0">insert</a> (const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;val)</td></tr>
<tr class="memdesc:af0e9676740f9dee983de782774f077f0 inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update ranges to include the range [val,val].  <a href="#af0e9676740f9dee983de782774f077f0">More...</a><br /></td></tr>
<tr class="separator:af0e9676740f9dee983de782774f077f0 inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7148421186fc5d33f4eb109609e1c4 inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_ranges.html#a551bdfa41f5ba3dd5b91ddcb86b1acd2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a2a7148421186fc5d33f4eb109609e1c4">find</a> (const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;<a class="el" href="classreflex_1_1_ranges.html#aeb29f8017cd8617ed78e8d185a9e2a74">lo</a>, const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;<a class="el" href="classreflex_1_1_ranges.html#a467a43c765cf87ed17c0b888f445c9fc">hi</a>) const </td></tr>
<tr class="memdesc:a2a7148421186fc5d33f4eb109609e1c4 inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first range [lo',hi'] that overlaps the given range [lo,hi], i.e. lo &lt;= hi' and lo' &lt;= hi.  <a href="#a2a7148421186fc5d33f4eb109609e1c4">More...</a><br /></td></tr>
<tr class="separator:a2a7148421186fc5d33f4eb109609e1c4 inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e426ff9650fddac27e0433db0811bc9 inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_ranges.html#a551bdfa41f5ba3dd5b91ddcb86b1acd2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a0e426ff9650fddac27e0433db0811bc9">find</a> (const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;val) const </td></tr>
<tr class="memdesc:a0e426ff9650fddac27e0433db0811bc9 inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the range [lo',hi'] that includes the given value val, i.e. lo' &lt;= val &lt;= hi'.  <a href="#a0e426ff9650fddac27e0433db0811bc9">More...</a><br /></td></tr>
<tr class="separator:a0e426ff9650fddac27e0433db0811bc9 inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86ade66b0f5c3003dbc11e1d4e2d738 inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#ad86ade66b0f5c3003dbc11e1d4e2d738">operator|=</a> (const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;rs)</td></tr>
<tr class="memdesc:ad86ade66b0f5c3003dbc11e1d4e2d738 inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update ranges to insert the given range set, where this method has lower complexity than iterating <a class="el" href="classreflex_1_1_ranges.html#a45b80affbf56f12faafae17b0c64dc00" title="Update ranges to include range [lo,hi] by merging overlapping ranges into one range. ">insert()</a> for each range in rs.  <a href="#ad86ade66b0f5c3003dbc11e1d4e2d738">More...</a><br /></td></tr>
<tr class="separator:ad86ade66b0f5c3003dbc11e1d4e2d738 inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0aa356a5eec364aad70a795aeab68f5 inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#ab0aa356a5eec364aad70a795aeab68f5">operator+=</a> (const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;rs)</td></tr>
<tr class="memdesc:ab0aa356a5eec364aad70a795aeab68f5 inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update ranges to insert the ranges of the given range set, same as Ranges::operator|=(rs).  <a href="#ab0aa356a5eec364aad70a795aeab68f5">More...</a><br /></td></tr>
<tr class="separator:ab0aa356a5eec364aad70a795aeab68f5 inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2feb520bce89afdf80f7d06d8c3bcd inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a3d2feb520bce89afdf80f7d06d8c3bcd">operator&amp;=</a> (const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;rs)</td></tr>
<tr class="memdesc:a3d2feb520bce89afdf80f7d06d8c3bcd inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update ranges to intersect the ranges with the given range set.  <a href="#a3d2feb520bce89afdf80f7d06d8c3bcd">More...</a><br /></td></tr>
<tr class="separator:a3d2feb520bce89afdf80f7d06d8c3bcd inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658a2b69b4e435ecf079e0e5cc98c880 inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_ranges.html">Ranges</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a658a2b69b4e435ecf079e0e5cc98c880">operator|</a> (const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;rs) const </td></tr>
<tr class="memdesc:a658a2b69b4e435ecf079e0e5cc98c880 inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the union of two range sets.  <a href="#a658a2b69b4e435ecf079e0e5cc98c880">More...</a><br /></td></tr>
<tr class="separator:a658a2b69b4e435ecf079e0e5cc98c880 inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14efc99f9c25db9e9b4ef0dbb72e3801 inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_ranges.html">Ranges</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a14efc99f9c25db9e9b4ef0dbb72e3801">operator+</a> (const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;rs) const </td></tr>
<tr class="memdesc:a14efc99f9c25db9e9b4ef0dbb72e3801 inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the union of two range sets, same as Ranges::operator|(rs).  <a href="#a14efc99f9c25db9e9b4ef0dbb72e3801">More...</a><br /></td></tr>
<tr class="separator:a14efc99f9c25db9e9b4ef0dbb72e3801 inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc03786da54f6077febdea2f83110e2 inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_ranges.html">Ranges</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a2bc03786da54f6077febdea2f83110e2">operator&amp;</a> (const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;rs) const </td></tr>
<tr class="memdesc:a2bc03786da54f6077febdea2f83110e2 inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the intersection of two range sets.  <a href="#a2bc03786da54f6077febdea2f83110e2">More...</a><br /></td></tr>
<tr class="separator:a2bc03786da54f6077febdea2f83110e2 inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412f3f7392b76411ed5f1e02ecdebd0c inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a412f3f7392b76411ed5f1e02ecdebd0c">operator&lt;</a> (const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;rs) const </td></tr>
<tr class="memdesc:a412f3f7392b76411ed5f1e02ecdebd0c inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this range set is lexicographically less than range set rs.  <a href="#a412f3f7392b76411ed5f1e02ecdebd0c">More...</a><br /></td></tr>
<tr class="separator:a412f3f7392b76411ed5f1e02ecdebd0c inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be1924a5c28eff510256c8345f65241 inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a2be1924a5c28eff510256c8345f65241">operator&gt;</a> (const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;rs) const </td></tr>
<tr class="memdesc:a2be1924a5c28eff510256c8345f65241 inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this range set is lexicographically greater than range set rs.  <a href="#a2be1924a5c28eff510256c8345f65241">More...</a><br /></td></tr>
<tr class="separator:a2be1924a5c28eff510256c8345f65241 inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21dec3fa4c006ba98e5888b724e7178e inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a21dec3fa4c006ba98e5888b724e7178e">operator&lt;=</a> (const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;rs) const </td></tr>
<tr class="memdesc:a21dec3fa4c006ba98e5888b724e7178e inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this range set is lexicographically less or equal to range set rs.  <a href="#a21dec3fa4c006ba98e5888b724e7178e">More...</a><br /></td></tr>
<tr class="separator:a21dec3fa4c006ba98e5888b724e7178e inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef3e519c643b66d0ab50f77f1780236 inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a3ef3e519c643b66d0ab50f77f1780236">operator&gt;=</a> (const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;rs) const </td></tr>
<tr class="memdesc:a3ef3e519c643b66d0ab50f77f1780236 inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this range set is lexicographically greater or equal to range set rs.  <a href="#a3ef3e519c643b66d0ab50f77f1780236">More...</a><br /></td></tr>
<tr class="separator:a3ef3e519c643b66d0ab50f77f1780236 inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef3e69adbf8dab9c4123a77c873eca1 inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a6ef3e69adbf8dab9c4123a77c873eca1">any</a> () const </td></tr>
<tr class="memdesc:a6ef3e69adbf8dab9c4123a77c873eca1 inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this set of ranges contains at least one range, i.e. is not empty.  <a href="#a6ef3e69adbf8dab9c4123a77c873eca1">More...</a><br /></td></tr>
<tr class="separator:a6ef3e69adbf8dab9c4123a77c873eca1 inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff9a255f63c79bc945cbcde112bd79a inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a8ff9a255f63c79bc945cbcde112bd79a">intersects</a> (const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;rs) const </td></tr>
<tr class="memdesc:a8ff9a255f63c79bc945cbcde112bd79a inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this set of ranges intersects with ranges rs, i.e. this set has at least one range [lo',hi'] that overlaps with a range [lo,hi] in rs such that lo &lt;= hi' and lo' &lt;= hi.  <a href="#a8ff9a255f63c79bc945cbcde112bd79a">More...</a><br /></td></tr>
<tr class="separator:a8ff9a255f63c79bc945cbcde112bd79a inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e84aa26790720fa68ac1882839db0c inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#af1e84aa26790720fa68ac1882839db0c">contains</a> (const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;rs) const </td></tr>
<tr class="memdesc:af1e84aa26790720fa68ac1882839db0c inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this set of ranges contains all ranges in rs, i.e. rs is a subset of this set which means that for each range [lo,hi] in rs, there is a range [lo',hi'] such that lo' &lt;= lo and hi &lt;= hi'.  <a href="#af1e84aa26790720fa68ac1882839db0c">More...</a><br /></td></tr>
<tr class="separator:af1e84aa26790720fa68ac1882839db0c inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb29f8017cd8617ed78e8d185a9e2a74 inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#aeb29f8017cd8617ed78e8d185a9e2a74">lo</a> () const </td></tr>
<tr class="memdesc:aeb29f8017cd8617ed78e8d185a9e2a74 inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lowest value in the set of ranges (the set cannot be empty)  <a href="#aeb29f8017cd8617ed78e8d185a9e2a74">More...</a><br /></td></tr>
<tr class="separator:aeb29f8017cd8617ed78e8d185a9e2a74 inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467a43c765cf87ed17c0b888f445c9fc inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a467a43c765cf87ed17c0b888f445c9fc">hi</a> () const </td></tr>
<tr class="memdesc:a467a43c765cf87ed17c0b888f445c9fc inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the highest value in the set of ranges (the set cannot be empty)  <a href="#a467a43c765cf87ed17c0b888f445c9fc">More...</a><br /></td></tr>
<tr class="separator:a467a43c765cf87ed17c0b888f445c9fc inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a214b9c65df80346fe6e0cb801fee8a40"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#a214b9c65df80346fe6e0cb801fee8a40">bump</a> (<a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> val)</td></tr>
<tr class="memdesc:a214b9c65df80346fe6e0cb801fee8a40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bump value.  <a href="#a214b9c65df80346fe6e0cb801fee8a40">More...</a><br /></td></tr>
<tr class="separator:a214b9c65df80346fe6e0cb801fee8a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class reflex::ORanges&lt; T &gt;</h3>

<p>RE/flex <a class="el" href="classreflex_1_1_o_ranges.html" title="RE/flex ORanges (open-ended, ordinal value range) template class. ">ORanges</a> (open-ended, ordinal value range) template class. </p>
<p>The <a class="el" href="classreflex_1_1_o_ranges.html" title="RE/flex ORanges (open-ended, ordinal value range) template class. ">ORanges</a> class is an optimization of the ranges class for ordinal types, i.e. types with the property that values can be counted (enumerable, e.g. integers and enumerations).</p>
<p>The optimization merges adjacent ranges. Two ranges <code>[a,b]</code> and <code>[c,d]</code> are adjacent when <code>b+1=c</code>. It is safe to merge adjacent ranges over values of an ordinal type, because <code>[a,b](+)[b+1,c]=[a,c]</code> with <code>(+)</code> representing range merging (set union).</p>
<p>By storing open-ended ranges <code>[lo,hi+1)</code> in the ranges class container, adjacent ranges are merged automatically by the fact that the bounds of open-ended adjacent ranges overlap.</p>
<p>In addition to the methods inherited from the Range base class, open-ended ranges can be updated by deleting ranges from the set with:</p>
<ul>
<li><code>bool <a class="el" href="classreflex_1_1_o_ranges.html#a0e1bb50ea13bc00cecd426c3c5117249" title="Update ranges by deleting the given range [lo,hi]. ">erase(const bound_type&amp; lo, const bound_type&amp; hi)</a></code> erases a range from this set of open-ended ranges. Returns true if the set was updated.</li>
<li><code>bool <a class="el" href="classreflex_1_1_o_ranges.html#af7211b683be1d46062e9d188b781a72e" title="Update ranges by deleting the given range [val,val]. ">erase(const bound_type&amp; val)</a></code> erases a value from this set of open-ended ranges. Returns true if the set was updated.</li>
<li><code><a class="el" href="classreflex_1_1_o_ranges.html" title="RE/flex ORanges (open-ended, ordinal value range) template class. ">ORanges</a>&amp; <a class="el" href="classreflex_1_1_o_ranges.html#a6e399bf2042c81e928e283566097f8b9" title="Update ranges to remove ranges rs, has lower complexity than repeating erase(). ">operator-=(const ORanges&amp; rs)</a></code> erases ranges rs from this set of open-ended ranges. Returns reference to this object.</li>
<li><code><a class="el" href="classreflex_1_1_o_ranges.html" title="RE/flex ORanges (open-ended, ordinal value range) template class. ">ORanges</a> <a class="el" href="classreflex_1_1_o_ranges.html#aa11bc3908554b1604f953d3001820a46" title="Returns the difference of two open-ended range sets. ">operator-(const ORanges&amp; rs) const</a></code> returns difference, i.e. ranges rs erased from this set of open-ended ranges.</li>
</ul>
<p>Open-ended ranges are more efficient than <code>std::set</code> when the values stored are adjacent (e.g. integers 2 and 3 are adjacent), since <code>std::set</code> stores values individually whereas open-ended ranges merges adjacent values into ranges. This lowers storage overhead and reduces insertion, deletion, and search time.</p>
<p>We can iterate over open-ended ranges. The iterator dereferences values are <code>[lo,hi+1)</code> pairs, i.e. <code>lo = i-&gt;first</code> and <code>hi = i-&gt;second - 1</code>.</p>
<p>Additional <a class="el" href="classreflex_1_1_o_ranges.html" title="RE/flex ORanges (open-ended, ordinal value range) template class. ">ORanges</a> methods not defined by <a class="el" href="classreflex_1_1_ranges.html" title="RE/flex Ranges template class. ">Ranges</a>:</p>
<ul>
<li><code>size_t <a class="el" href="classreflex_1_1_o_ranges.html#a111ba731966af84356477ef5d2b062dd" title="Return the number of items stored in ranges. ">count()</a></code> returns the number of items stored in ranges, note that <code>size()</code> returns the number of ranges.</li>
</ul>
<p>IMPORTANT:</p>
<p>The largest value that can be stored in an open-ended range of value type T is the maximum T-representable value minus 1. For example, the character range <code><a class="el" href="classreflex_1_1_o_ranges.html" title="RE/flex ORanges (open-ended, ordinal value range) template class. ">reflex::ORanges</a>&lt;char&gt;</code> holds values -128 to 126 and excludes 127.</p><ul>
<li>Pick sufficiently wide container value types T, e.g. int instead of char.</li>
<li>Or the macro WITH_ORANGES_CLAMPED can be defined to use this library such that the maximum value is clamped to prevent overflow, e.g. <code><a class="el" href="classreflex_1_1_o_ranges.html" title="RE/flex ORanges (open-ended, ordinal value range) template class. ">reflex::ORanges</a>&lt;char&gt; ch = 127</code> is clamped to 126. However, this still excludes 127 from the range set.</li>
<li>It is in principle possible to store and search for character 127 separately with insert(127) and find(127), respectively. Repeated insert(127) will add more 127 values, which is not desirable, since the unique set property no longer holds. Beware that insert(ch, 127) will not work. Also, value 127 cannot be deleted.</li>
</ul>
<p>Example:</p>
<div class="fragment"><div class="line"><a class="code" href="classreflex_1_1_o_ranges.html">reflex::ORanges&lt;int&gt;</a> ints;</div><div class="line">ints = 0;              <span class="comment">// insert 0</span></div><div class="line">ints.<a class="code" href="classreflex_1_1_o_ranges.html#acab8cad7c40e07960001634985f2d050">insert</a>(100, 200); <span class="comment">// insert 100..200</span></div><div class="line">ints.<a class="code" href="classreflex_1_1_o_ranges.html#acab8cad7c40e07960001634985f2d050">insert</a>(300, 400); <span class="comment">// insert 300..400</span></div><div class="line">ints.<a class="code" href="classreflex_1_1_o_ranges.html#acab8cad7c40e07960001634985f2d050">insert</a>(200, 300); <span class="comment">// insert 200..300</span></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Set of &quot;</span> &lt;&lt; ints.size() &lt;&lt; <span class="stringliteral">&quot; open-ended ranges:&quot;</span> &lt;&lt; std::endl;</div><div class="line"><span class="keywordflow">for</span> (<a class="code" href="classreflex_1_1_o_ranges.html#add7ea78d89f343eaeb7329d9f73e7f47">reflex::ORanges&lt;int&gt;::const_iterator</a> i = ints.begin(); i != ints.end(); ++i)</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; i-&gt;first &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; i-&gt;second &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div><div class="line">if (ints.<a class="code" href="classreflex_1_1_o_ranges.html#a7e66f53d0aed9f1a0aafa7b707205281">find</a>(200) != ints.end())</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;200 is in the set&quot;</span> &lt;&lt; std::endl;</div><div class="line"><span class="keywordflow">if</span> (ints.<a class="code" href="classreflex_1_1_o_ranges.html#a7e66f53d0aed9f1a0aafa7b707205281">find</a>(99) == ints.end())</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;99 is not in the set&quot;</span> &lt;&lt; std::endl;</div><div class="line"><span class="keywordflow">if</span> (ints.<a class="code" href="classreflex_1_1_o_ranges.html#a7e66f53d0aed9f1a0aafa7b707205281">find</a>(401) == ints.end())</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;401 is not in the set&quot;</span> &lt;&lt; std::endl;</div><div class="line">ints.<a class="code" href="classreflex_1_1_o_ranges.html#a0e1bb50ea13bc00cecd426c3c5117249">erase</a>(250, 350);</div><div class="line"><span class="keywordflow">for</span> (<a class="code" href="classreflex_1_1_o_ranges.html#add7ea78d89f343eaeb7329d9f73e7f47">reflex::ORanges&lt;int&gt;::const_iterator</a> i = ints.begin(); i != ints.end(); ++i)</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; i-&gt;first &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; i-&gt;second &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div></div><!-- fragment --><p>Output:</p>
<p>Set of 2 open-ended ranges: [0,1) [100,401) 200 is in the set 99 is not in the set 401 is not in the set [0,1) [100,250) [351,401) </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a9306ca6343c93417ee45602d1e854a0f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::<a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the bounds. </p>

</div>
</div>
<a class="anchor" id="add7ea78d89f343eaeb7329d9f73e7f47"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef container_type::const_iterator <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::<a class="el" href="classreflex_1_1_ranges.html#a551bdfa41f5ba3dd5b91ddcb86b1acd2">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym type defining the base class container std::set::const_iterator. </p>

</div>
</div>
<a class="anchor" id="a2279c7fc683a9719345e6150c9720e2a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::set&lt; std::pair&lt;T,T&gt;,<a class="el" href="structreflex_1_1range__compare.html">range_compare</a>&lt;T&gt; &gt; <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::<a class="el" href="classreflex_1_1_ranges.html#a7ed84540bbb395b6f0bc21cb8ea169f1">container_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym type defining the base class container std::set. </p>

</div>
</div>
<a class="anchor" id="a2a822980610d3f4deb3cb0e42ad49a85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef container_type::iterator <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::<a class="el" href="classreflex_1_1_ranges.html#ac6f32a9642333820fd0b9b66af654cb6">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym type defining the base class container std::set::iterator. </p>

</div>
</div>
<a class="anchor" id="a4a0f99be50ac378e9a9c8fb0257b833c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef container_type::key_compare <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::<a class="el" href="classreflex_1_1_ranges.html#a188adab06dd0d3ed7813ff8d6ad1a121">key_compare</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym type defining the key/value comparison std::set::key_compare. </p>

</div>
</div>
<a class="anchor" id="af53348dfe78ee8b514273aaea6f6e6fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef container_type::value_compare <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::<a class="el" href="classreflex_1_1_ranges.html#a8f622467be2e7f9df83a2d0f791bfd90">value_compare</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a34350a20bbd8f9f719e2f3144df55942"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef container_type::value_type <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::<a class="el" href="classreflex_1_1_ranges.html#a18640a7ac6891e626c78cbda4ab80abe">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym type defining the base class container std::set::value_type. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a184e3ec1103949b48211effcabf5480d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::<a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an empty range. </p>

</div>
</div>
<a class="anchor" id="a8469444d467ae43394579d59e2e5e892"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::<a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html#a18640a7ac6891e626c78cbda4ab80abe">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a copy of a range [lo,hi]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afcdf67ed7348a0181a8c0fd3090c45c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::<a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;&#160;</td>
          <td class="paramname"><em>hi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a range [lo,hi]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>lower bound </td></tr>
    <tr><td class="paramname">hi</td><td>upper bound </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a88f15ce9529f5819bd92c4b7eaee1ef8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::<a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a singleton range [val,val]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a214b9c65df80346fe6e0cb801fee8a40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::bump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bump value. </p>
<dl class="section return"><dt>Returns</dt><dd>val + 1. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to bump </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a111ba731966af84356477ef5d2b062dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of items stored in ranges. </p>

</div>
</div>
<a class="anchor" id="a0e1bb50ea13bc00cecd426c3c5117249"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;&#160;</td>
          <td class="paramname"><em>hi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update ranges by deleting the given range [lo,hi]. </p>
<dl class="section return"><dt>Returns</dt><dd>true if ranges was updated. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>lower bound </td></tr>
    <tr><td class="paramname">hi</td><td>upper bound </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af7211b683be1d46062e9d188b781a72e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update ranges by deleting the given range [val,val]. </p>
<dl class="section return"><dt>Returns</dt><dd>true if ranges was updated. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>value to delete </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7e66f53d0aed9f1a0aafa7b707205281"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_ranges.html#a551bdfa41f5ba3dd5b91ddcb86b1acd2">const_iterator</a> <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;&#160;</td>
          <td class="paramname"><em>hi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first range that overlaps the given range. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the first range that overlaps the given range, or the end iterator. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>lower bound </td></tr>
    <tr><td class="paramname">hi</td><td>upper bound </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8d52c358414c1339a6e26d06235f5992"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_ranges.html#a551bdfa41f5ba3dd5b91ddcb86b1acd2">const_iterator</a> <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the range that includes the given value. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the range that includes the value, or the end iterator. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>value to search for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aebbc4ec485e34807b3f04d8569477bb4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::hi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the highest value in the set of ranges (the set cannot be empty) </p>
<dl class="section return"><dt>Returns</dt><dd>highest value </dd></dl>

</div>
</div>
<a class="anchor" id="acab8cad7c40e07960001634985f2d050"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classreflex_1_1_ranges.html#ac6f32a9642333820fd0b9b66af654cb6">iterator</a>,bool&gt; <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;&#160;</td>
          <td class="paramname"><em>hi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update ranges to include range [lo,hi] by merging overlapping and adjacent ranges into one range. </p>
<dl class="section return"><dt>Returns</dt><dd>a pair of an iterator to the range and a flag indicating whether the range was inserted as new. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>lower bound </td></tr>
    <tr><td class="paramname">hi</td><td>upper bound </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adaae9f574a9332bf843e263c0f016582"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classreflex_1_1_ranges.html#ac6f32a9642333820fd0b9b66af654cb6">iterator</a>,bool&gt; <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update ranges to include range [val,val] by merging overlapping and adjacent ranges into one range. </p>
<dl class="section return"><dt>Returns</dt><dd>a pair of an iterator to the range and a flag indicating whether the range was inserted as new. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>value to insert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aafab298888e6e86590afb7b6e00ea56c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::intersects </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this set of ranges intersects with ranges rs, i.e. this set has at least one range [lo',hi'] that overlaps with a range [lo,hi] in rs such that lo &lt;= hi' and lo' &lt;= hi. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this set intersects rs. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rs</td><td>ranges </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a289c62f602d438c6ef63a3c32dbd5292"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a> <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the intersection of two open-ended range sets. </p>
<dl class="section return"><dt>Returns</dt><dd>the intersection of this set and rs. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rs</td><td>ranges to intersect </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad59deda9697985a3c07af43a6204e4fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a>&amp; <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update ranges to intersect the ranges of the given range set. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to this object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rs</td><td>ranges to intersect </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a36e2177782a200135ec63a4bc12df2c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a> <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the union of two range sets. </p>
<dl class="section return"><dt>Returns</dt><dd>the union of this set and rs. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rs</td><td>ranges to merge </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa11bc3908554b1604f953d3001820a46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a> <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the difference of two open-ended range sets. </p>
<dl class="section return"><dt>Returns</dt><dd>the difference of this set and rs. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rs</td><td>ranges </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6e399bf2042c81e928e283566097f8b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a>&amp; <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update ranges to remove ranges rs, has lower complexity than repeating <a class="el" href="classreflex_1_1_o_ranges.html#a0e1bb50ea13bc00cecd426c3c5117249" title="Update ranges by deleting the given range [lo,hi]. ">erase()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a4f2dc1305d1dc89e8043b1867d00e89c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a> <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the union of two range sets. </p>
<dl class="section return"><dt>Returns</dt><dd>the union of this set and rs. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rs</td><td>ranges to merge </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="ranges_8h.html">ranges.h</a></li>
</ul>
</div><!-- contents -->
<hr class="footer">
<address class="footer"><small>
Converted on Tue Oct 29 2024 12:14:59 by <a target="_blank" href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.11</small></address>
<br>
<div style="height: 246px; background: #DBDBDB;">
</body>
</html>
