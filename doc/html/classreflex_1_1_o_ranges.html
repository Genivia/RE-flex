<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta http-equiv="cache-control" content="no-cache">
<title>reflex::ORanges&lt; T &gt; Class Template Reference</title>
<link href="doxygen_tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="doxygen_content.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top">
 <div id="titlearea">
  <table height="72px" width="100%" cellspacing="0" cellpadding="0">
   <tbody>
    <tr>
     <td width="10%">&nbsp;</td>
     <td><a href="https://github.com/Genivia/RE-flex"><img src="reflex-logo.png"/></a></td>
     <td>
      <div style="float: right; font-size: 18px; font-weight: bold;">reflex::ORanges&lt; T &gt; Class Template Reference</div>
      <br>
      <div style="float: right; font-size: 10px;">updated Wed Jul 6 2022 by Robert van Engelen</div>
     </td>
     <td width="10%">&nbsp;</td>
    </tr>
   </tbody>
  </table>
 </div>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacereflex.html">reflex</a></li><li class="navelem"><a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="classreflex_1_1_o_ranges-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">reflex::ORanges&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>RE/flex <a class="el" href="classreflex_1_1_o_ranges.html" title="RE/flex ORanges (open-ended, ordinal value range) template class. ">ORanges</a> (open-ended, ordinal value range) template class.  
 <a href="classreflex_1_1_o_ranges.html#details">More...</a></p>

<p><code>#include &lt;ranges.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for reflex::ORanges&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classreflex_1_1_o_ranges__inherit__graph.png" border="0" usemap="#reflex_1_1_o_ranges_3_01_t_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="reflex_1_1_o_ranges_3_01_t_01_4_inherit__map" id="reflex_1_1_o_ranges_3_01_t_01_4_inherit__map">
<area shape="rect" id="node2" href="classreflex_1_1_ranges.html" title="RE/flex Ranges template class. " alt="" coords="21,109,159,136"/>
<area shape="rect" id="node3" title="STL class. " alt="" coords="5,5,175,61"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for reflex::ORanges&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classreflex_1_1_o_ranges__coll__graph.png" border="0" usemap="#reflex_1_1_o_ranges_3_01_t_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="reflex_1_1_o_ranges_3_01_t_01_4_coll__map" id="reflex_1_1_o_ranges_3_01_t_01_4_coll__map">
<area shape="rect" id="node2" href="classreflex_1_1_ranges.html" title="RE/flex Ranges template class. " alt="" coords="21,200,159,227"/>
<area shape="rect" id="node3" title="STL class. " alt="" coords="5,95,175,151"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9306ca6343c93417ee45602d1e854a0f"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#a9306ca6343c93417ee45602d1e854a0f">bound_type</a></td></tr>
<tr class="memdesc:a9306ca6343c93417ee45602d1e854a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the bounds.  <a href="#a9306ca6343c93417ee45602d1e854a0f">More...</a><br /></td></tr>
<tr class="separator:a9306ca6343c93417ee45602d1e854a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2279c7fc683a9719345e6150c9720e2a"><td class="memItemLeft" align="right" valign="top">typedef std::set&lt; std::pair&lt; T, T &gt;, <a class="el" href="structreflex_1_1range__compare.html">range_compare</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#a2279c7fc683a9719345e6150c9720e2a">container_type</a></td></tr>
<tr class="memdesc:a2279c7fc683a9719345e6150c9720e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym type defining the base class container std::set.  <a href="#a2279c7fc683a9719345e6150c9720e2a">More...</a><br /></td></tr>
<tr class="separator:a2279c7fc683a9719345e6150c9720e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34350a20bbd8f9f719e2f3144df55942"><td class="memItemLeft" align="right" valign="top">typedef container_type::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#a34350a20bbd8f9f719e2f3144df55942">value_type</a></td></tr>
<tr class="memdesc:a34350a20bbd8f9f719e2f3144df55942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym type defining the base class container std::set::value_type.  <a href="#a34350a20bbd8f9f719e2f3144df55942">More...</a><br /></td></tr>
<tr class="separator:a34350a20bbd8f9f719e2f3144df55942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0f99be50ac378e9a9c8fb0257b833c"><td class="memItemLeft" align="right" valign="top">typedef container_type::key_compare&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#a4a0f99be50ac378e9a9c8fb0257b833c">key_compare</a></td></tr>
<tr class="memdesc:a4a0f99be50ac378e9a9c8fb0257b833c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym type defining the key/value comparison std::set::key_compare.  <a href="#a4a0f99be50ac378e9a9c8fb0257b833c">More...</a><br /></td></tr>
<tr class="separator:a4a0f99be50ac378e9a9c8fb0257b833c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53348dfe78ee8b514273aaea6f6e6fb"><td class="memItemLeft" align="right" valign="top">typedef container_type::value_compare&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#af53348dfe78ee8b514273aaea6f6e6fb">value_compare</a></td></tr>
<tr class="separator:af53348dfe78ee8b514273aaea6f6e6fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a822980610d3f4deb3cb0e42ad49a85"><td class="memItemLeft" align="right" valign="top">typedef container_type::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#a2a822980610d3f4deb3cb0e42ad49a85">iterator</a></td></tr>
<tr class="memdesc:a2a822980610d3f4deb3cb0e42ad49a85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym type defining the base class container std::set::iterator.  <a href="#a2a822980610d3f4deb3cb0e42ad49a85">More...</a><br /></td></tr>
<tr class="separator:a2a822980610d3f4deb3cb0e42ad49a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7ea78d89f343eaeb7329d9f73e7f47"><td class="memItemLeft" align="right" valign="top">typedef container_type::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#add7ea78d89f343eaeb7329d9f73e7f47">const_iterator</a></td></tr>
<tr class="memdesc:add7ea78d89f343eaeb7329d9f73e7f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym type defining the base class container std::set::const_iterator.  <a href="#add7ea78d89f343eaeb7329d9f73e7f47">More...</a><br /></td></tr>
<tr class="separator:add7ea78d89f343eaeb7329d9f73e7f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classreflex_1_1_ranges"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classreflex_1_1_ranges')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classreflex_1_1_ranges.html">reflex::Ranges&lt; T &gt;</a></td></tr>
<tr class="memitem:a5932a3dc82b3b47baa01c205b40eec64 inherit pub_types_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a></td></tr>
<tr class="memdesc:a5932a3dc82b3b47baa01c205b40eec64 inherit pub_types_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the bounds.  <a href="#a5932a3dc82b3b47baa01c205b40eec64">More...</a><br /></td></tr>
<tr class="separator:a5932a3dc82b3b47baa01c205b40eec64 inherit pub_types_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed84540bbb395b6f0bc21cb8ea169f1 inherit pub_types_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">typedef std::set&lt; std::pair&lt; T, T &gt;, <a class="el" href="structreflex_1_1range__compare.html">range_compare</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a7ed84540bbb395b6f0bc21cb8ea169f1">container_type</a></td></tr>
<tr class="memdesc:a7ed84540bbb395b6f0bc21cb8ea169f1 inherit pub_types_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym type defining the base class container std::set.  <a href="#a7ed84540bbb395b6f0bc21cb8ea169f1">More...</a><br /></td></tr>
<tr class="separator:a7ed84540bbb395b6f0bc21cb8ea169f1 inherit pub_types_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18640a7ac6891e626c78cbda4ab80abe inherit pub_types_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">typedef container_type::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a18640a7ac6891e626c78cbda4ab80abe">value_type</a></td></tr>
<tr class="memdesc:a18640a7ac6891e626c78cbda4ab80abe inherit pub_types_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym type defining the base class container std::set::value_type.  <a href="#a18640a7ac6891e626c78cbda4ab80abe">More...</a><br /></td></tr>
<tr class="separator:a18640a7ac6891e626c78cbda4ab80abe inherit pub_types_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188adab06dd0d3ed7813ff8d6ad1a121 inherit pub_types_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">typedef container_type::key_compare&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a188adab06dd0d3ed7813ff8d6ad1a121">key_compare</a></td></tr>
<tr class="memdesc:a188adab06dd0d3ed7813ff8d6ad1a121 inherit pub_types_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym type defining the key/value comparison std::set::key_compare.  <a href="#a188adab06dd0d3ed7813ff8d6ad1a121">More...</a><br /></td></tr>
<tr class="separator:a188adab06dd0d3ed7813ff8d6ad1a121 inherit pub_types_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f622467be2e7f9df83a2d0f791bfd90 inherit pub_types_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">typedef container_type::value_compare&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a8f622467be2e7f9df83a2d0f791bfd90">value_compare</a></td></tr>
<tr class="separator:a8f622467be2e7f9df83a2d0f791bfd90 inherit pub_types_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f32a9642333820fd0b9b66af654cb6 inherit pub_types_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">typedef container_type::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#ac6f32a9642333820fd0b9b66af654cb6">iterator</a></td></tr>
<tr class="memdesc:ac6f32a9642333820fd0b9b66af654cb6 inherit pub_types_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym type defining the base class container std::set::iterator.  <a href="#ac6f32a9642333820fd0b9b66af654cb6">More...</a><br /></td></tr>
<tr class="separator:ac6f32a9642333820fd0b9b66af654cb6 inherit pub_types_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551bdfa41f5ba3dd5b91ddcb86b1acd2 inherit pub_types_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">typedef container_type::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a551bdfa41f5ba3dd5b91ddcb86b1acd2">const_iterator</a></td></tr>
<tr class="memdesc:a551bdfa41f5ba3dd5b91ddcb86b1acd2 inherit pub_types_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym type defining the base class container std::set::iterator.  <a href="#a551bdfa41f5ba3dd5b91ddcb86b1acd2">More...</a><br /></td></tr>
<tr class="separator:a551bdfa41f5ba3dd5b91ddcb86b1acd2 inherit pub_types_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a184e3ec1103949b48211effcabf5480d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#a184e3ec1103949b48211effcabf5480d">ORanges</a> ()</td></tr>
<tr class="memdesc:a184e3ec1103949b48211effcabf5480d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty range.  <a href="#a184e3ec1103949b48211effcabf5480d">More...</a><br /></td></tr>
<tr class="separator:a184e3ec1103949b48211effcabf5480d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8469444d467ae43394579d59e2e5e892"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#a8469444d467ae43394579d59e2e5e892">ORanges</a> (const <a class="el" href="classreflex_1_1_ranges.html#a18640a7ac6891e626c78cbda4ab80abe">value_type</a> &amp;r)</td></tr>
<tr class="memdesc:a8469444d467ae43394579d59e2e5e892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a copy of a range [lo,hi].  <a href="#a8469444d467ae43394579d59e2e5e892">More...</a><br /></td></tr>
<tr class="separator:a8469444d467ae43394579d59e2e5e892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcdf67ed7348a0181a8c0fd3090c45c1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#afcdf67ed7348a0181a8c0fd3090c45c1">ORanges</a> (const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;<a class="el" href="classreflex_1_1_ranges.html#aeb29f8017cd8617ed78e8d185a9e2a74">lo</a>, const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;<a class="el" href="classreflex_1_1_o_ranges.html#aebbc4ec485e34807b3f04d8569477bb4">hi</a>)</td></tr>
<tr class="memdesc:afcdf67ed7348a0181a8c0fd3090c45c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a range [lo,hi].  <a href="#afcdf67ed7348a0181a8c0fd3090c45c1">More...</a><br /></td></tr>
<tr class="separator:afcdf67ed7348a0181a8c0fd3090c45c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f15ce9529f5819bd92c4b7eaee1ef8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#a88f15ce9529f5819bd92c4b7eaee1ef8">ORanges</a> (const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;val)</td></tr>
<tr class="memdesc:a88f15ce9529f5819bd92c4b7eaee1ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a singleton range [val,val].  <a href="#a88f15ce9529f5819bd92c4b7eaee1ef8">More...</a><br /></td></tr>
<tr class="separator:a88f15ce9529f5819bd92c4b7eaee1ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab8cad7c40e07960001634985f2d050"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classreflex_1_1_ranges.html#ac6f32a9642333820fd0b9b66af654cb6">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#acab8cad7c40e07960001634985f2d050">insert</a> (const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;<a class="el" href="classreflex_1_1_ranges.html#aeb29f8017cd8617ed78e8d185a9e2a74">lo</a>, const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;<a class="el" href="classreflex_1_1_o_ranges.html#aebbc4ec485e34807b3f04d8569477bb4">hi</a>)</td></tr>
<tr class="memdesc:acab8cad7c40e07960001634985f2d050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update ranges to include range [lo,hi] by merging overlapping and adjacent ranges into one range.  <a href="#acab8cad7c40e07960001634985f2d050">More...</a><br /></td></tr>
<tr class="separator:acab8cad7c40e07960001634985f2d050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaae9f574a9332bf843e263c0f016582"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classreflex_1_1_ranges.html#ac6f32a9642333820fd0b9b66af654cb6">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#adaae9f574a9332bf843e263c0f016582">insert</a> (const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;val)</td></tr>
<tr class="memdesc:adaae9f574a9332bf843e263c0f016582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update ranges to include range [val,val] by merging overlapping and adjacent ranges into one range.  <a href="#adaae9f574a9332bf843e263c0f016582">More...</a><br /></td></tr>
<tr class="separator:adaae9f574a9332bf843e263c0f016582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1bb50ea13bc00cecd426c3c5117249"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#a0e1bb50ea13bc00cecd426c3c5117249">erase</a> (const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;<a class="el" href="classreflex_1_1_ranges.html#aeb29f8017cd8617ed78e8d185a9e2a74">lo</a>, const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;<a class="el" href="classreflex_1_1_o_ranges.html#aebbc4ec485e34807b3f04d8569477bb4">hi</a>)</td></tr>
<tr class="memdesc:a0e1bb50ea13bc00cecd426c3c5117249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update ranges by deleting the given range [lo,hi].  <a href="#a0e1bb50ea13bc00cecd426c3c5117249">More...</a><br /></td></tr>
<tr class="separator:a0e1bb50ea13bc00cecd426c3c5117249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7211b683be1d46062e9d188b781a72e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#af7211b683be1d46062e9d188b781a72e">erase</a> (const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;val)</td></tr>
<tr class="memdesc:af7211b683be1d46062e9d188b781a72e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update ranges by deleting the given range [val,val].  <a href="#af7211b683be1d46062e9d188b781a72e">More...</a><br /></td></tr>
<tr class="separator:af7211b683be1d46062e9d188b781a72e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e66f53d0aed9f1a0aafa7b707205281"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_ranges.html#a551bdfa41f5ba3dd5b91ddcb86b1acd2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#a7e66f53d0aed9f1a0aafa7b707205281">find</a> (const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;<a class="el" href="classreflex_1_1_ranges.html#aeb29f8017cd8617ed78e8d185a9e2a74">lo</a>, const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;<a class="el" href="classreflex_1_1_o_ranges.html#aebbc4ec485e34807b3f04d8569477bb4">hi</a>) const </td></tr>
<tr class="memdesc:a7e66f53d0aed9f1a0aafa7b707205281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first range that overlaps the given range.  <a href="#a7e66f53d0aed9f1a0aafa7b707205281">More...</a><br /></td></tr>
<tr class="separator:a7e66f53d0aed9f1a0aafa7b707205281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d52c358414c1339a6e26d06235f5992"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_ranges.html#a551bdfa41f5ba3dd5b91ddcb86b1acd2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#a8d52c358414c1339a6e26d06235f5992">find</a> (const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;val) const </td></tr>
<tr class="memdesc:a8d52c358414c1339a6e26d06235f5992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the range that includes the given value.  <a href="#a8d52c358414c1339a6e26d06235f5992">More...</a><br /></td></tr>
<tr class="separator:a8d52c358414c1339a6e26d06235f5992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e399bf2042c81e928e283566097f8b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#a6e399bf2042c81e928e283566097f8b9">operator-=</a> (const <a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a> &amp;rs)</td></tr>
<tr class="memdesc:a6e399bf2042c81e928e283566097f8b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update ranges to remove ranges rs, has lower complexity than repeating <a class="el" href="classreflex_1_1_o_ranges.html#a0e1bb50ea13bc00cecd426c3c5117249" title="Update ranges by deleting the given range [lo,hi]. ">erase()</a>.  <a href="#a6e399bf2042c81e928e283566097f8b9">More...</a><br /></td></tr>
<tr class="separator:a6e399bf2042c81e928e283566097f8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59deda9697985a3c07af43a6204e4fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#ad59deda9697985a3c07af43a6204e4fd">operator&amp;=</a> (const <a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a> &amp;rs)</td></tr>
<tr class="memdesc:ad59deda9697985a3c07af43a6204e4fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update ranges to intersect the ranges of the given range set.  <a href="#ad59deda9697985a3c07af43a6204e4fd">More...</a><br /></td></tr>
<tr class="separator:ad59deda9697985a3c07af43a6204e4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2dc1305d1dc89e8043b1867d00e89c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#a4f2dc1305d1dc89e8043b1867d00e89c">operator|</a> (const <a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a> &amp;rs) const </td></tr>
<tr class="memdesc:a4f2dc1305d1dc89e8043b1867d00e89c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the union of two range sets.  <a href="#a4f2dc1305d1dc89e8043b1867d00e89c">More...</a><br /></td></tr>
<tr class="separator:a4f2dc1305d1dc89e8043b1867d00e89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e2177782a200135ec63a4bc12df2c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#a36e2177782a200135ec63a4bc12df2c6">operator+</a> (const <a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a> &amp;rs) const </td></tr>
<tr class="memdesc:a36e2177782a200135ec63a4bc12df2c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the union of two range sets.  <a href="#a36e2177782a200135ec63a4bc12df2c6">More...</a><br /></td></tr>
<tr class="separator:a36e2177782a200135ec63a4bc12df2c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11bc3908554b1604f953d3001820a46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#aa11bc3908554b1604f953d3001820a46">operator-</a> (const <a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a> &amp;rs) const </td></tr>
<tr class="memdesc:aa11bc3908554b1604f953d3001820a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the difference of two open-ended range sets.  <a href="#aa11bc3908554b1604f953d3001820a46">More...</a><br /></td></tr>
<tr class="separator:aa11bc3908554b1604f953d3001820a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289c62f602d438c6ef63a3c32dbd5292"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#a289c62f602d438c6ef63a3c32dbd5292">operator&amp;</a> (const <a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a> &amp;rs) const </td></tr>
<tr class="memdesc:a289c62f602d438c6ef63a3c32dbd5292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the intersection of two open-ended range sets.  <a href="#a289c62f602d438c6ef63a3c32dbd5292">More...</a><br /></td></tr>
<tr class="separator:a289c62f602d438c6ef63a3c32dbd5292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafab298888e6e86590afb7b6e00ea56c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#aafab298888e6e86590afb7b6e00ea56c">intersects</a> (const <a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a> &amp;rs) const </td></tr>
<tr class="memdesc:aafab298888e6e86590afb7b6e00ea56c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this set of ranges intersects with ranges rs, i.e. this set has at least one range [lo',hi'] that overlaps with a range [lo,hi] in rs such that lo &lt;= hi' and lo' &lt;= hi.  <a href="#aafab298888e6e86590afb7b6e00ea56c">More...</a><br /></td></tr>
<tr class="separator:aafab298888e6e86590afb7b6e00ea56c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebbc4ec485e34807b3f04d8569477bb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#aebbc4ec485e34807b3f04d8569477bb4">hi</a> () const </td></tr>
<tr class="memdesc:aebbc4ec485e34807b3f04d8569477bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the highest value in the set of ranges (the set cannot be empty)  <a href="#aebbc4ec485e34807b3f04d8569477bb4">More...</a><br /></td></tr>
<tr class="separator:aebbc4ec485e34807b3f04d8569477bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classreflex_1_1_ranges"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classreflex_1_1_ranges')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classreflex_1_1_ranges.html">reflex::Ranges&lt; T &gt;</a></td></tr>
<tr class="memitem:a113a3eed86ce245a93626b1f5b84c5ad inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a113a3eed86ce245a93626b1f5b84c5ad">Ranges</a> ()</td></tr>
<tr class="memdesc:a113a3eed86ce245a93626b1f5b84c5ad inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty range.  <a href="#a113a3eed86ce245a93626b1f5b84c5ad">More...</a><br /></td></tr>
<tr class="separator:a113a3eed86ce245a93626b1f5b84c5ad inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36353497e22513c992cc68d7057ed209 inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a36353497e22513c992cc68d7057ed209">Ranges</a> (const <a class="el" href="classreflex_1_1_ranges.html#a18640a7ac6891e626c78cbda4ab80abe">value_type</a> &amp;r)</td></tr>
<tr class="memdesc:a36353497e22513c992cc68d7057ed209 inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a copy of a range [lo,hi].  <a href="#a36353497e22513c992cc68d7057ed209">More...</a><br /></td></tr>
<tr class="separator:a36353497e22513c992cc68d7057ed209 inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c27d82deac4a616b3c7f50dc11a66b4 inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a7c27d82deac4a616b3c7f50dc11a66b4">Ranges</a> (const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;<a class="el" href="classreflex_1_1_ranges.html#aeb29f8017cd8617ed78e8d185a9e2a74">lo</a>, const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;<a class="el" href="classreflex_1_1_ranges.html#a467a43c765cf87ed17c0b888f445c9fc">hi</a>)</td></tr>
<tr class="memdesc:a7c27d82deac4a616b3c7f50dc11a66b4 inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a range [lo,hi].  <a href="#a7c27d82deac4a616b3c7f50dc11a66b4">More...</a><br /></td></tr>
<tr class="separator:a7c27d82deac4a616b3c7f50dc11a66b4 inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab375bf376f87fb4f75d20e5af68166f1 inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#ab375bf376f87fb4f75d20e5af68166f1">Ranges</a> (const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;val)</td></tr>
<tr class="memdesc:ab375bf376f87fb4f75d20e5af68166f1 inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a singleton range [val,val].  <a href="#ab375bf376f87fb4f75d20e5af68166f1">More...</a><br /></td></tr>
<tr class="separator:ab375bf376f87fb4f75d20e5af68166f1 inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b80affbf56f12faafae17b0c64dc00 inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classreflex_1_1_ranges.html#ac6f32a9642333820fd0b9b66af654cb6">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a45b80affbf56f12faafae17b0c64dc00">insert</a> (const <a class="el" href="classreflex_1_1_ranges.html#a18640a7ac6891e626c78cbda4ab80abe">value_type</a> &amp;r)</td></tr>
<tr class="memdesc:a45b80affbf56f12faafae17b0c64dc00 inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update ranges to include range [lo,hi] by merging overlapping ranges into one range.  <a href="#a45b80affbf56f12faafae17b0c64dc00">More...</a><br /></td></tr>
<tr class="separator:a45b80affbf56f12faafae17b0c64dc00 inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf55cde7658ed085e54f1c695cb9910 inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classreflex_1_1_ranges.html#ac6f32a9642333820fd0b9b66af654cb6">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#acbf55cde7658ed085e54f1c695cb9910">insert</a> (const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;<a class="el" href="classreflex_1_1_ranges.html#aeb29f8017cd8617ed78e8d185a9e2a74">lo</a>, const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;<a class="el" href="classreflex_1_1_ranges.html#a467a43c765cf87ed17c0b888f445c9fc">hi</a>)</td></tr>
<tr class="memdesc:acbf55cde7658ed085e54f1c695cb9910 inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update ranges to include range [lo,hi] by merging overlapping ranges into one range.  <a href="#acbf55cde7658ed085e54f1c695cb9910">More...</a><br /></td></tr>
<tr class="separator:acbf55cde7658ed085e54f1c695cb9910 inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e9676740f9dee983de782774f077f0 inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classreflex_1_1_ranges.html#ac6f32a9642333820fd0b9b66af654cb6">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#af0e9676740f9dee983de782774f077f0">insert</a> (const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;val)</td></tr>
<tr class="memdesc:af0e9676740f9dee983de782774f077f0 inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update ranges to include the range [val,val].  <a href="#af0e9676740f9dee983de782774f077f0">More...</a><br /></td></tr>
<tr class="separator:af0e9676740f9dee983de782774f077f0 inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7148421186fc5d33f4eb109609e1c4 inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_ranges.html#a551bdfa41f5ba3dd5b91ddcb86b1acd2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a2a7148421186fc5d33f4eb109609e1c4">find</a> (const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;<a class="el" href="classreflex_1_1_ranges.html#aeb29f8017cd8617ed78e8d185a9e2a74">lo</a>, const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;<a class="el" href="classreflex_1_1_ranges.html#a467a43c765cf87ed17c0b888f445c9fc">hi</a>) const </td></tr>
<tr class="memdesc:a2a7148421186fc5d33f4eb109609e1c4 inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first range [lo',hi'] that overlaps the given range [lo,hi], i.e. lo &lt;= hi' and lo' &lt;= hi.  <a href="#a2a7148421186fc5d33f4eb109609e1c4">More...</a><br /></td></tr>
<tr class="separator:a2a7148421186fc5d33f4eb109609e1c4 inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e426ff9650fddac27e0433db0811bc9 inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_ranges.html#a551bdfa41f5ba3dd5b91ddcb86b1acd2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a0e426ff9650fddac27e0433db0811bc9">find</a> (const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;val) const </td></tr>
<tr class="memdesc:a0e426ff9650fddac27e0433db0811bc9 inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the range [lo',hi'] that includes the given value val, i.e. lo' &lt;= val &lt;= hi'.  <a href="#a0e426ff9650fddac27e0433db0811bc9">More...</a><br /></td></tr>
<tr class="separator:a0e426ff9650fddac27e0433db0811bc9 inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86ade66b0f5c3003dbc11e1d4e2d738 inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#ad86ade66b0f5c3003dbc11e1d4e2d738">operator|=</a> (const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;rs)</td></tr>
<tr class="memdesc:ad86ade66b0f5c3003dbc11e1d4e2d738 inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update ranges to insert the given range set, where this method has lower complexity than iterating <a class="el" href="classreflex_1_1_ranges.html#a45b80affbf56f12faafae17b0c64dc00" title="Update ranges to include range [lo,hi] by merging overlapping ranges into one range. ">insert()</a> for each range in rs.  <a href="#ad86ade66b0f5c3003dbc11e1d4e2d738">More...</a><br /></td></tr>
<tr class="separator:ad86ade66b0f5c3003dbc11e1d4e2d738 inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0aa356a5eec364aad70a795aeab68f5 inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#ab0aa356a5eec364aad70a795aeab68f5">operator+=</a> (const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;rs)</td></tr>
<tr class="memdesc:ab0aa356a5eec364aad70a795aeab68f5 inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update ranges to insert the ranges of the given range set, same as Ranges::operator|=(rs).  <a href="#ab0aa356a5eec364aad70a795aeab68f5">More...</a><br /></td></tr>
<tr class="separator:ab0aa356a5eec364aad70a795aeab68f5 inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2feb520bce89afdf80f7d06d8c3bcd inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a3d2feb520bce89afdf80f7d06d8c3bcd">operator&amp;=</a> (const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;rs)</td></tr>
<tr class="memdesc:a3d2feb520bce89afdf80f7d06d8c3bcd inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update ranges to intersect the ranges with the given range set.  <a href="#a3d2feb520bce89afdf80f7d06d8c3bcd">More...</a><br /></td></tr>
<tr class="separator:a3d2feb520bce89afdf80f7d06d8c3bcd inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658a2b69b4e435ecf079e0e5cc98c880 inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_ranges.html">Ranges</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a658a2b69b4e435ecf079e0e5cc98c880">operator|</a> (const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;rs) const </td></tr>
<tr class="memdesc:a658a2b69b4e435ecf079e0e5cc98c880 inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the union of two range sets.  <a href="#a658a2b69b4e435ecf079e0e5cc98c880">More...</a><br /></td></tr>
<tr class="separator:a658a2b69b4e435ecf079e0e5cc98c880 inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14efc99f9c25db9e9b4ef0dbb72e3801 inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_ranges.html">Ranges</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a14efc99f9c25db9e9b4ef0dbb72e3801">operator+</a> (const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;rs) const </td></tr>
<tr class="memdesc:a14efc99f9c25db9e9b4ef0dbb72e3801 inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the union of two range sets, same as Ranges::operator|(rs).  <a href="#a14efc99f9c25db9e9b4ef0dbb72e3801">More...</a><br /></td></tr>
<tr class="separator:a14efc99f9c25db9e9b4ef0dbb72e3801 inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc03786da54f6077febdea2f83110e2 inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_ranges.html">Ranges</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a2bc03786da54f6077febdea2f83110e2">operator&amp;</a> (const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;rs) const </td></tr>
<tr class="memdesc:a2bc03786da54f6077febdea2f83110e2 inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the intersection of two range sets.  <a href="#a2bc03786da54f6077febdea2f83110e2">More...</a><br /></td></tr>
<tr class="separator:a2bc03786da54f6077febdea2f83110e2 inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412f3f7392b76411ed5f1e02ecdebd0c inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a412f3f7392b76411ed5f1e02ecdebd0c">operator&lt;</a> (const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;rs) const </td></tr>
<tr class="memdesc:a412f3f7392b76411ed5f1e02ecdebd0c inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this range set is lexicographically less than range set rs.  <a href="#a412f3f7392b76411ed5f1e02ecdebd0c">More...</a><br /></td></tr>
<tr class="separator:a412f3f7392b76411ed5f1e02ecdebd0c inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be1924a5c28eff510256c8345f65241 inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a2be1924a5c28eff510256c8345f65241">operator&gt;</a> (const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;rs) const </td></tr>
<tr class="memdesc:a2be1924a5c28eff510256c8345f65241 inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this range set is lexicographically greater than range set rs.  <a href="#a2be1924a5c28eff510256c8345f65241">More...</a><br /></td></tr>
<tr class="separator:a2be1924a5c28eff510256c8345f65241 inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21dec3fa4c006ba98e5888b724e7178e inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a21dec3fa4c006ba98e5888b724e7178e">operator&lt;=</a> (const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;rs) const </td></tr>
<tr class="memdesc:a21dec3fa4c006ba98e5888b724e7178e inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this range set is lexicographically less or equal to range set rs.  <a href="#a21dec3fa4c006ba98e5888b724e7178e">More...</a><br /></td></tr>
<tr class="separator:a21dec3fa4c006ba98e5888b724e7178e inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef3e519c643b66d0ab50f77f1780236 inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a3ef3e519c643b66d0ab50f77f1780236">operator&gt;=</a> (const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;rs) const </td></tr>
<tr class="memdesc:a3ef3e519c643b66d0ab50f77f1780236 inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this range set is lexicographically greater or equal to range set rs.  <a href="#a3ef3e519c643b66d0ab50f77f1780236">More...</a><br /></td></tr>
<tr class="separator:a3ef3e519c643b66d0ab50f77f1780236 inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef3e69adbf8dab9c4123a77c873eca1 inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a6ef3e69adbf8dab9c4123a77c873eca1">any</a> () const </td></tr>
<tr class="memdesc:a6ef3e69adbf8dab9c4123a77c873eca1 inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this set of ranges contains at least one range, i.e. is not empty.  <a href="#a6ef3e69adbf8dab9c4123a77c873eca1">More...</a><br /></td></tr>
<tr class="separator:a6ef3e69adbf8dab9c4123a77c873eca1 inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff9a255f63c79bc945cbcde112bd79a inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a8ff9a255f63c79bc945cbcde112bd79a">intersects</a> (const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;rs) const </td></tr>
<tr class="memdesc:a8ff9a255f63c79bc945cbcde112bd79a inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this set of ranges intersects with ranges rs, i.e. this set has at least one range [lo',hi'] that overlaps with a range [lo,hi] in rs such that lo &lt;= hi' and lo' &lt;= hi.  <a href="#a8ff9a255f63c79bc945cbcde112bd79a">More...</a><br /></td></tr>
<tr class="separator:a8ff9a255f63c79bc945cbcde112bd79a inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e84aa26790720fa68ac1882839db0c inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#af1e84aa26790720fa68ac1882839db0c">contains</a> (const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;rs) const </td></tr>
<tr class="memdesc:af1e84aa26790720fa68ac1882839db0c inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this set of ranges contains all ranges in rs, i.e. rs is a subset of this set which means that for each range [lo,hi] in rs, there is a range [lo',hi'] such that lo' &lt;= lo and hi &lt;= hi'.  <a href="#af1e84aa26790720fa68ac1882839db0c">More...</a><br /></td></tr>
<tr class="separator:af1e84aa26790720fa68ac1882839db0c inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb29f8017cd8617ed78e8d185a9e2a74 inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#aeb29f8017cd8617ed78e8d185a9e2a74">lo</a> () const </td></tr>
<tr class="memdesc:aeb29f8017cd8617ed78e8d185a9e2a74 inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lowest value in the set of ranges (the set cannot be empty)  <a href="#aeb29f8017cd8617ed78e8d185a9e2a74">More...</a><br /></td></tr>
<tr class="separator:aeb29f8017cd8617ed78e8d185a9e2a74 inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467a43c765cf87ed17c0b888f445c9fc inherit pub_methods_classreflex_1_1_ranges"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a467a43c765cf87ed17c0b888f445c9fc">hi</a> () const </td></tr>
<tr class="memdesc:a467a43c765cf87ed17c0b888f445c9fc inherit pub_methods_classreflex_1_1_ranges"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the highest value in the set of ranges (the set cannot be empty)  <a href="#a467a43c765cf87ed17c0b888f445c9fc">More...</a><br /></td></tr>
<tr class="separator:a467a43c765cf87ed17c0b888f445c9fc inherit pub_methods_classreflex_1_1_ranges"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a214b9c65df80346fe6e0cb801fee8a40"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_o_ranges.html#a214b9c65df80346fe6e0cb801fee8a40">bump</a> (<a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> val)</td></tr>
<tr class="memdesc:a214b9c65df80346fe6e0cb801fee8a40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bump value.  <a href="#a214b9c65df80346fe6e0cb801fee8a40">More...</a><br /></td></tr>
<tr class="separator:a214b9c65df80346fe6e0cb801fee8a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class reflex::ORanges&lt; T &gt;</h3>

<p>RE/flex <a class="el" href="classreflex_1_1_o_ranges.html" title="RE/flex ORanges (open-ended, ordinal value range) template class. ">ORanges</a> (open-ended, ordinal value range) template class. </p>
<p>The <a class="el" href="classreflex_1_1_o_ranges.html" title="RE/flex ORanges (open-ended, ordinal value range) template class. ">ORanges</a> class is an optimization of the ranges class for ordinal types, i.e. types with the property that values can be counted (enumerable, e.g. integers and enumerations).</p>
<p>The optimization merges adjacent ranges. Two ranges <code>[a,b]</code> and <code>[c,d]</code> are adjacent when <code>b+1=c</code>. It is safe to merge adjacent ranges over values of an ordinal type, because <code>[a,b](+)[b+1,c]=[a,c]</code> with <code>(+)</code> representing range merging (set union).</p>
<p>By storing open-ended ranges <code>[lo,hi+1)</code> in the ranges class container, adjacent ranges are merged automatically by the fact that the bounds of open-ended adjacent ranges overlap.</p>
<p>In addition to the methods inherited from the Range base class, open-ended ranges can be updated by deleting ranges from the set with:</p>
<ul>
<li><code>bool <a class="el" href="classreflex_1_1_o_ranges.html#a0e1bb50ea13bc00cecd426c3c5117249" title="Update ranges by deleting the given range [lo,hi]. ">erase(const bound_type&amp; lo, const bound_type&amp; hi)</a></code> erases a range from this set of open-ended ranges. Returns true if the set was updated.</li>
<li><code>bool <a class="el" href="classreflex_1_1_o_ranges.html#af7211b683be1d46062e9d188b781a72e" title="Update ranges by deleting the given range [val,val]. ">erase(const bound_type&amp; val)</a></code> erases a value from this set of open-ended ranges. Returns true if the set was updated.</li>
<li><code><a class="el" href="classreflex_1_1_o_ranges.html" title="RE/flex ORanges (open-ended, ordinal value range) template class. ">ORanges</a>&amp; <a class="el" href="classreflex_1_1_o_ranges.html#a6e399bf2042c81e928e283566097f8b9" title="Update ranges to remove ranges rs, has lower complexity than repeating erase(). ">operator-=(const ORanges&amp; rs)</a></code> erases ranges rs from this set of open-ended ranges. Returns reference to this object.</li>
<li><code><a class="el" href="classreflex_1_1_o_ranges.html" title="RE/flex ORanges (open-ended, ordinal value range) template class. ">ORanges</a> <a class="el" href="classreflex_1_1_o_ranges.html#aa11bc3908554b1604f953d3001820a46" title="Returns the difference of two open-ended range sets. ">operator-(const ORanges&amp; rs) const</a></code> returns difference, i.e. ranges rs erased from this set of open-ended ranges.</li>
</ul>
<p>Open-ended ranges are more efficient than <code>std::set</code> when the values stored are adjacent (e.g. integers 2 and 3 are adjacent), since <code>std::set</code> stores values individually whereas open-ended ranges merges adjacent values into ranges. This lowers storage overhead and reduces insertion, deletion, and search time.</p>
<p>We can iterate over open-ended ranges. The iterator dereferences values are <code>[lo,hi+1)</code> pairs, i.e. <code>lo = i-&gt;first</code> and <code>hi = i-&gt;second - 1</code>.</p>
<p>Note that the largest value that can be stored in an open-ended range is the maximum representable value minus 1. For example, <code><a class="el" href="classreflex_1_1_o_ranges.html" title="RE/flex ORanges (open-ended, ordinal value range) template class. ">reflex::ORanges</a>&lt;char&gt;</code> holds values -128 to 126 and excludes 127. The macro WITH_ORANGES_CLAMPED can be defined to use this library such that the maximum value is clamped to prevent overflow, e.g. <code><a class="el" href="classreflex_1_1_o_ranges.html" title="RE/flex ORanges (open-ended, ordinal value range) template class. ">reflex::ORanges</a>&lt;char&gt; ch = 127</code> is clamped to 126. However, this still excludes 127 from the range set. This feature should not be required when the library is used with sufficiently wide container value types.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><a class="code" href="classreflex_1_1_o_ranges.html">reflex::ORanges&lt;int&gt;</a> ints;</div><div class="line">ints = 0;              <span class="comment">// insert 0</span></div><div class="line">ints.<a class="code" href="classreflex_1_1_o_ranges.html#acab8cad7c40e07960001634985f2d050">insert</a>(100, 200); <span class="comment">// insert 100..200</span></div><div class="line">ints.<a class="code" href="classreflex_1_1_o_ranges.html#acab8cad7c40e07960001634985f2d050">insert</a>(300, 400); <span class="comment">// insert 300..400</span></div><div class="line">ints.<a class="code" href="classreflex_1_1_o_ranges.html#acab8cad7c40e07960001634985f2d050">insert</a>(200, 300); <span class="comment">// insert 200..300</span></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Set of &quot;</span> &lt;&lt; ints.size() &lt;&lt; <span class="stringliteral">&quot; open-ended ranges:&quot;</span> &lt;&lt; std::endl;</div><div class="line"><span class="keywordflow">for</span> (<a class="code" href="classreflex_1_1_o_ranges.html#add7ea78d89f343eaeb7329d9f73e7f47">reflex::ORanges&lt;int&gt;::const_iterator</a> i = ints.begin(); i != ints.end(); ++i)</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; i-&gt;first &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; i-&gt;second &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div><div class="line">if (ints.<a class="code" href="classreflex_1_1_o_ranges.html#a7e66f53d0aed9f1a0aafa7b707205281">find</a>(200) != ints.end())</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;200 is in the set&quot;</span> &lt;&lt; std::endl;</div><div class="line"><span class="keywordflow">if</span> (ints.<a class="code" href="classreflex_1_1_o_ranges.html#a7e66f53d0aed9f1a0aafa7b707205281">find</a>(99) == ints.end())</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;99 is not in the set&quot;</span> &lt;&lt; std::endl;</div><div class="line"><span class="keywordflow">if</span> (ints.<a class="code" href="classreflex_1_1_o_ranges.html#a7e66f53d0aed9f1a0aafa7b707205281">find</a>(401) == ints.end())</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;401 is not in the set&quot;</span> &lt;&lt; std::endl;</div><div class="line">ints.<a class="code" href="classreflex_1_1_o_ranges.html#a0e1bb50ea13bc00cecd426c3c5117249">erase</a>(250, 350);</div><div class="line"><span class="keywordflow">for</span> (<a class="code" href="classreflex_1_1_o_ranges.html#add7ea78d89f343eaeb7329d9f73e7f47">reflex::ORanges&lt;int&gt;::const_iterator</a> i = ints.begin(); i != ints.end(); ++i)</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; i-&gt;first &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; i-&gt;second &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div></div><!-- fragment --><p>Output:</p>
<p>Set of 2 open-ended ranges: [0,1) [100,401) 200 is in the set 99 is not in the set 401 is not in the set [0,1) [100,250) [351,401) </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a9306ca6343c93417ee45602d1e854a0f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::<a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the bounds. </p>

</div>
</div>
<a class="anchor" id="add7ea78d89f343eaeb7329d9f73e7f47"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef container_type::const_iterator <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::<a class="el" href="classreflex_1_1_ranges.html#a551bdfa41f5ba3dd5b91ddcb86b1acd2">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym type defining the base class container std::set::const_iterator. </p>

</div>
</div>
<a class="anchor" id="a2279c7fc683a9719345e6150c9720e2a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::set&lt; std::pair&lt;T,T&gt;,<a class="el" href="structreflex_1_1range__compare.html">range_compare</a>&lt;T&gt; &gt; <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::<a class="el" href="classreflex_1_1_ranges.html#a7ed84540bbb395b6f0bc21cb8ea169f1">container_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym type defining the base class container std::set. </p>

</div>
</div>
<a class="anchor" id="a2a822980610d3f4deb3cb0e42ad49a85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef container_type::iterator <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::<a class="el" href="classreflex_1_1_ranges.html#ac6f32a9642333820fd0b9b66af654cb6">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym type defining the base class container std::set::iterator. </p>

</div>
</div>
<a class="anchor" id="a4a0f99be50ac378e9a9c8fb0257b833c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef container_type::key_compare <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::<a class="el" href="classreflex_1_1_ranges.html#a188adab06dd0d3ed7813ff8d6ad1a121">key_compare</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym type defining the key/value comparison std::set::key_compare. </p>

</div>
</div>
<a class="anchor" id="af53348dfe78ee8b514273aaea6f6e6fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef container_type::value_compare <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::<a class="el" href="classreflex_1_1_ranges.html#a8f622467be2e7f9df83a2d0f791bfd90">value_compare</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a34350a20bbd8f9f719e2f3144df55942"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef container_type::value_type <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::<a class="el" href="classreflex_1_1_ranges.html#a18640a7ac6891e626c78cbda4ab80abe">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym type defining the base class container std::set::value_type. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a184e3ec1103949b48211effcabf5480d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::<a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an empty range. </p>

</div>
</div>
<a class="anchor" id="a8469444d467ae43394579d59e2e5e892"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::<a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html#a18640a7ac6891e626c78cbda4ab80abe">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a copy of a range [lo,hi]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afcdf67ed7348a0181a8c0fd3090c45c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::<a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;&#160;</td>
          <td class="paramname"><em>hi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a range [lo,hi]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>lower bound </td></tr>
    <tr><td class="paramname">hi</td><td>upper bound </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a88f15ce9529f5819bd92c4b7eaee1ef8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::<a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a singleton range [val,val]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a214b9c65df80346fe6e0cb801fee8a40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::bump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bump value. </p>
<dl class="section return"><dt>Returns</dt><dd>val + 1. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to bump </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0e1bb50ea13bc00cecd426c3c5117249"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;&#160;</td>
          <td class="paramname"><em>hi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update ranges by deleting the given range [lo,hi]. </p>
<dl class="section return"><dt>Returns</dt><dd>true if ranges was updated. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>lower bound </td></tr>
    <tr><td class="paramname">hi</td><td>upper bound </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af7211b683be1d46062e9d188b781a72e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update ranges by deleting the given range [val,val]. </p>
<dl class="section return"><dt>Returns</dt><dd>true if ranges was updated. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>value to delete </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7e66f53d0aed9f1a0aafa7b707205281"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_ranges.html#a551bdfa41f5ba3dd5b91ddcb86b1acd2">const_iterator</a> <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;&#160;</td>
          <td class="paramname"><em>hi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first range that overlaps the given range. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the first range that overlaps the given range, or the end iterator. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>lower bound </td></tr>
    <tr><td class="paramname">hi</td><td>upper bound </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8d52c358414c1339a6e26d06235f5992"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_ranges.html#a551bdfa41f5ba3dd5b91ddcb86b1acd2">const_iterator</a> <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the range that includes the given value. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the range that includes the value, or the end iterator. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>value to search for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aebbc4ec485e34807b3f04d8569477bb4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::hi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the highest value in the set of ranges (the set cannot be empty) </p>
<dl class="section return"><dt>Returns</dt><dd>highest value </dd></dl>

</div>
</div>
<a class="anchor" id="acab8cad7c40e07960001634985f2d050"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classreflex_1_1_ranges.html#ac6f32a9642333820fd0b9b66af654cb6">iterator</a>,bool&gt; <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;&#160;</td>
          <td class="paramname"><em>hi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update ranges to include range [lo,hi] by merging overlapping and adjacent ranges into one range. </p>
<dl class="section return"><dt>Returns</dt><dd>a pair of an iterator to the range and a flag indicating whether the range was inserted as new. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>lower bound </td></tr>
    <tr><td class="paramname">hi</td><td>upper bound </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adaae9f574a9332bf843e263c0f016582"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classreflex_1_1_ranges.html#ac6f32a9642333820fd0b9b66af654cb6">iterator</a>,bool&gt; <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update ranges to include range [val,val] by merging overlapping and adjacent ranges into one range. </p>
<dl class="section return"><dt>Returns</dt><dd>a pair of an iterator to the range and a flag indicating whether the range was inserted as new. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>value to insert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aafab298888e6e86590afb7b6e00ea56c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::intersects </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this set of ranges intersects with ranges rs, i.e. this set has at least one range [lo',hi'] that overlaps with a range [lo,hi] in rs such that lo &lt;= hi' and lo' &lt;= hi. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this set intersects rs. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rs</td><td>ranges </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a289c62f602d438c6ef63a3c32dbd5292"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a> <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the intersection of two open-ended range sets. </p>
<dl class="section return"><dt>Returns</dt><dd>the intersection of this set and rs. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rs</td><td>ranges to intersect </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad59deda9697985a3c07af43a6204e4fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a>&amp; <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update ranges to intersect the ranges of the given range set. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to this object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rs</td><td>ranges to intersect </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a36e2177782a200135ec63a4bc12df2c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a> <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the union of two range sets. </p>
<dl class="section return"><dt>Returns</dt><dd>the union of this set and rs. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rs</td><td>ranges to merge </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa11bc3908554b1604f953d3001820a46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a> <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the difference of two open-ended range sets. </p>
<dl class="section return"><dt>Returns</dt><dd>the difference of this set and rs. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rs</td><td>ranges </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6e399bf2042c81e928e283566097f8b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a>&amp; <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update ranges to remove ranges rs, has lower complexity than repeating <a class="el" href="classreflex_1_1_o_ranges.html#a0e1bb50ea13bc00cecd426c3c5117249" title="Update ranges by deleting the given range [lo,hi]. ">erase()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a4f2dc1305d1dc89e8043b1867d00e89c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a> <a class="el" href="classreflex_1_1_o_ranges.html">reflex::ORanges</a>&lt; T &gt;::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_o_ranges.html">ORanges</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the union of two range sets. </p>
<dl class="section return"><dt>Returns</dt><dd>the union of this set and rs. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rs</td><td>ranges to merge </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="ranges_8h.html">ranges.h</a></li>
</ul>
</div><!-- contents -->
<hr class="footer">
<address class="footer"><small>
Converted on Wed Jul 6 2022 10:30:15 by <a target="_blank" href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.11</small></address>
<br>
<div style="height: 246px; background: #DBDBDB;">
</body>
</html>
