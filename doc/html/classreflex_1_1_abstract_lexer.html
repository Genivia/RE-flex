<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta http-equiv="cache-control" content="no-cache">
<title>reflex::AbstractLexer&lt; M &gt; Class Template Reference</title>
<link href="doxygen_tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="doxygen_content.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top">
 <div id="titlearea">
  <table height="72px" width="100%" cellspacing="0" cellpadding="0">
   <tbody>
    <tr>
     <td width="10%">&nbsp;</td>
     <td><a href="https://github.com/Genivia/RE-flex"><img src="reflex-logo.png"/></a></td>
     <td>
      <div style="float: right; font-size: 18px; font-weight: bold;">reflex::AbstractLexer&lt; M &gt; Class Template Reference</div>
      <br>
      <div style="float: right; font-size: 10px;">updated Wed Jul 6 2022 by Robert van Engelen</div>
     </td>
     <td width="10%">&nbsp;</td>
    </tr>
   </tbody>
  </table>
 </div>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacereflex.html">reflex</a></li><li class="navelem"><a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classreflex_1_1_abstract_lexer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">reflex::AbstractLexer&lt; M &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The abstract lexer class template that is the abstract root class of all reflex-generated scanners.  
 <a href="classreflex_1_1_abstract_lexer.html#details">More...</a></p>

<p><code>#include &lt;abslexer.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for reflex::AbstractLexer&lt; M &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classreflex_1_1_abstract_lexer__inherit__graph.png" border="0" usemap="#reflex_1_1_abstract_lexer_3_01_m_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="reflex_1_1_abstract_lexer_3_01_m_01_4_inherit__map" id="reflex_1_1_abstract_lexer_3_01_m_01_4_inherit__map">
<area shape="rect" id="node2" href="classreflex_1_1_flex_lexer.html" title="Flex&#45;compatible FlexLexer abstract base class template derived from reflex::AbstractMatcher for the r..." alt="" coords="17,80,172,107"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for reflex::AbstractLexer&lt; M &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classreflex_1_1_abstract_lexer__coll__graph.png" border="0" usemap="#reflex_1_1_abstract_lexer_3_01_m_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="reflex_1_1_abstract_lexer_3_01_m_01_4_coll__map" id="reflex_1_1_abstract_lexer_3_01_m_01_4_coll__map">
<area shape="rect" id="node3" href="classreflex_1_1_abstract_lexer_1_1_matcher.html" title="Extend matcher class M with a member pointing to the instantiating lexer class. " alt="" coords="1323,47,1467,89"/>
<area shape="rect" id="node5" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. " alt="" coords="843,85,935,112"/>
<area shape="rect" id="node6" href="structreflex_1_1_input_1_1_handler.html" title="FILE* handler functor base class to handle FILE* errors and non&#45;blocking FILE* reads. " alt="" coords="541,35,687,61"/>
<area shape="rect" id="node7" title="STL class. " alt="" coords="569,85,659,112"/>
<area shape="rect" id="node8" title="STL class. " alt="" coords="361,77,490,118"/>
<area shape="rect" id="node9" title="STL class. " alt="" coords="155,117,309,144"/>
<area shape="rect" id="node13" title="STL class. " alt="" coords="359,142,492,183"/>
<area shape="rect" id="node10" title="STL class. " alt="" coords="5,117,105,144"/>
<area shape="rect" id="node12" title="STL class. " alt="" coords="711,140,807,167"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend matcher class M with a member pointing to the instantiating lexer class.  <a href="classreflex_1_1_abstract_lexer_1_1_matcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a536b9af11d41ac2441dd8739c64901ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a536b9af11d41ac2441dd8739c64901ae">AbstractLexer</a> (const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;input, std::ostream &amp;<a class="el" href="classreflex_1_1_abstract_lexer.html#a520efbcc7a4007bcbdb702b118e1b5ea">os</a>)</td></tr>
<tr class="memdesc:a536b9af11d41ac2441dd8739c64901ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct abstract lexer to scan an input character sequence and echo the text matches to output.  <a href="#a536b9af11d41ac2441dd8739c64901ae">More...</a><br /></td></tr>
<tr class="separator:a536b9af11d41ac2441dd8739c64901ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3dd2c00e0c5a5a478a02cacaf57bd96"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#ad3dd2c00e0c5a5a478a02cacaf57bd96">~AbstractLexer</a> ()</td></tr>
<tr class="memdesc:ad3dd2c00e0c5a5a478a02cacaf57bd96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete lexer and its current matcher with its associated input.  <a href="#ad3dd2c00e0c5a5a478a02cacaf57bd96">More...</a><br /></td></tr>
<tr class="separator:ad3dd2c00e0c5a5a478a02cacaf57bd96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a070058e52c93918d41b1f37901f01b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a3a070058e52c93918d41b1f37901f01b">set_debug</a> (int flag)</td></tr>
<tr class="memdesc:a3a070058e52c93918d41b1f37901f01b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set debug flag value.  <a href="#a3a070058e52c93918d41b1f37901f01b">More...</a><br /></td></tr>
<tr class="separator:a3a070058e52c93918d41b1f37901f01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bdc642fbcb9b37c124c44f11b335bd"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#ac4bdc642fbcb9b37c124c44f11b335bd">debug</a> () const </td></tr>
<tr class="memdesc:ac4bdc642fbcb9b37c124c44f11b335bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get debug flag value.  <a href="#ac4bdc642fbcb9b37c124c44f11b335bd">More...</a><br /></td></tr>
<tr class="separator:ac4bdc642fbcb9b37c124c44f11b335bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeedf0d263073b3447b26877c2ef03101"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#aeedf0d263073b3447b26877c2ef03101">perf_report</a> ()</td></tr>
<tr class="memdesc:aeedf0d263073b3447b26877c2ef03101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy performance reporter, to prevent link errors when reflex option -p is omitted.  <a href="#aeedf0d263073b3447b26877c2ef03101">More...</a><br /></td></tr>
<tr class="separator:aeedf0d263073b3447b26877c2ef03101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca2e0dcb03e92d26478145004d077b6"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#aeca2e0dcb03e92d26478145004d077b6">wrap</a> ()</td></tr>
<tr class="memdesc:aeca2e0dcb03e92d26478145004d077b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default wrap operation at EOF: do not wrap input.  <a href="#aeca2e0dcb03e92d26478145004d077b6">More...</a><br /></td></tr>
<tr class="separator:aeca2e0dcb03e92d26478145004d077b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e93c71d6cc835ad29e39d5663bd026"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:a86e93c71d6cc835ad29e39d5663bd026"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a86e93c71d6cc835ad29e39d5663bd026">in</a> (const I &amp;input)</td></tr>
<tr class="memdesc:a86e93c71d6cc835ad29e39d5663bd026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the matcher and start scanning from the given input character sequence I.  <a href="#a86e93c71d6cc835ad29e39d5663bd026">More...</a><br /></td></tr>
<tr class="separator:a86e93c71d6cc835ad29e39d5663bd026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50727a74a6e9afe88ab7694047cadbe8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a50727a74a6e9afe88ab7694047cadbe8">in</a> (const char *b, size_t n)</td></tr>
<tr class="memdesc:a50727a74a6e9afe88ab7694047cadbe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the matcher and start scanning from the given byte sequence.  <a href="#a50727a74a6e9afe88ab7694047cadbe8">More...</a><br /></td></tr>
<tr class="separator:a50727a74a6e9afe88ab7694047cadbe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90af4baa6d064decf87f54aeb95806d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_input.html">Input</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a90af4baa6d064decf87f54aeb95806d8">in</a> ()</td></tr>
<tr class="memdesc:a90af4baa6d064decf87f54aeb95806d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current input character sequence that is being scanned.  <a href="#a90af4baa6d064decf87f54aeb95806d8">More...</a><br /></td></tr>
<tr class="separator:a90af4baa6d064decf87f54aeb95806d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b88719f4d035a4aefc2f67fd09f8d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_input.html">Input</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#aa5b88719f4d035a4aefc2f67fd09f8d2">stdinit</a> ()</td></tr>
<tr class="memdesc:aa5b88719f4d035a4aefc2f67fd09f8d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current input character sequence that is being scanned, if none assign stdin.  <a href="#aa5b88719f4d035a4aefc2f67fd09f8d2">More...</a><br /></td></tr>
<tr class="separator:aa5b88719f4d035a4aefc2f67fd09f8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da401412f85849c7b7e744ad4824731"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_input.html">Input</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a7da401412f85849c7b7e744ad4824731">nostdinit</a> ()</td></tr>
<tr class="memdesc:a7da401412f85849c7b7e744ad4824731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current input character sequence that is being scanned, if none assign std::cin.  <a href="#a7da401412f85849c7b7e744ad4824731">More...</a><br /></td></tr>
<tr class="separator:a7da401412f85849c7b7e744ad4824731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862b4bd60ae3a2fb7a77825c5f759e41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a862b4bd60ae3a2fb7a77825c5f759e41">buffer</a> (char *base, size_t <a class="el" href="classreflex_1_1_abstract_lexer.html#a4adf95aef287ae60d22c7bbdf513570f">size</a>)</td></tr>
<tr class="memdesc:a862b4bd60ae3a2fb7a77825c5f759e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the matcher and start scanning the given buffer containing 0-terminated character data (data may be modified).  <a href="#a862b4bd60ae3a2fb7a77825c5f759e41">More...</a><br /></td></tr>
<tr class="separator:a862b4bd60ae3a2fb7a77825c5f759e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5611c94c961a216fc733244c9b688f8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a5611c94c961a216fc733244c9b688f8f">out</a> (std::ostream &amp;<a class="el" href="classreflex_1_1_abstract_lexer.html#a520efbcc7a4007bcbdb702b118e1b5ea">os</a>)</td></tr>
<tr class="memdesc:a5611c94c961a216fc733244c9b688f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current output to the given output stream to echo text matches to.  <a href="#a5611c94c961a216fc733244c9b688f8f">More...</a><br /></td></tr>
<tr class="separator:a5611c94c961a216fc733244c9b688f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4c3de6df3eb45dfd4c3ed86be405e5"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a5f4c3de6df3eb45dfd4c3ed86be405e5">out</a> () const </td></tr>
<tr class="memdesc:a5f4c3de6df3eb45dfd4c3ed86be405e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current output stream used to echo text matches to.  <a href="#a5f4c3de6df3eb45dfd4c3ed86be405e5">More...</a><br /></td></tr>
<tr class="separator:a5f4c3de6df3eb45dfd4c3ed86be405e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520efbcc7a4007bcbdb702b118e1b5ea"><td class="memItemLeft" align="right" valign="top">std::ostream *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a520efbcc7a4007bcbdb702b118e1b5ea">os</a> ()</td></tr>
<tr class="memdesc:a520efbcc7a4007bcbdb702b118e1b5ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the current output stream used to echo text matches to.  <a href="#a520efbcc7a4007bcbdb702b118e1b5ea">More...</a><br /></td></tr>
<tr class="separator:a520efbcc7a4007bcbdb702b118e1b5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac54e52193bb1a175f82b35c9ddfecf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#abac54e52193bb1a175f82b35c9ddfecf">has_matcher</a> () const </td></tr>
<tr class="memdesc:abac54e52193bb1a175f82b35c9ddfecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a matcher was assigned to this lexer for scanning.  <a href="#abac54e52193bb1a175f82b35c9ddfecf">More...</a><br /></td></tr>
<tr class="separator:abac54e52193bb1a175f82b35c9ddfecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ee52cef2c37c2ca47a686eea75a5db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a70ee52cef2c37c2ca47a686eea75a5db">matcher</a> (<a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a> *matcher)</td></tr>
<tr class="memdesc:a70ee52cef2c37c2ca47a686eea75a5db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the matcher (and its current state) for scanning.  <a href="#a70ee52cef2c37c2ca47a686eea75a5db">More...</a><br /></td></tr>
<tr class="separator:a70ee52cef2c37c2ca47a686eea75a5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0be24643126521aeac9cc4cfcaf206a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#aa0be24643126521aeac9cc4cfcaf206a">matcher</a> () const </td></tr>
<tr class="memdesc:aa0be24643126521aeac9cc4cfcaf206a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the current matcher.  <a href="#aa0be24643126521aeac9cc4cfcaf206a">More...</a><br /></td></tr>
<tr class="separator:aa0be24643126521aeac9cc4cfcaf206a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d33059076b03430591e369b5ef96eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a85d33059076b03430591e369b5ef96eb">ptr_matcher</a> () const </td></tr>
<tr class="memdesc:a85d33059076b03430591e369b5ef96eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the current matcher, NULL if none was set.  <a href="#a85d33059076b03430591e369b5ef96eb">More...</a><br /></td></tr>
<tr class="separator:a85d33059076b03430591e369b5ef96eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91254a55027878842695841c8caffdb3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a91254a55027878842695841c8caffdb3">new_matcher</a> (const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;input=<a class="el" href="classreflex_1_1_input.html">Input</a>(), const char *opt=NULL)</td></tr>
<tr class="memdesc:a91254a55027878842695841c8caffdb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new copy of the matcher for the given input.  <a href="#a91254a55027878842695841c8caffdb3">More...</a><br /></td></tr>
<tr class="separator:a91254a55027878842695841c8caffdb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d00ce513ed727dc4fdde304fcb8d97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a45d00ce513ed727dc4fdde304fcb8d97">del_matcher</a> (<a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a> *<a class="el" href="classreflex_1_1_abstract_lexer.html#a70ee52cef2c37c2ca47a686eea75a5db">matcher</a>)</td></tr>
<tr class="memdesc:a45d00ce513ed727dc4fdde304fcb8d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a matcher.  <a href="#a45d00ce513ed727dc4fdde304fcb8d97">More...</a><br /></td></tr>
<tr class="separator:a45d00ce513ed727dc4fdde304fcb8d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7da8596b9eeb820214e2630a331e43d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#aa7da8596b9eeb820214e2630a331e43d">push_matcher</a> (<a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a> *<a class="el" href="classreflex_1_1_abstract_lexer.html#a70ee52cef2c37c2ca47a686eea75a5db">matcher</a>)</td></tr>
<tr class="memdesc:aa7da8596b9eeb820214e2630a331e43d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push the current matcher on the stack and use the given matcher for scanning.  <a href="#aa7da8596b9eeb820214e2630a331e43d">More...</a><br /></td></tr>
<tr class="separator:aa7da8596b9eeb820214e2630a331e43d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fed855c7271786b505f6a68fb475db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a83fed855c7271786b505f6a68fb475db">pop_matcher</a> ()</td></tr>
<tr class="memdesc:a83fed855c7271786b505f6a68fb475db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop matcher from the stack and continue scanning where it left off, delete the current matcher.  <a href="#a83fed855c7271786b505f6a68fb475db">More...</a><br /></td></tr>
<tr class="separator:a83fed855c7271786b505f6a68fb475db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad708880eff5601208180600758773a1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#ad708880eff5601208180600758773a1f">echo</a> () const </td></tr>
<tr class="memdesc:ad708880eff5601208180600758773a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Echo the matched text to the current output.  <a href="#ad708880eff5601208180600758773a1f">More...</a><br /></td></tr>
<tr class="separator:ad708880eff5601208180600758773a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1696b73ebd927f1093985f866d73bf6"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#ac1696b73ebd927f1093985f866d73bf6">text</a> () const </td></tr>
<tr class="memdesc:ac1696b73ebd927f1093985f866d73bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns string with the text matched.  <a href="#ac1696b73ebd927f1093985f866d73bf6">More...</a><br /></td></tr>
<tr class="separator:ac1696b73ebd927f1093985f866d73bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b43d3eabdf73eaf8106c33af71fb57"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a25b43d3eabdf73eaf8106c33af71fb57">str</a> () const </td></tr>
<tr class="memdesc:a25b43d3eabdf73eaf8106c33af71fb57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns string with a copy of the text matched.  <a href="#a25b43d3eabdf73eaf8106c33af71fb57">More...</a><br /></td></tr>
<tr class="separator:a25b43d3eabdf73eaf8106c33af71fb57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cefad78219d2fe0b10e49a4f74204cc"><td class="memItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a9cefad78219d2fe0b10e49a4f74204cc">wstr</a> () const </td></tr>
<tr class="memdesc:a9cefad78219d2fe0b10e49a4f74204cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns wide string with a copy of the text matched.  <a href="#a9cefad78219d2fe0b10e49a4f74204cc">More...</a><br /></td></tr>
<tr class="separator:a9cefad78219d2fe0b10e49a4f74204cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08720e165486e2db19cdcd99ee80fb1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#aa08720e165486e2db19cdcd99ee80fb1">chr</a> () const </td></tr>
<tr class="memdesc:aa08720e165486e2db19cdcd99ee80fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first 8-bit character of the text matched.  <a href="#aa08720e165486e2db19cdcd99ee80fb1">More...</a><br /></td></tr>
<tr class="separator:aa08720e165486e2db19cdcd99ee80fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160da2c0f59e43836cacad171badd45f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a160da2c0f59e43836cacad171badd45f">wchr</a> () const </td></tr>
<tr class="memdesc:a160da2c0f59e43836cacad171badd45f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first wide character of the text matched.  <a href="#a160da2c0f59e43836cacad171badd45f">More...</a><br /></td></tr>
<tr class="separator:a160da2c0f59e43836cacad171badd45f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4adf95aef287ae60d22c7bbdf513570f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a4adf95aef287ae60d22c7bbdf513570f">size</a> () const </td></tr>
<tr class="memdesc:a4adf95aef287ae60d22c7bbdf513570f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the matched text size in number of bytes.  <a href="#a4adf95aef287ae60d22c7bbdf513570f">More...</a><br /></td></tr>
<tr class="separator:a4adf95aef287ae60d22c7bbdf513570f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c209d1965c6917dace3631cbd4fc82"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a57c209d1965c6917dace3631cbd4fc82">wsize</a> () const </td></tr>
<tr class="memdesc:a57c209d1965c6917dace3631cbd4fc82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the matched text size in number of (wide) characters.  <a href="#a57c209d1965c6917dace3631cbd4fc82">More...</a><br /></td></tr>
<tr class="separator:a57c209d1965c6917dace3631cbd4fc82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec39f17dabf8019919ab2b515a660e82"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#aec39f17dabf8019919ab2b515a660e82">lineno</a> () const </td></tr>
<tr class="memdesc:aec39f17dabf8019919ab2b515a660e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the line number of matched text.  <a href="#aec39f17dabf8019919ab2b515a660e82">More...</a><br /></td></tr>
<tr class="separator:aec39f17dabf8019919ab2b515a660e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c0351bb149281f0a0014ec271a349a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a20c0351bb149281f0a0014ec271a349a">lineno</a> (size_t n)</td></tr>
<tr class="memdesc:a20c0351bb149281f0a0014ec271a349a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set or change the starting line number of the last match.  <a href="#a20c0351bb149281f0a0014ec271a349a">More...</a><br /></td></tr>
<tr class="separator:a20c0351bb149281f0a0014ec271a349a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4cf455c03298f1ca49f118b412d111"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a0f4cf455c03298f1ca49f118b412d111">lines</a> () const </td></tr>
<tr class="memdesc:a0f4cf455c03298f1ca49f118b412d111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of lines that the match spans.  <a href="#a0f4cf455c03298f1ca49f118b412d111">More...</a><br /></td></tr>
<tr class="separator:a0f4cf455c03298f1ca49f118b412d111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a338a21634404913bd5f38efedf2a109a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a338a21634404913bd5f38efedf2a109a">lineno_end</a> () const </td></tr>
<tr class="memdesc:a338a21634404913bd5f38efedf2a109a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ending line number of matched text.  <a href="#a338a21634404913bd5f38efedf2a109a">More...</a><br /></td></tr>
<tr class="separator:a338a21634404913bd5f38efedf2a109a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7991f7785e86d29c9f64d9991ce47f9e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a7991f7785e86d29c9f64d9991ce47f9e">columno</a> () const </td></tr>
<tr class="memdesc:a7991f7785e86d29c9f64d9991ce47f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the starting column number of matched text, taking tab spacing into account and counting wide characters as one character each.  <a href="#a7991f7785e86d29c9f64d9991ce47f9e">More...</a><br /></td></tr>
<tr class="separator:a7991f7785e86d29c9f64d9991ce47f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cdf0a400fd515dc2141b993a887cfbe"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a8cdf0a400fd515dc2141b993a887cfbe">columns</a> () const </td></tr>
<tr class="memdesc:a8cdf0a400fd515dc2141b993a887cfbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of columns of the last line (or the single line of matched text) in the matched text, taking tab spacing into account and counting wide characters as one character each.  <a href="#a8cdf0a400fd515dc2141b993a887cfbe">More...</a><br /></td></tr>
<tr class="separator:a8cdf0a400fd515dc2141b993a887cfbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834e21c4d177c26956dfe0d90beb677a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a834e21c4d177c26956dfe0d90beb677a">columno_end</a> () const </td></tr>
<tr class="memdesc:a834e21c4d177c26956dfe0d90beb677a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ending column number of matched text, taking tab spacing into account and counting wide characters as one character each.  <a href="#a834e21c4d177c26956dfe0d90beb677a">More...</a><br /></td></tr>
<tr class="separator:a834e21c4d177c26956dfe0d90beb677a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905c83f6978b3599c43167ae3c7f5b30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a905c83f6978b3599c43167ae3c7f5b30">start</a> (int state)</td></tr>
<tr class="memdesc:a905c83f6978b3599c43167ae3c7f5b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transition to the given start condition state.  <a href="#a905c83f6978b3599c43167ae3c7f5b30">More...</a><br /></td></tr>
<tr class="separator:a905c83f6978b3599c43167ae3c7f5b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac003645fb8e8d8ddb1c268af6ab3b258"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#ac003645fb8e8d8ddb1c268af6ab3b258">start</a> () const </td></tr>
<tr class="memdesc:ac003645fb8e8d8ddb1c268af6ab3b258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current start condition state.  <a href="#ac003645fb8e8d8ddb1c268af6ab3b258">More...</a><br /></td></tr>
<tr class="separator:ac003645fb8e8d8ddb1c268af6ab3b258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996791039f153c27947dab23db026f41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a996791039f153c27947dab23db026f41">push_state</a> (int state)</td></tr>
<tr class="memdesc:a996791039f153c27947dab23db026f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push the current start condition state on the stack and transition to the given start condition state.  <a href="#a996791039f153c27947dab23db026f41">More...</a><br /></td></tr>
<tr class="separator:a996791039f153c27947dab23db026f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc3e098fc89e5bdc1f6d44af0d85c8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a2bc3e098fc89e5bdc1f6d44af0d85c8f">pop_state</a> ()</td></tr>
<tr class="memdesc:a2bc3e098fc89e5bdc1f6d44af0d85c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the stack start condition state and transition to that state.  <a href="#a2bc3e098fc89e5bdc1f6d44af0d85c8f">More...</a><br /></td></tr>
<tr class="separator:a2bc3e098fc89e5bdc1f6d44af0d85c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ccbfb254360056a679cef8702228f6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#ae5ccbfb254360056a679cef8702228f6">top_state</a> () const </td></tr>
<tr class="memdesc:ae5ccbfb254360056a679cef8702228f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stack top start condition state or 0 (INITIAL) if the stack is empty.  <a href="#ae5ccbfb254360056a679cef8702228f6">More...</a><br /></td></tr>
<tr class="separator:ae5ccbfb254360056a679cef8702228f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef7b75dfc67ee897a77e70ed7ca46d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a4ef7b75dfc67ee897a77e70ed7ca46d2">states_empty</a> () const </td></tr>
<tr class="memdesc:a4ef7b75dfc67ee897a77e70ed7ca46d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the condition state stack is empty.  <a href="#a4ef7b75dfc67ee897a77e70ed7ca46d2">More...</a><br /></td></tr>
<tr class="separator:a4ef7b75dfc67ee897a77e70ed7ca46d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48da3dea969abc450e9f050600fd43d9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a48da3dea969abc450e9f050600fd43d9">lexer_error</a> (const char *message=NULL)</td></tr>
<tr class="memdesc:a48da3dea969abc450e9f050600fd43d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexer exceptions.  <a href="#a48da3dea969abc450e9f050600fd43d9">More...</a><br /></td></tr>
<tr class="separator:a48da3dea969abc450e9f050600fd43d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a5476b6d021bcbb48aa1623f3a8338b5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_input.html">Input</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a5476b6d021bcbb48aa1623f3a8338b5d">in_</a></td></tr>
<tr class="memdesc:a5476b6d021bcbb48aa1623f3a8338b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">the input character sequence to scan  <a href="#a5476b6d021bcbb48aa1623f3a8338b5d">More...</a><br /></td></tr>
<tr class="separator:a5476b6d021bcbb48aa1623f3a8338b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25646f2503ea4a20f5b73bc7da28545e"><td class="memItemLeft" align="right" valign="top">std::ostream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a25646f2503ea4a20f5b73bc7da28545e">os_</a></td></tr>
<tr class="memdesc:a25646f2503ea4a20f5b73bc7da28545e"><td class="mdescLeft">&#160;</td><td class="mdescRight">the output stream to echo text matches to  <a href="#a25646f2503ea4a20f5b73bc7da28545e">More...</a><br /></td></tr>
<tr class="separator:a25646f2503ea4a20f5b73bc7da28545e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76c28c5d0ffec8e603f671b1317c404"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#ac76c28c5d0ffec8e603f671b1317c404">base_</a></td></tr>
<tr class="memdesc:ac76c28c5d0ffec8e603f671b1317c404"><td class="mdescLeft">&#160;</td><td class="mdescRight">the buffer to scan in place, if non-NULL  <a href="#ac76c28c5d0ffec8e603f671b1317c404">More...</a><br /></td></tr>
<tr class="separator:ac76c28c5d0ffec8e603f671b1317c404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d026a0d2f0aefa1177753707a17aa48"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a7d026a0d2f0aefa1177753707a17aa48">size_</a></td></tr>
<tr class="memdesc:a7d026a0d2f0aefa1177753707a17aa48"><td class="mdescLeft">&#160;</td><td class="mdescRight">the size of the buffer to scan in place, if nonzero  <a href="#a7d026a0d2f0aefa1177753707a17aa48">More...</a><br /></td></tr>
<tr class="separator:a7d026a0d2f0aefa1177753707a17aa48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31804738641329190e2ab79c0429d805"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a31804738641329190e2ab79c0429d805">matcher_</a></td></tr>
<tr class="memdesc:a31804738641329190e2ab79c0429d805"><td class="mdescLeft">&#160;</td><td class="mdescRight">the matcher used for scanning  <a href="#a31804738641329190e2ab79c0429d805">More...</a><br /></td></tr>
<tr class="separator:a31804738641329190e2ab79c0429d805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588470b3af8d9c64437ea48f21f9e5fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a588470b3af8d9c64437ea48f21f9e5fd">start_</a></td></tr>
<tr class="memdesc:a588470b3af8d9c64437ea48f21f9e5fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">the current start condition state  <a href="#a588470b3af8d9c64437ea48f21f9e5fd">More...</a><br /></td></tr>
<tr class="separator:a588470b3af8d9c64437ea48f21f9e5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278b6ed6fdf565b2ef4592ac7372660e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a278b6ed6fdf565b2ef4592ac7372660e">debug_</a></td></tr>
<tr class="memdesc:a278b6ed6fdf565b2ef4592ac7372660e"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if -d (&ndash;debug) 0 otherwise:  <a href="#a278b6ed6fdf565b2ef4592ac7372660e">More...</a><br /></td></tr>
<tr class="separator:a278b6ed6fdf565b2ef4592ac7372660e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0b0705752b17d78302e4dae7d2b643"><td class="memItemLeft" align="right" valign="top">std::stack&lt; <a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a5c0b0705752b17d78302e4dae7d2b643">stack_</a></td></tr>
<tr class="memdesc:a5c0b0705752b17d78302e4dae7d2b643"><td class="mdescLeft">&#160;</td><td class="mdescRight">a stack of pointers to matchers  <a href="#a5c0b0705752b17d78302e4dae7d2b643">More...</a><br /></td></tr>
<tr class="separator:a5c0b0705752b17d78302e4dae7d2b643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbffb98e8f214ace1a1c5a2c2b66243a"><td class="memItemLeft" align="right" valign="top">std::stack&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#acbffb98e8f214ace1a1c5a2c2b66243a">state_</a></td></tr>
<tr class="memdesc:acbffb98e8f214ace1a1c5a2c2b66243a"><td class="mdescLeft">&#160;</td><td class="mdescRight">a stack of start condition states  <a href="#acbffb98e8f214ace1a1c5a2c2b66243a">More...</a><br /></td></tr>
<tr class="separator:acbffb98e8f214ace1a1c5a2c2b66243a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename M&gt;<br />
class reflex::AbstractLexer&lt; M &gt;</h3>

<p>The abstract lexer class template that is the abstract root class of all reflex-generated scanners. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">&lt;M&gt;</td><td>matcher class derived from <a class="el" href="classreflex_1_1_abstract_matcher.html" title="The abstract matcher base class template defines an interface for all pattern matcher engines...">reflex::AbstractMatcher</a> </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a536b9af11d41ac2441dd8739c64901ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::<a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct abstract lexer to scan an input character sequence and echo the text matches to output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td><a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a> character sequence to read from </td></tr>
    <tr><td class="paramname">os</td><td>echo the text matches to this std::ostream or to std::cout </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad3dd2c00e0c5a5a478a02cacaf57bd96"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::~<a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete lexer and its current matcher with its associated input. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a862b4bd60ae3a2fb7a77825c5f759e41"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a>&amp; <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::buffer </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the matcher and start scanning the given buffer containing 0-terminated character data (data may be modified). </p>
<dl class="section return"><dt>Returns</dt><dd>reference to *this </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>base of the buffer containing 0-terminated character data </td></tr>
    <tr><td class="paramname">size</td><td>nonzero size of the buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa08720e165486e2db19cdcd99ee80fb1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::chr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first 8-bit character of the text matched. </p>
<dl class="section return"><dt>Returns</dt><dd>8-bit char </dd></dl>

</div>
</div>
<a class="anchor" id="a7991f7785e86d29c9f64d9991ce47f9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::columno </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the starting column number of matched text, taking tab spacing into account and counting wide characters as one character each. </p>
<dl class="section return"><dt>Returns</dt><dd>column number </dd></dl>

</div>
</div>
<a class="anchor" id="a834e21c4d177c26956dfe0d90beb677a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::columno_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the ending column number of matched text, taking tab spacing into account and counting wide characters as one character each. </p>
<dl class="section return"><dt>Returns</dt><dd>column number </dd></dl>

</div>
</div>
<a class="anchor" id="a8cdf0a400fd515dc2141b993a887cfbe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::columns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of columns of the last line (or the single line of matched text) in the matched text, taking tab spacing into account and counting wide characters as one character each. </p>
<dl class="section return"><dt>Returns</dt><dd>number of columns </dd></dl>

</div>
</div>
<a class="anchor" id="ac4bdc642fbcb9b37c124c44f11b335bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::debug </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get debug flag value. </p>
<dl class="section return"><dt>Returns</dt><dd>debug flag value </dd></dl>

</div>
</div>
<a class="anchor" id="a45d00ce513ed727dc4fdde304fcb8d97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::del_matcher </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a> *&#160;</td>
          <td class="paramname"><em>matcher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete a matcher. </p>

</div>
</div>
<a class="anchor" id="ad708880eff5601208180600758773a1f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::echo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Echo the matched text to the current output. </p>

</div>
</div>
<a class="anchor" id="abac54e52193bb1a175f82b35c9ddfecf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::has_matcher </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if a matcher was assigned to this lexer for scanning. </p>
<dl class="section return"><dt>Returns</dt><dd>true if a matcher was assigned </dd></dl>

</div>
</div>
<a class="anchor" id="a86e93c71d6cc835ad29e39d5663bd026"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<div class="memtemplate">
template&lt;typename I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a>&amp; <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::in </td>
          <td>(</td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the matcher and start scanning from the given input character sequence I. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to *this </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>a character sequence to scan, e.g. <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a>, char*, wchar_t*, std::string, std::wstring, FILE*, std::istream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a50727a74a6e9afe88ab7694047cadbe8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a>&amp; <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::in </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the matcher and start scanning from the given byte sequence. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to *this </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>the byte sequence to scan </td></tr>
    <tr><td class="paramname">n</td><td>length of the byte sequence to scan </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a90af4baa6d064decf87f54aeb95806d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_input.html">Input</a>&amp; <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::in </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current input character sequence that is being scanned. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to the current <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="a48da3dea969abc450e9f050600fd43d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::lexer_error </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>message</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lexer exceptions. </p>

</div>
</div>
<a class="anchor" id="aec39f17dabf8019919ab2b515a660e82"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::lineno </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the line number of matched text. </p>
<dl class="section return"><dt>Returns</dt><dd>line number </dd></dl>

</div>
</div>
<a class="anchor" id="a20c0351bb149281f0a0014ec271a349a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::lineno </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set or change the starting line number of the last match. </p>

</div>
</div>
<a class="anchor" id="a338a21634404913bd5f38efedf2a109a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::lineno_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the ending line number of matched text. </p>
<dl class="section return"><dt>Returns</dt><dd>line number </dd></dl>

</div>
</div>
<a class="anchor" id="a0f4cf455c03298f1ca49f118b412d111"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::lines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of lines that the match spans. </p>
<dl class="section return"><dt>Returns</dt><dd>number of lines </dd></dl>

</div>
</div>
<a class="anchor" id="a70ee52cef2c37c2ca47a686eea75a5db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a>&amp; <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::matcher </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a> *&#160;</td>
          <td class="paramname"><em>matcher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the matcher (and its current state) for scanning. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to *this </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matcher</td><td>points to a matcher object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa0be24643126521aeac9cc4cfcaf206a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a>&amp; <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::matcher </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the current matcher. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to the current matcher </dd></dl>

</div>
</div>
<a class="anchor" id="a91254a55027878842695841c8caffdb3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a>* <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::new_matcher </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em> = <code><a class="el" href="classreflex_1_1_input.html">Input</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>opt</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new copy of the matcher for the given input. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to new <a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html" title="Extend matcher class M with a member pointing to the instantiating lexer class. ">reflex::AbstractLexer::Matcher</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td><a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a> character sequence to match </td></tr>
    <tr><td class="paramname">opt</td><td>options, if any </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7da401412f85849c7b7e744ad4824731"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_input.html">Input</a>&amp; <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::nostdinit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current input character sequence that is being scanned, if none assign std::cin. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to the current <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a> object with input assigned </dd></dl>

</div>
</div>
<a class="anchor" id="a520efbcc7a4007bcbdb702b118e1b5ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream*&amp; <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::os </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to the current output stream used to echo text matches to. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the current std::ostream object </dd></dl>

</div>
</div>
<a class="anchor" id="a5611c94c961a216fc733244c9b688f8f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a>&amp; <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::out </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the current output to the given output stream to echo text matches to. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to *this </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>output stream to echo text matches to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5f4c3de6df3eb45dfd4c3ed86be405e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::out </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current output stream used to echo text matches to. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to the current std::ostream object </dd></dl>

</div>
</div>
<a class="anchor" id="aeedf0d263073b3447b26877c2ef03101"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::perf_report </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dummy performance reporter, to prevent link errors when reflex option -p is omitted. </p>

</div>
</div>
<a class="anchor" id="a83fed855c7271786b505f6a68fb475db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::pop_matcher </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop matcher from the stack and continue scanning where it left off, delete the current matcher. </p>

</div>
</div>
<a class="anchor" id="a2bc3e098fc89e5bdc1f6d44af0d85c8f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::pop_state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop the stack start condition state and transition to that state. </p>

</div>
</div>
<a class="anchor" id="a85d33059076b03430591e369b5ef96eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a>* <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::ptr_matcher </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the current matcher, NULL if none was set. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the current matcher or NULL if no matcher was set </dd></dl>

</div>
</div>
<a class="anchor" id="aa7da8596b9eeb820214e2630a331e43d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::push_matcher </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a> *&#160;</td>
          <td class="paramname"><em>matcher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push the current matcher on the stack and use the given matcher for scanning. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matcher</td><td>points to a matcher object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a996791039f153c27947dab23db026f41"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::push_state </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push the current start condition state on the stack and transition to the given start condition state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>start condition state to transition to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a070058e52c93918d41b1f37901f01b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::set_debug </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set debug flag value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>0 or 1 (false or true) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4adf95aef287ae60d22c7bbdf513570f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the matched text size in number of bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>size of the matched text </dd></dl>

</div>
</div>
<a class="anchor" id="a905c83f6978b3599c43167ae3c7f5b30"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a>&amp; <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::start </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transition to the given start condition state. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to *this </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>start condition state to transition to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac003645fb8e8d8ddb1c268af6ab3b258"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current start condition state. </p>
<dl class="section return"><dt>Returns</dt><dd>start condition (integer) </dd></dl>

</div>
</div>
<a class="anchor" id="a4ef7b75dfc67ee897a77e70ed7ca46d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::states_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the condition state stack is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the stack is empty, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="aa5b88719f4d035a4aefc2f67fd09f8d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_input.html">Input</a>&amp; <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::stdinit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current input character sequence that is being scanned, if none assign stdin. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to the current <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a> object with input assigned </dd></dl>

</div>
</div>
<a class="anchor" id="a25b43d3eabdf73eaf8106c33af71fb57"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns string with a copy of the text matched. </p>
<dl class="section return"><dt>Returns</dt><dd>matched text </dd></dl>

</div>
</div>
<a class="anchor" id="ac1696b73ebd927f1093985f866d73bf6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::text </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns string with the text matched. </p>
<dl class="section return"><dt>Returns</dt><dd>matched text </dd></dl>

</div>
</div>
<a class="anchor" id="ae5ccbfb254360056a679cef8702228f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::top_state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the stack top start condition state or 0 (INITIAL) if the stack is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>start condition (integer) </dd></dl>

</div>
</div>
<a class="anchor" id="a160da2c0f59e43836cacad171badd45f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::wchr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first wide character of the text matched. </p>
<dl class="section return"><dt>Returns</dt><dd>wide char (UTF-8 converted to <a class="el" href="namespacereflex_1_1_unicode.html">Unicode</a>) </dd></dl>

</div>
</div>
<a class="anchor" id="aeca2e0dcb03e92d26478145004d077b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::wrap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default wrap operation at EOF: do not wrap input. </p>
<dl class="section return"><dt>Returns</dt><dd>1 (override to return 0 to indicate that new input is available after this invocation so that wrap after EOF is OK) </dd></dl>

</div>
</div>
<a class="anchor" id="a57c209d1965c6917dace3631cbd4fc82"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::wsize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the matched text size in number of (wide) characters. </p>
<dl class="section return"><dt>Returns</dt><dd>number of (wide) characters matched </dd></dl>

</div>
</div>
<a class="anchor" id="a9cefad78219d2fe0b10e49a4f74204cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::wstr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns wide string with a copy of the text matched. </p>
<dl class="section return"><dt>Returns</dt><dd>matched text </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ac76c28c5d0ffec8e603f671b1317c404"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::base_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the buffer to scan in place, if non-NULL </p>

</div>
</div>
<a class="anchor" id="a278b6ed6fdf565b2ef4592ac7372660e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::debug_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>1 if -d (&ndash;debug) 0 otherwise: </p>

</div>
</div>
<a class="anchor" id="a5476b6d021bcbb48aa1623f3a8338b5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_input.html">Input</a> <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::in_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the input character sequence to scan </p>

</div>
</div>
<a class="anchor" id="a31804738641329190e2ab79c0429d805"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a>* <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::matcher_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the matcher used for scanning </p>

</div>
</div>
<a class="anchor" id="a25646f2503ea4a20f5b73bc7da28545e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream* <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::os_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the output stream to echo text matches to </p>

</div>
</div>
<a class="anchor" id="a7d026a0d2f0aefa1177753707a17aa48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::size_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the size of the buffer to scan in place, if nonzero </p>

</div>
</div>
<a class="anchor" id="a5c0b0705752b17d78302e4dae7d2b643"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::stack&lt;<a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a>*&gt; <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::stack_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a stack of pointers to matchers </p>

</div>
</div>
<a class="anchor" id="a588470b3af8d9c64437ea48f21f9e5fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::start_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the current start condition state </p>

</div>
</div>
<a class="anchor" id="acbffb98e8f214ace1a1c5a2c2b66243a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::stack&lt;int&gt; <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::state_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a stack of start condition states </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="abslexer_8h.html">abslexer.h</a></li>
</ul>
</div><!-- contents -->
<hr class="footer">
<address class="footer"><small>
Converted on Wed Jul 6 2022 10:30:14 by <a target="_blank" href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.11</small></address>
<br>
<div style="height: 246px; background: #DBDBDB;">
</body>
</html>
