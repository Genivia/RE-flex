<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta http-equiv="cache-control" content="no-cache">
<title>reflex::Ranges&lt; T &gt; Class Template Reference</title>
<link href="doxygen_tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="doxygen_content.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top">
 <div id="titlearea">
  <table height="72px" width="100%" cellspacing="0" cellpadding="0">
   <tbody>
    <tr>
     <td width="10%">&nbsp;</td>
     <td><a href="https://github.com/Genivia/RE-flex"><img src="reflex-logo.png"/></a></td>
     <td>
      <div style="float: right; font-size: 18px; font-weight: bold;">reflex::Ranges&lt; T &gt; Class Template Reference</div>
      <br>
      <div style="float: right; font-size: 10px;">updated Wed Jul 6 2022 by Robert van Engelen</div>
     </td>
     <td width="10%">&nbsp;</td>
    </tr>
   </tbody>
  </table>
 </div>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacereflex.html">reflex</a></li><li class="navelem"><a class="el" href="classreflex_1_1_ranges.html">Ranges</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classreflex_1_1_ranges-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">reflex::Ranges&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>RE/flex <a class="el" href="classreflex_1_1_ranges.html" title="RE/flex Ranges template class. ">Ranges</a> template class.  
 <a href="classreflex_1_1_ranges.html#details">More...</a></p>

<p><code>#include &lt;ranges.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for reflex::Ranges&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classreflex_1_1_ranges__inherit__graph.png" border="0" usemap="#reflex_1_1_ranges_3_01_t_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="reflex_1_1_ranges_3_01_t_01_4_inherit__map" id="reflex_1_1_ranges_3_01_t_01_4_inherit__map">
<area shape="rect" id="node3" href="classreflex_1_1_o_ranges.html" title="RE/flex ORanges (open&#45;ended, ordinal value range) template class. " alt="" coords="15,184,165,211"/>
<area shape="rect" id="node2" title="STL class. " alt="" coords="5,5,175,61"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for reflex::Ranges&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classreflex_1_1_ranges__coll__graph.png" border="0" usemap="#reflex_1_1_ranges_3_01_t_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="reflex_1_1_ranges_3_01_t_01_4_coll__map" id="reflex_1_1_ranges_3_01_t_01_4_coll__map">
<area shape="rect" id="node2" title="STL class. " alt="" coords="5,95,175,151"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5932a3dc82b3b47baa01c205b40eec64"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a></td></tr>
<tr class="memdesc:a5932a3dc82b3b47baa01c205b40eec64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the bounds.  <a href="#a5932a3dc82b3b47baa01c205b40eec64">More...</a><br /></td></tr>
<tr class="separator:a5932a3dc82b3b47baa01c205b40eec64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed84540bbb395b6f0bc21cb8ea169f1"><td class="memItemLeft" align="right" valign="top">typedef std::set&lt; std::pair&lt; T, T &gt;, <a class="el" href="structreflex_1_1range__compare.html">range_compare</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a7ed84540bbb395b6f0bc21cb8ea169f1">container_type</a></td></tr>
<tr class="memdesc:a7ed84540bbb395b6f0bc21cb8ea169f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym type defining the base class container std::set.  <a href="#a7ed84540bbb395b6f0bc21cb8ea169f1">More...</a><br /></td></tr>
<tr class="separator:a7ed84540bbb395b6f0bc21cb8ea169f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18640a7ac6891e626c78cbda4ab80abe"><td class="memItemLeft" align="right" valign="top">typedef container_type::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a18640a7ac6891e626c78cbda4ab80abe">value_type</a></td></tr>
<tr class="memdesc:a18640a7ac6891e626c78cbda4ab80abe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym type defining the base class container std::set::value_type.  <a href="#a18640a7ac6891e626c78cbda4ab80abe">More...</a><br /></td></tr>
<tr class="separator:a18640a7ac6891e626c78cbda4ab80abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188adab06dd0d3ed7813ff8d6ad1a121"><td class="memItemLeft" align="right" valign="top">typedef container_type::key_compare&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a188adab06dd0d3ed7813ff8d6ad1a121">key_compare</a></td></tr>
<tr class="memdesc:a188adab06dd0d3ed7813ff8d6ad1a121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym type defining the key/value comparison std::set::key_compare.  <a href="#a188adab06dd0d3ed7813ff8d6ad1a121">More...</a><br /></td></tr>
<tr class="separator:a188adab06dd0d3ed7813ff8d6ad1a121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f622467be2e7f9df83a2d0f791bfd90"><td class="memItemLeft" align="right" valign="top">typedef container_type::value_compare&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a8f622467be2e7f9df83a2d0f791bfd90">value_compare</a></td></tr>
<tr class="separator:a8f622467be2e7f9df83a2d0f791bfd90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f32a9642333820fd0b9b66af654cb6"><td class="memItemLeft" align="right" valign="top">typedef container_type::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#ac6f32a9642333820fd0b9b66af654cb6">iterator</a></td></tr>
<tr class="memdesc:ac6f32a9642333820fd0b9b66af654cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym type defining the base class container std::set::iterator.  <a href="#ac6f32a9642333820fd0b9b66af654cb6">More...</a><br /></td></tr>
<tr class="separator:ac6f32a9642333820fd0b9b66af654cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551bdfa41f5ba3dd5b91ddcb86b1acd2"><td class="memItemLeft" align="right" valign="top">typedef container_type::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a551bdfa41f5ba3dd5b91ddcb86b1acd2">const_iterator</a></td></tr>
<tr class="memdesc:a551bdfa41f5ba3dd5b91ddcb86b1acd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym type defining the base class container std::set::iterator.  <a href="#a551bdfa41f5ba3dd5b91ddcb86b1acd2">More...</a><br /></td></tr>
<tr class="separator:a551bdfa41f5ba3dd5b91ddcb86b1acd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a113a3eed86ce245a93626b1f5b84c5ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a113a3eed86ce245a93626b1f5b84c5ad">Ranges</a> ()</td></tr>
<tr class="memdesc:a113a3eed86ce245a93626b1f5b84c5ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty range.  <a href="#a113a3eed86ce245a93626b1f5b84c5ad">More...</a><br /></td></tr>
<tr class="separator:a113a3eed86ce245a93626b1f5b84c5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36353497e22513c992cc68d7057ed209"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a36353497e22513c992cc68d7057ed209">Ranges</a> (const <a class="el" href="classreflex_1_1_ranges.html#a18640a7ac6891e626c78cbda4ab80abe">value_type</a> &amp;r)</td></tr>
<tr class="memdesc:a36353497e22513c992cc68d7057ed209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a copy of a range [lo,hi].  <a href="#a36353497e22513c992cc68d7057ed209">More...</a><br /></td></tr>
<tr class="separator:a36353497e22513c992cc68d7057ed209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c27d82deac4a616b3c7f50dc11a66b4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a7c27d82deac4a616b3c7f50dc11a66b4">Ranges</a> (const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;<a class="el" href="classreflex_1_1_ranges.html#aeb29f8017cd8617ed78e8d185a9e2a74">lo</a>, const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;<a class="el" href="classreflex_1_1_ranges.html#a467a43c765cf87ed17c0b888f445c9fc">hi</a>)</td></tr>
<tr class="memdesc:a7c27d82deac4a616b3c7f50dc11a66b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a range [lo,hi].  <a href="#a7c27d82deac4a616b3c7f50dc11a66b4">More...</a><br /></td></tr>
<tr class="separator:a7c27d82deac4a616b3c7f50dc11a66b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab375bf376f87fb4f75d20e5af68166f1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#ab375bf376f87fb4f75d20e5af68166f1">Ranges</a> (const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;val)</td></tr>
<tr class="memdesc:ab375bf376f87fb4f75d20e5af68166f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a singleton range [val,val].  <a href="#ab375bf376f87fb4f75d20e5af68166f1">More...</a><br /></td></tr>
<tr class="separator:ab375bf376f87fb4f75d20e5af68166f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b80affbf56f12faafae17b0c64dc00"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classreflex_1_1_ranges.html#ac6f32a9642333820fd0b9b66af654cb6">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a45b80affbf56f12faafae17b0c64dc00">insert</a> (const <a class="el" href="classreflex_1_1_ranges.html#a18640a7ac6891e626c78cbda4ab80abe">value_type</a> &amp;r)</td></tr>
<tr class="memdesc:a45b80affbf56f12faafae17b0c64dc00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update ranges to include range [lo,hi] by merging overlapping ranges into one range.  <a href="#a45b80affbf56f12faafae17b0c64dc00">More...</a><br /></td></tr>
<tr class="separator:a45b80affbf56f12faafae17b0c64dc00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf55cde7658ed085e54f1c695cb9910"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classreflex_1_1_ranges.html#ac6f32a9642333820fd0b9b66af654cb6">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#acbf55cde7658ed085e54f1c695cb9910">insert</a> (const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;<a class="el" href="classreflex_1_1_ranges.html#aeb29f8017cd8617ed78e8d185a9e2a74">lo</a>, const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;<a class="el" href="classreflex_1_1_ranges.html#a467a43c765cf87ed17c0b888f445c9fc">hi</a>)</td></tr>
<tr class="memdesc:acbf55cde7658ed085e54f1c695cb9910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update ranges to include range [lo,hi] by merging overlapping ranges into one range.  <a href="#acbf55cde7658ed085e54f1c695cb9910">More...</a><br /></td></tr>
<tr class="separator:acbf55cde7658ed085e54f1c695cb9910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e9676740f9dee983de782774f077f0"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classreflex_1_1_ranges.html#ac6f32a9642333820fd0b9b66af654cb6">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#af0e9676740f9dee983de782774f077f0">insert</a> (const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;val)</td></tr>
<tr class="memdesc:af0e9676740f9dee983de782774f077f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update ranges to include the range [val,val].  <a href="#af0e9676740f9dee983de782774f077f0">More...</a><br /></td></tr>
<tr class="separator:af0e9676740f9dee983de782774f077f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7148421186fc5d33f4eb109609e1c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_ranges.html#a551bdfa41f5ba3dd5b91ddcb86b1acd2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a2a7148421186fc5d33f4eb109609e1c4">find</a> (const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;<a class="el" href="classreflex_1_1_ranges.html#aeb29f8017cd8617ed78e8d185a9e2a74">lo</a>, const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;<a class="el" href="classreflex_1_1_ranges.html#a467a43c765cf87ed17c0b888f445c9fc">hi</a>) const </td></tr>
<tr class="memdesc:a2a7148421186fc5d33f4eb109609e1c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first range [lo',hi'] that overlaps the given range [lo,hi], i.e. lo &lt;= hi' and lo' &lt;= hi.  <a href="#a2a7148421186fc5d33f4eb109609e1c4">More...</a><br /></td></tr>
<tr class="separator:a2a7148421186fc5d33f4eb109609e1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e426ff9650fddac27e0433db0811bc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_ranges.html#a551bdfa41f5ba3dd5b91ddcb86b1acd2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a0e426ff9650fddac27e0433db0811bc9">find</a> (const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;val) const </td></tr>
<tr class="memdesc:a0e426ff9650fddac27e0433db0811bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the range [lo',hi'] that includes the given value val, i.e. lo' &lt;= val &lt;= hi'.  <a href="#a0e426ff9650fddac27e0433db0811bc9">More...</a><br /></td></tr>
<tr class="separator:a0e426ff9650fddac27e0433db0811bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86ade66b0f5c3003dbc11e1d4e2d738"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#ad86ade66b0f5c3003dbc11e1d4e2d738">operator|=</a> (const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;rs)</td></tr>
<tr class="memdesc:ad86ade66b0f5c3003dbc11e1d4e2d738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update ranges to insert the given range set, where this method has lower complexity than iterating <a class="el" href="classreflex_1_1_ranges.html#a45b80affbf56f12faafae17b0c64dc00" title="Update ranges to include range [lo,hi] by merging overlapping ranges into one range. ">insert()</a> for each range in rs.  <a href="#ad86ade66b0f5c3003dbc11e1d4e2d738">More...</a><br /></td></tr>
<tr class="separator:ad86ade66b0f5c3003dbc11e1d4e2d738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0aa356a5eec364aad70a795aeab68f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#ab0aa356a5eec364aad70a795aeab68f5">operator+=</a> (const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;rs)</td></tr>
<tr class="memdesc:ab0aa356a5eec364aad70a795aeab68f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update ranges to insert the ranges of the given range set, same as Ranges::operator|=(rs).  <a href="#ab0aa356a5eec364aad70a795aeab68f5">More...</a><br /></td></tr>
<tr class="separator:ab0aa356a5eec364aad70a795aeab68f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2feb520bce89afdf80f7d06d8c3bcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a3d2feb520bce89afdf80f7d06d8c3bcd">operator&amp;=</a> (const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;rs)</td></tr>
<tr class="memdesc:a3d2feb520bce89afdf80f7d06d8c3bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update ranges to intersect the ranges with the given range set.  <a href="#a3d2feb520bce89afdf80f7d06d8c3bcd">More...</a><br /></td></tr>
<tr class="separator:a3d2feb520bce89afdf80f7d06d8c3bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658a2b69b4e435ecf079e0e5cc98c880"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_ranges.html">Ranges</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a658a2b69b4e435ecf079e0e5cc98c880">operator|</a> (const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;rs) const </td></tr>
<tr class="memdesc:a658a2b69b4e435ecf079e0e5cc98c880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the union of two range sets.  <a href="#a658a2b69b4e435ecf079e0e5cc98c880">More...</a><br /></td></tr>
<tr class="separator:a658a2b69b4e435ecf079e0e5cc98c880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14efc99f9c25db9e9b4ef0dbb72e3801"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_ranges.html">Ranges</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a14efc99f9c25db9e9b4ef0dbb72e3801">operator+</a> (const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;rs) const </td></tr>
<tr class="memdesc:a14efc99f9c25db9e9b4ef0dbb72e3801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the union of two range sets, same as Ranges::operator|(rs).  <a href="#a14efc99f9c25db9e9b4ef0dbb72e3801">More...</a><br /></td></tr>
<tr class="separator:a14efc99f9c25db9e9b4ef0dbb72e3801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc03786da54f6077febdea2f83110e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_ranges.html">Ranges</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a2bc03786da54f6077febdea2f83110e2">operator&amp;</a> (const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;rs) const </td></tr>
<tr class="memdesc:a2bc03786da54f6077febdea2f83110e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the intersection of two range sets.  <a href="#a2bc03786da54f6077febdea2f83110e2">More...</a><br /></td></tr>
<tr class="separator:a2bc03786da54f6077febdea2f83110e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412f3f7392b76411ed5f1e02ecdebd0c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a412f3f7392b76411ed5f1e02ecdebd0c">operator&lt;</a> (const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;rs) const </td></tr>
<tr class="memdesc:a412f3f7392b76411ed5f1e02ecdebd0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this range set is lexicographically less than range set rs.  <a href="#a412f3f7392b76411ed5f1e02ecdebd0c">More...</a><br /></td></tr>
<tr class="separator:a412f3f7392b76411ed5f1e02ecdebd0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be1924a5c28eff510256c8345f65241"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a2be1924a5c28eff510256c8345f65241">operator&gt;</a> (const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;rs) const </td></tr>
<tr class="memdesc:a2be1924a5c28eff510256c8345f65241"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this range set is lexicographically greater than range set rs.  <a href="#a2be1924a5c28eff510256c8345f65241">More...</a><br /></td></tr>
<tr class="separator:a2be1924a5c28eff510256c8345f65241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21dec3fa4c006ba98e5888b724e7178e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a21dec3fa4c006ba98e5888b724e7178e">operator&lt;=</a> (const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;rs) const </td></tr>
<tr class="memdesc:a21dec3fa4c006ba98e5888b724e7178e"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this range set is lexicographically less or equal to range set rs.  <a href="#a21dec3fa4c006ba98e5888b724e7178e">More...</a><br /></td></tr>
<tr class="separator:a21dec3fa4c006ba98e5888b724e7178e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef3e519c643b66d0ab50f77f1780236"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a3ef3e519c643b66d0ab50f77f1780236">operator&gt;=</a> (const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;rs) const </td></tr>
<tr class="memdesc:a3ef3e519c643b66d0ab50f77f1780236"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this range set is lexicographically greater or equal to range set rs.  <a href="#a3ef3e519c643b66d0ab50f77f1780236">More...</a><br /></td></tr>
<tr class="separator:a3ef3e519c643b66d0ab50f77f1780236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef3e69adbf8dab9c4123a77c873eca1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a6ef3e69adbf8dab9c4123a77c873eca1">any</a> () const </td></tr>
<tr class="memdesc:a6ef3e69adbf8dab9c4123a77c873eca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this set of ranges contains at least one range, i.e. is not empty.  <a href="#a6ef3e69adbf8dab9c4123a77c873eca1">More...</a><br /></td></tr>
<tr class="separator:a6ef3e69adbf8dab9c4123a77c873eca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff9a255f63c79bc945cbcde112bd79a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a8ff9a255f63c79bc945cbcde112bd79a">intersects</a> (const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;rs) const </td></tr>
<tr class="memdesc:a8ff9a255f63c79bc945cbcde112bd79a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this set of ranges intersects with ranges rs, i.e. this set has at least one range [lo',hi'] that overlaps with a range [lo,hi] in rs such that lo &lt;= hi' and lo' &lt;= hi.  <a href="#a8ff9a255f63c79bc945cbcde112bd79a">More...</a><br /></td></tr>
<tr class="separator:a8ff9a255f63c79bc945cbcde112bd79a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e84aa26790720fa68ac1882839db0c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#af1e84aa26790720fa68ac1882839db0c">contains</a> (const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a> &amp;rs) const </td></tr>
<tr class="memdesc:af1e84aa26790720fa68ac1882839db0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this set of ranges contains all ranges in rs, i.e. rs is a subset of this set which means that for each range [lo,hi] in rs, there is a range [lo',hi'] such that lo' &lt;= lo and hi &lt;= hi'.  <a href="#af1e84aa26790720fa68ac1882839db0c">More...</a><br /></td></tr>
<tr class="separator:af1e84aa26790720fa68ac1882839db0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb29f8017cd8617ed78e8d185a9e2a74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#aeb29f8017cd8617ed78e8d185a9e2a74">lo</a> () const </td></tr>
<tr class="memdesc:aeb29f8017cd8617ed78e8d185a9e2a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lowest value in the set of ranges (the set cannot be empty)  <a href="#aeb29f8017cd8617ed78e8d185a9e2a74">More...</a><br /></td></tr>
<tr class="separator:aeb29f8017cd8617ed78e8d185a9e2a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467a43c765cf87ed17c0b888f445c9fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_ranges.html#a467a43c765cf87ed17c0b888f445c9fc">hi</a> () const </td></tr>
<tr class="memdesc:a467a43c765cf87ed17c0b888f445c9fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the highest value in the set of ranges (the set cannot be empty)  <a href="#a467a43c765cf87ed17c0b888f445c9fc">More...</a><br /></td></tr>
<tr class="separator:a467a43c765cf87ed17c0b888f445c9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class reflex::Ranges&lt; T &gt;</h3>

<p>RE/flex <a class="el" href="classreflex_1_1_ranges.html" title="RE/flex Ranges template class. ">Ranges</a> template class. </p>
<p>The <code>std::set</code> container is the base class of this <a class="el" href="classreflex_1_1_ranges.html" title="RE/flex Ranges template class. ">Ranges</a> class. Value ranges [lo,hi] are stored in the underlying <code>std::set</code> container as a pair of bounds <code>std::pair(lo, hi)</code>.</p>
<p><a class="el" href="classreflex_1_1_ranges.html" title="RE/flex Ranges template class. ">Ranges</a> in the set are mutually disjoint (i.e. non-overlapping). This property is maintained by the <code><a class="el" href="classreflex_1_1_ranges.html" title="RE/flex Ranges template class. ">reflex::Ranges</a></code> methods.</p>
<p>The <code><a class="el" href="classreflex_1_1_ranges.html#a18640a7ac6891e626c78cbda4ab80abe" title="Synonym type defining the base class container std::set::value_type. ">Ranges::value_type</a></code> is <code>std::pair&lt;bound_type,bound_type&gt;</code> with <code><a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64" title="Type of the bounds. ">Ranges::bound_type</a></code> the template parameter type <code>T</code>.</p>
<p>The <code>reflexx::Ranges</code> class introduces several new methods in addition to the inherited <code>std::set</code> methods:</p>
<ul>
<li><code>std::pair&lt;iterator,bool&gt; <a class="el" href="classreflex_1_1_ranges.html#acbf55cde7658ed085e54f1c695cb9910" title="Update ranges to include range [lo,hi] by merging overlapping ranges into one range. ">insert(const bound_type&amp; lo, const bound_type&amp; hi)</a></code> updates ranges to include the range [lo,hi]. Returns an iterator to the range that contains [lo,hi] and a flag indicating that ranges was updated (true) or if the new range was subsumed by current ranges (false).</li>
<li><code>std::pair&lt;iterator,bool&gt; <a class="el" href="classreflex_1_1_ranges.html#af0e9676740f9dee983de782774f077f0" title="Update ranges to include the range [val,val]. ">insert(const bound_type&amp; val)</a></code> updates ranges to include the value [val,val]. Returns an iterator to the range that contains val and a flag indicating that ranges was updated (true) or if the new range was subsumed by current ranges (false).</li>
<li><code>const_iterator <a class="el" href="classreflex_1_1_ranges.html#a2a7148421186fc5d33f4eb109609e1c4" title="Find the first range [lo&#39;,hi&#39;] that overlaps the given range [lo,hi], i.e. lo &lt;= hi&#39; and lo&#39; &lt;= hi...">find(const bound_type&amp; lo, const bound_type&amp; hi) const</a></code> searches for the first range that overlaps with [lo,hi]. Returns an iterator to the range found or the end iterator.</li>
<li><code>const_iterator <a class="el" href="classreflex_1_1_ranges.html#a0e426ff9650fddac27e0433db0811bc9" title="Find the range [lo&#39;,hi&#39;] that includes the given value val, i.e. lo&#39; &lt;= val &lt;= hi&#39;. ">find(const bound_type&amp; val) const</a></code> searches for the range that includes the given value. Returns an iterator to the range found or the end iterator.</li>
<li><code><a class="el" href="classreflex_1_1_ranges.html" title="RE/flex Ranges template class. ">Ranges</a>&amp; <a class="el" href="classreflex_1_1_ranges.html#ad86ade66b0f5c3003dbc11e1d4e2d738" title="Update ranges to insert the given range set, where this method has lower complexity than iterating in...">operator|=(const Ranges&amp; rs)</a></code> inserts ranges rs. Returns reference to this object.</li>
<li><code><a class="el" href="classreflex_1_1_ranges.html" title="RE/flex Ranges template class. ">Ranges</a>&amp; <a class="el" href="classreflex_1_1_ranges.html#ab0aa356a5eec364aad70a795aeab68f5" title="Update ranges to insert the ranges of the given range set, same as Ranges::operator|=(rs). ">operator+=(const Ranges&amp; rs)</a></code> same as above.</li>
<li><code><a class="el" href="classreflex_1_1_ranges.html" title="RE/flex Ranges template class. ">Ranges</a>&amp; <a class="el" href="classreflex_1_1_ranges.html#a3d2feb520bce89afdf80f7d06d8c3bcd" title="Update ranges to intersect the ranges with the given range set. ">operator&amp;=(const Ranges&amp; rs)</a></code> update ranges to intersect with ranges rs. Returns reference to this object.</li>
<li><code><a class="el" href="classreflex_1_1_ranges.html" title="RE/flex Ranges template class. ">Ranges</a> <a class="el" href="classreflex_1_1_ranges.html#a658a2b69b4e435ecf079e0e5cc98c880" title="Returns the union of two range sets. ">operator|(const Ranges&amp; rs) const</a></code> returns union of ranges.</li>
<li><code><a class="el" href="classreflex_1_1_ranges.html" title="RE/flex Ranges template class. ">Ranges</a> <a class="el" href="classreflex_1_1_ranges.html#a14efc99f9c25db9e9b4ef0dbb72e3801" title="Returns the union of two range sets, same as Ranges::operator|(rs). ">operator+(const Ranges&amp; rs) const</a></code> same as above.</li>
<li><code><a class="el" href="classreflex_1_1_ranges.html" title="RE/flex Ranges template class. ">Ranges</a> <a class="el" href="classreflex_1_1_ranges.html#a2bc03786da54f6077febdea2f83110e2" title="Returns the intersection of two range sets. ">operator&amp;(const Ranges&amp; rs) const</a></code> returns intersection of ranges.</li>
<li><code>bool <a class="el" href="classreflex_1_1_ranges.html#a6ef3e69adbf8dab9c4123a77c873eca1" title="Return true if this set of ranges contains at least one range, i.e. is not empty. ...">any() const</a></code> returns true if this set of ranges contains at least one range, i.e. is not empty.</li>
<li><code>bool <a class="el" href="classreflex_1_1_ranges.html#a8ff9a255f63c79bc945cbcde112bd79a" title="Return true if this set of ranges intersects with ranges rs, i.e. this set has at least one range [lo...">intersects(const Ranges&amp; rs) const</a></code> returns true if this set of ranges intersects ranges rs, i.e. has at least one range that overlaps with ranges rs.</li>
<li><code>bool <a class="el" href="classreflex_1_1_ranges.html#af1e84aa26790720fa68ac1882839db0c" title="Return true if this set of ranges contains all ranges in rs, i.e. rs is a subset of this set which me...">contains(const Ranges&amp; rs) const</a></code> returns true if this set of ranges contains all ranges rs, i.e. ranges rs is a subset.</li>
<li><code>bound_type <a class="el" href="classreflex_1_1_ranges.html#aeb29f8017cd8617ed78e8d185a9e2a74" title="Return the lowest value in the set of ranges (the set cannot be empty) ">lo()</a></code> returns the lowest value in the set of ranges.</li>
<li><code>bound_type <a class="el" href="classreflex_1_1_ranges.html#a467a43c765cf87ed17c0b888f445c9fc" title="Return the highest value in the set of ranges (the set cannot be empty) ">hi()</a></code> returns the highest value in the set of ranges.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>Using <code>std::set::insert()</code> instead of <code><a class="el" href="classreflex_1_1_ranges.html#a45b80affbf56f12faafae17b0c64dc00" title="Update ranges to include range [lo,hi] by merging overlapping ranges into one range. ">Ranges::insert()</a></code> may result in overlapping ranges rather than merging ranges to produce disjoint non-overlapping ranges.</dd></dl>
<p>Example:</p>
<div class="fragment"><div class="line"><a class="code" href="classreflex_1_1_ranges.html">reflex::Ranges&lt;float&gt;</a> intervals;</div><div class="line">intervals.<a class="code" href="classreflex_1_1_ranges.html#a45b80affbf56f12faafae17b0c64dc00">insert</a>(1.0, 2.0);  <span class="comment">// insert  1.0..2.0</span></div><div class="line">intervals.<a class="code" href="classreflex_1_1_ranges.html#a45b80affbf56f12faafae17b0c64dc00">insert</a>(2.0, 3.0);  <span class="comment">// insert  2.0..3.0</span></div><div class="line">intervals.<a class="code" href="classreflex_1_1_ranges.html#a45b80affbf56f12faafae17b0c64dc00">insert</a>(-1.0, 0.0); <span class="comment">// insert -1.0..0.0</span></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Set of &quot;</span> &lt;&lt; intervals.size() &lt;&lt; <span class="stringliteral">&quot; intervals:&quot;</span> &lt;&lt; std::endl;</div><div class="line"><span class="keywordflow">for</span> (<a class="code" href="classreflex_1_1_ranges.html#a551bdfa41f5ba3dd5b91ddcb86b1acd2">reflex::Ranges&lt;float&gt;::const_iterator</a> i = intervals.begin(); i != intervals.end(); ++i)</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; i-&gt;first &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; i-&gt;second &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; std::endl;</div><div class="line">if (intervals.<a class="code" href="classreflex_1_1_ranges.html#a2a7148421186fc5d33f4eb109609e1c4">find</a>(2.5) != intervals.end())</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;2.5 is in intervals&quot;</span> &lt;&lt; std::endl;</div><div class="line"><span class="keywordflow">for</span> (<a class="code" href="classreflex_1_1_ranges.html#a551bdfa41f5ba3dd5b91ddcb86b1acd2">reflex::Ranges&lt;float&gt;::const_iterator</a> i = intervals.<a class="code" href="classreflex_1_1_ranges.html#a2a7148421186fc5d33f4eb109609e1c4">find</a>(0.0, 1.0); i != intervals.end() &amp;&amp; i-&gt;first &lt;= 1.0; ++i)</div><div class="line">  std::cout &lt;&lt;  <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; i-&gt;first &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; i-&gt;second &lt;&lt; <span class="stringliteral">&quot;] overlaps with [0.0,1.0]&quot;</span> &lt;&lt; std::endl;</div><div class="line">if (intervals.<a class="code" href="classreflex_1_1_ranges.html#a8ff9a255f63c79bc945cbcde112bd79a">intersects</a>(<a class="code" href="classreflex_1_1_ranges.html">reflex::Ranges&lt;float&gt;</a>(2.5, 10.0)))</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;intersects [2.5,10.0]&quot;</span> &lt;&lt; std::endl;</div><div class="line"><span class="keywordflow">if</span> (intervals.<a class="code" href="classreflex_1_1_ranges.html#af1e84aa26790720fa68ac1882839db0c">contains</a>(<a class="code" href="classreflex_1_1_ranges.html">reflex::Ranges&lt;float&gt;</a>(1.0, 2.5)))</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;contains [1.0,2.5]&quot;</span> &lt;&lt; std::endl;</div></div><!-- fragment --><p>Output: </p><pre class="fragment">Set of 2 intervals:
[-1,0]
[1,3]
2.5 is in intervals
[-1,0] overlaps with [0.0,1.0]
[1,3] overlaps with [0.0,1.0]
intersects [2.5,10.0]
contains [1.0,2.5]</pre> </div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a5932a3dc82b3b47baa01c205b40eec64"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classreflex_1_1_ranges.html">reflex::Ranges</a>&lt; T &gt;::<a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the bounds. </p>

</div>
</div>
<a class="anchor" id="a551bdfa41f5ba3dd5b91ddcb86b1acd2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef container_type::const_iterator <a class="el" href="classreflex_1_1_ranges.html">reflex::Ranges</a>&lt; T &gt;::<a class="el" href="classreflex_1_1_ranges.html#a551bdfa41f5ba3dd5b91ddcb86b1acd2">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym type defining the base class container std::set::iterator. </p>

</div>
</div>
<a class="anchor" id="a7ed84540bbb395b6f0bc21cb8ea169f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::set&lt; std::pair&lt;T,T&gt;,<a class="el" href="structreflex_1_1range__compare.html">range_compare</a>&lt;T&gt; &gt; <a class="el" href="classreflex_1_1_ranges.html">reflex::Ranges</a>&lt; T &gt;::<a class="el" href="classreflex_1_1_ranges.html#a7ed84540bbb395b6f0bc21cb8ea169f1">container_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym type defining the base class container std::set. </p>

</div>
</div>
<a class="anchor" id="ac6f32a9642333820fd0b9b66af654cb6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef container_type::iterator <a class="el" href="classreflex_1_1_ranges.html">reflex::Ranges</a>&lt; T &gt;::<a class="el" href="classreflex_1_1_ranges.html#ac6f32a9642333820fd0b9b66af654cb6">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym type defining the base class container std::set::iterator. </p>

</div>
</div>
<a class="anchor" id="a188adab06dd0d3ed7813ff8d6ad1a121"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef container_type::key_compare <a class="el" href="classreflex_1_1_ranges.html">reflex::Ranges</a>&lt; T &gt;::<a class="el" href="classreflex_1_1_ranges.html#a188adab06dd0d3ed7813ff8d6ad1a121">key_compare</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym type defining the key/value comparison std::set::key_compare. </p>

</div>
</div>
<a class="anchor" id="a8f622467be2e7f9df83a2d0f791bfd90"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef container_type::value_compare <a class="el" href="classreflex_1_1_ranges.html">reflex::Ranges</a>&lt; T &gt;::<a class="el" href="classreflex_1_1_ranges.html#a8f622467be2e7f9df83a2d0f791bfd90">value_compare</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a18640a7ac6891e626c78cbda4ab80abe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef container_type::value_type <a class="el" href="classreflex_1_1_ranges.html">reflex::Ranges</a>&lt; T &gt;::<a class="el" href="classreflex_1_1_ranges.html#a18640a7ac6891e626c78cbda4ab80abe">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym type defining the base class container std::set::value_type. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a113a3eed86ce245a93626b1f5b84c5ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_ranges.html">reflex::Ranges</a>&lt; T &gt;::<a class="el" href="classreflex_1_1_ranges.html">Ranges</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an empty range. </p>

</div>
</div>
<a class="anchor" id="a36353497e22513c992cc68d7057ed209"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_ranges.html">reflex::Ranges</a>&lt; T &gt;::<a class="el" href="classreflex_1_1_ranges.html">Ranges</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html#a18640a7ac6891e626c78cbda4ab80abe">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a copy of a range [lo,hi]. </p>

</div>
</div>
<a class="anchor" id="a7c27d82deac4a616b3c7f50dc11a66b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_ranges.html">reflex::Ranges</a>&lt; T &gt;::<a class="el" href="classreflex_1_1_ranges.html">Ranges</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;&#160;</td>
          <td class="paramname"><em>hi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a range [lo,hi]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>lower bound </td></tr>
    <tr><td class="paramname">hi</td><td>upper bound </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab375bf376f87fb4f75d20e5af68166f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_ranges.html">reflex::Ranges</a>&lt; T &gt;::<a class="el" href="classreflex_1_1_ranges.html">Ranges</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a singleton range [val,val]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a6ef3e69adbf8dab9c4123a77c873eca1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classreflex_1_1_ranges.html">reflex::Ranges</a>&lt; T &gt;::any </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this set of ranges contains at least one range, i.e. is not empty. </p>
<dl class="section return"><dt>Returns</dt><dd>true if non empty, false if empty. </dd></dl>

</div>
</div>
<a class="anchor" id="af1e84aa26790720fa68ac1882839db0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classreflex_1_1_ranges.html">reflex::Ranges</a>&lt; T &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this set of ranges contains all ranges in rs, i.e. rs is a subset of this set which means that for each range [lo,hi] in rs, there is a range [lo',hi'] such that lo' &lt;= lo and hi &lt;= hi'. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this set contains rs. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rs</td><td>ranges </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a7148421186fc5d33f4eb109609e1c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_ranges.html#a551bdfa41f5ba3dd5b91ddcb86b1acd2">const_iterator</a> <a class="el" href="classreflex_1_1_ranges.html">reflex::Ranges</a>&lt; T &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;&#160;</td>
          <td class="paramname"><em>hi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first range [lo',hi'] that overlaps the given range [lo,hi], i.e. lo &lt;= hi' and lo' &lt;= hi. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the first range that overlaps the given range, or the end iterator. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>lower bound </td></tr>
    <tr><td class="paramname">hi</td><td>upper bound </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0e426ff9650fddac27e0433db0811bc9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_ranges.html#a551bdfa41f5ba3dd5b91ddcb86b1acd2">const_iterator</a> <a class="el" href="classreflex_1_1_ranges.html">reflex::Ranges</a>&lt; T &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the range [lo',hi'] that includes the given value val, i.e. lo' &lt;= val &lt;= hi'. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the range that includes the value, or the end iterator. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>value to search for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a467a43c765cf87ed17c0b888f445c9fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> <a class="el" href="classreflex_1_1_ranges.html">reflex::Ranges</a>&lt; T &gt;::hi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the highest value in the set of ranges (the set cannot be empty) </p>
<dl class="section return"><dt>Returns</dt><dd>highest value </dd></dl>

</div>
</div>
<a class="anchor" id="a45b80affbf56f12faafae17b0c64dc00"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classreflex_1_1_ranges.html#ac6f32a9642333820fd0b9b66af654cb6">iterator</a>,bool&gt; <a class="el" href="classreflex_1_1_ranges.html">reflex::Ranges</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html#a18640a7ac6891e626c78cbda4ab80abe">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update ranges to include range [lo,hi] by merging overlapping ranges into one range. </p>
<dl class="section return"><dt>Returns</dt><dd>a pair of an iterator to the range and a flag indicating whether the range was inserted as new. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acbf55cde7658ed085e54f1c695cb9910"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classreflex_1_1_ranges.html#ac6f32a9642333820fd0b9b66af654cb6">iterator</a>,bool&gt; <a class="el" href="classreflex_1_1_ranges.html">reflex::Ranges</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;&#160;</td>
          <td class="paramname"><em>hi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update ranges to include range [lo,hi] by merging overlapping ranges into one range. </p>
<dl class="section return"><dt>Returns</dt><dd>a pair of an iterator to the range and a flag indicating whether the range was inserted as new. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>lower bound </td></tr>
    <tr><td class="paramname">hi</td><td>upper bound </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af0e9676740f9dee983de782774f077f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classreflex_1_1_ranges.html#ac6f32a9642333820fd0b9b66af654cb6">iterator</a>,bool&gt; <a class="el" href="classreflex_1_1_ranges.html">reflex::Ranges</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update ranges to include the range [val,val]. </p>
<dl class="section return"><dt>Returns</dt><dd>a pair of an iterator to the range and a flag indicating whether the range was inserted as new. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>value to insert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8ff9a255f63c79bc945cbcde112bd79a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classreflex_1_1_ranges.html">reflex::Ranges</a>&lt; T &gt;::intersects </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this set of ranges intersects with ranges rs, i.e. this set has at least one range [lo',hi'] that overlaps with a range [lo,hi] in rs such that lo &lt;= hi' and lo' &lt;= hi. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this set intersects rs. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rs</td><td>ranges </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb29f8017cd8617ed78e8d185a9e2a74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_ranges.html#a5932a3dc82b3b47baa01c205b40eec64">bound_type</a> <a class="el" href="classreflex_1_1_ranges.html">reflex::Ranges</a>&lt; T &gt;::lo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the lowest value in the set of ranges (the set cannot be empty) </p>
<dl class="section return"><dt>Returns</dt><dd>lowest value </dd></dl>

</div>
</div>
<a class="anchor" id="a2bc03786da54f6077febdea2f83110e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_ranges.html">Ranges</a> <a class="el" href="classreflex_1_1_ranges.html">reflex::Ranges</a>&lt; T &gt;::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the intersection of two range sets. </p>
<dl class="section return"><dt>Returns</dt><dd>the intersection of this range set and rs. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rs</td><td>range set to intersect </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3d2feb520bce89afdf80f7d06d8c3bcd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_ranges.html">Ranges</a>&amp; <a class="el" href="classreflex_1_1_ranges.html">reflex::Ranges</a>&lt; T &gt;::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update ranges to intersect the ranges with the given range set. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to this object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rs</td><td>ranges to intersect </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a14efc99f9c25db9e9b4ef0dbb72e3801"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_ranges.html">Ranges</a> <a class="el" href="classreflex_1_1_ranges.html">reflex::Ranges</a>&lt; T &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the union of two range sets, same as Ranges::operator|(rs). </p>
<dl class="section return"><dt>Returns</dt><dd>the union of this set and rs. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rs</td><td>ranges to merge </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab0aa356a5eec364aad70a795aeab68f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_ranges.html">Ranges</a>&amp; <a class="el" href="classreflex_1_1_ranges.html">reflex::Ranges</a>&lt; T &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update ranges to insert the ranges of the given range set, same as Ranges::operator|=(rs). </p>
<dl class="section return"><dt>Returns</dt><dd>reference to this object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rs</td><td>ranges to insert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a412f3f7392b76411ed5f1e02ecdebd0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classreflex_1_1_ranges.html">reflex::Ranges</a>&lt; T &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if this range set is lexicographically less than range set rs. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this range set is less than rs. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rs</td><td>ranges </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a21dec3fa4c006ba98e5888b724e7178e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classreflex_1_1_ranges.html">reflex::Ranges</a>&lt; T &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if this range set is lexicographically less or equal to range set rs. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this rnage set is less or equal to rs. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rs</td><td>ranges </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2be1924a5c28eff510256c8345f65241"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classreflex_1_1_ranges.html">reflex::Ranges</a>&lt; T &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if this range set is lexicographically greater than range set rs. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this range set is greater than rs. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rs</td><td>ranges </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3ef3e519c643b66d0ab50f77f1780236"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classreflex_1_1_ranges.html">reflex::Ranges</a>&lt; T &gt;::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if this range set is lexicographically greater or equal to range set rs. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this is greater or equal to rs. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rs</td><td>ranges </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a658a2b69b4e435ecf079e0e5cc98c880"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_ranges.html">Ranges</a> <a class="el" href="classreflex_1_1_ranges.html">reflex::Ranges</a>&lt; T &gt;::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the union of two range sets. </p>
<dl class="section return"><dt>Returns</dt><dd>the union of this set and rs. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rs</td><td>ranges to merge </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad86ade66b0f5c3003dbc11e1d4e2d738"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_ranges.html">Ranges</a>&amp; <a class="el" href="classreflex_1_1_ranges.html">reflex::Ranges</a>&lt; T &gt;::operator|= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_ranges.html">Ranges</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update ranges to insert the given range set, where this method has lower complexity than iterating <a class="el" href="classreflex_1_1_ranges.html#a45b80affbf56f12faafae17b0c64dc00" title="Update ranges to include range [lo,hi] by merging overlapping ranges into one range. ">insert()</a> for each range in rs. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to this object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rs</td><td>ranges to insert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="ranges_8h.html">ranges.h</a></li>
</ul>
</div><!-- contents -->
<hr class="footer">
<address class="footer"><small>
Converted on Wed Jul 6 2022 10:30:15 by <a target="_blank" href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.11</small></address>
<br>
<div style="height: 246px; background: #DBDBDB;">
</body>
</html>
