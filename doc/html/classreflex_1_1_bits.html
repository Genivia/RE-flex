<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta http-equiv="cache-control" content="no-cache">
<title>reflex::Bits Class Reference</title>
<link href="doxygen_tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="doxygen_content.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top">
 <div id="titlearea">
  <table height="72px" width="100%" cellspacing="0" cellpadding="0">
   <tbody>
    <tr>
     <td width="10%">&nbsp;</td>
     <td><a href="https://github.com/Genivia/RE-flex"><img src="reflex-logo.png"/></a></td>
     <td>
      <div style="float: right; font-size: 18px; font-weight: bold;">reflex::Bits Class Reference</div>
      <br>
      <div style="float: right; font-size: 10px;">updated Fri Jan 24 2025 by Robert van Engelen</div>
     </td>
     <td width="10%">&nbsp;</td>
    </tr>
   </tbody>
  </table>
 </div>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacereflex.html">reflex</a></li><li class="navelem"><a class="el" href="classreflex_1_1_bits.html">Bits</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classreflex_1_1_bits-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">reflex::Bits Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>RE/flex <a class="el" href="classreflex_1_1_bits.html" title="RE/flex Bits class for dynamic bit vectors. ">Bits</a> class for dynamic bit vectors.  
 <a href="classreflex_1_1_bits.html#details">More...</a></p>

<p><code>#include &lt;bits.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreflex_1_1_bits_1_1_bitref.html">Bitref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">References a single bit, returned by operator[].  <a href="structreflex_1_1_bits_1_1_bitref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae077b0ee7614ebeba83ab0e7f27452c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#ae077b0ee7614ebeba83ab0e7f27452c8">Bits</a> ()</td></tr>
<tr class="memdesc:ae077b0ee7614ebeba83ab0e7f27452c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty bit vector.  <a href="#ae077b0ee7614ebeba83ab0e7f27452c8">More...</a><br /></td></tr>
<tr class="separator:ae077b0ee7614ebeba83ab0e7f27452c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb961a8c79ad7090d8a2d27672018b1a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#abb961a8c79ad7090d8a2d27672018b1a">Bits</a> (const <a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;bits)</td></tr>
<tr class="memdesc:abb961a8c79ad7090d8a2d27672018b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#abb961a8c79ad7090d8a2d27672018b1a">More...</a><br /></td></tr>
<tr class="separator:abb961a8c79ad7090d8a2d27672018b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cebd7741c96f873fa03ca04d74ae38a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#a8cebd7741c96f873fa03ca04d74ae38a">Bits</a> (size_t n)</td></tr>
<tr class="memdesc:a8cebd7741c96f873fa03ca04d74ae38a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a bit vector and set n'th bit.  <a href="#a8cebd7741c96f873fa03ca04d74ae38a">More...</a><br /></td></tr>
<tr class="separator:a8cebd7741c96f873fa03ca04d74ae38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e06bdf54b6492aef0c6d93aedda3b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#ab2e06bdf54b6492aef0c6d93aedda3b3">Bits</a> (size_t n1, size_t n2)</td></tr>
<tr class="memdesc:ab2e06bdf54b6492aef0c6d93aedda3b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a bit vector and set a range of bits n1'th to n2'th.  <a href="#ab2e06bdf54b6492aef0c6d93aedda3b3">More...</a><br /></td></tr>
<tr class="separator:ab2e06bdf54b6492aef0c6d93aedda3b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ff4b079eea699ef30a12db76f8bdfd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#aa3ff4b079eea699ef30a12db76f8bdfd">~Bits</a> ()</td></tr>
<tr class="memdesc:aa3ff4b079eea699ef30a12db76f8bdfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy bits.  <a href="#aa3ff4b079eea699ef30a12db76f8bdfd">More...</a><br /></td></tr>
<tr class="separator:aa3ff4b079eea699ef30a12db76f8bdfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0fba2b3dc252c65ccceedac01fc2bbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#ad0fba2b3dc252c65ccceedac01fc2bbf">operator=</a> (const <a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;bits)</td></tr>
<tr class="memdesc:ad0fba2b3dc252c65ccceedac01fc2bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign bits.  <a href="#ad0fba2b3dc252c65ccceedac01fc2bbf">More...</a><br /></td></tr>
<tr class="separator:ad0fba2b3dc252c65ccceedac01fc2bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b37c1bd009d04de5e31063d1cd3e57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structreflex_1_1_bits_1_1_bitref.html">Bitref</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#ae0b37c1bd009d04de5e31063d1cd3e57">operator[]</a> (size_t n)</td></tr>
<tr class="memdesc:ae0b37c1bd009d04de5e31063d1cd3e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference n'th bit in the bit vector to assign a value to that bit.  <a href="#ae0b37c1bd009d04de5e31063d1cd3e57">More...</a><br /></td></tr>
<tr class="separator:ae0b37c1bd009d04de5e31063d1cd3e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9583e4fcb869c739e217603f88eb1b13"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#a9583e4fcb869c739e217603f88eb1b13">operator[]</a> (size_t n) const </td></tr>
<tr class="memdesc:a9583e4fcb869c739e217603f88eb1b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns n'th bit.  <a href="#a9583e4fcb869c739e217603f88eb1b13">More...</a><br /></td></tr>
<tr class="separator:a9583e4fcb869c739e217603f88eb1b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65dab33f00d00f90cbd188dd6f250476"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#a65dab33f00d00f90cbd188dd6f250476">insert</a> (size_t n)</td></tr>
<tr class="memdesc:a65dab33f00d00f90cbd188dd6f250476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert and set a bit in the bit vector.  <a href="#a65dab33f00d00f90cbd188dd6f250476">More...</a><br /></td></tr>
<tr class="separator:a65dab33f00d00f90cbd188dd6f250476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0eed42abf159a0fadfdfdb97fdc89d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#a4a0eed42abf159a0fadfdfdb97fdc89d">erase</a> (size_t n)</td></tr>
<tr class="memdesc:a4a0eed42abf159a0fadfdfdb97fdc89d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a bit in the bit vector.  <a href="#a4a0eed42abf159a0fadfdfdb97fdc89d">More...</a><br /></td></tr>
<tr class="separator:a4a0eed42abf159a0fadfdfdb97fdc89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3d5eb8b76cfdccf51afb9f01c0afa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#aba3d5eb8b76cfdccf51afb9f01c0afa9">flip</a> (size_t n)</td></tr>
<tr class="memdesc:aba3d5eb8b76cfdccf51afb9f01c0afa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips a bit in the bit vector.  <a href="#aba3d5eb8b76cfdccf51afb9f01c0afa9">More...</a><br /></td></tr>
<tr class="separator:aba3d5eb8b76cfdccf51afb9f01c0afa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8b2b0dbee4837057a070907e4548fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#a4a8b2b0dbee4837057a070907e4548fb">insert</a> (size_t n1, size_t n2)</td></tr>
<tr class="memdesc:a4a8b2b0dbee4837057a070907e4548fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert and set a range of bits in the bit vector.  <a href="#a4a8b2b0dbee4837057a070907e4548fb">More...</a><br /></td></tr>
<tr class="separator:a4a8b2b0dbee4837057a070907e4548fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35cf04543c4d87dbf406f061fdd9cb92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#a35cf04543c4d87dbf406f061fdd9cb92">erase</a> (size_t n1, size_t n2)</td></tr>
<tr class="memdesc:a35cf04543c4d87dbf406f061fdd9cb92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a range of bits in the bit vector.  <a href="#a35cf04543c4d87dbf406f061fdd9cb92">More...</a><br /></td></tr>
<tr class="separator:a35cf04543c4d87dbf406f061fdd9cb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b01ae9954310d6ca2f03ad014f8f614"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#a6b01ae9954310d6ca2f03ad014f8f614">flip</a> (size_t n1, size_t n2)</td></tr>
<tr class="memdesc:a6b01ae9954310d6ca2f03ad014f8f614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip a range of bits in the bit vector.  <a href="#a6b01ae9954310d6ca2f03ad014f8f614">More...</a><br /></td></tr>
<tr class="separator:a6b01ae9954310d6ca2f03ad014f8f614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda1f31b0c1ec7fe84bfac17995995e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#aeda1f31b0c1ec7fe84bfac17995995e3">lshift</a> ()</td></tr>
<tr class="memdesc:aeda1f31b0c1ec7fe84bfac17995995e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-shift left by one.  <a href="#aeda1f31b0c1ec7fe84bfac17995995e3">More...</a><br /></td></tr>
<tr class="separator:aeda1f31b0c1ec7fe84bfac17995995e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af310869c725d595b38f47e5c5b6a71ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#af310869c725d595b38f47e5c5b6a71ab">rshift</a> ()</td></tr>
<tr class="memdesc:af310869c725d595b38f47e5c5b6a71ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-shift right by one.  <a href="#af310869c725d595b38f47e5c5b6a71ab">More...</a><br /></td></tr>
<tr class="separator:af310869c725d595b38f47e5c5b6a71ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5eb0c2b46d731895e64933d2c6b3df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#a4f5eb0c2b46d731895e64933d2c6b3df">operator|=</a> (const <a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;bits)</td></tr>
<tr class="memdesc:a4f5eb0c2b46d731895e64933d2c6b3df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-or (set union) the bit vector with the given bits.  <a href="#a4f5eb0c2b46d731895e64933d2c6b3df">More...</a><br /></td></tr>
<tr class="separator:a4f5eb0c2b46d731895e64933d2c6b3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3ca7ea4be7cb808dff49bfe563ab9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#a8c3ca7ea4be7cb808dff49bfe563ab9b">operator&amp;=</a> (const <a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;bits)</td></tr>
<tr class="memdesc:a8c3ca7ea4be7cb808dff49bfe563ab9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-and (set intersection) the bit vector with the given bits.  <a href="#a8c3ca7ea4be7cb808dff49bfe563ab9b">More...</a><br /></td></tr>
<tr class="separator:a8c3ca7ea4be7cb808dff49bfe563ab9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de7dd0e5c09211ee4a15f13c9fb932c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#a3de7dd0e5c09211ee4a15f13c9fb932c">operator^=</a> (const <a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;bits)</td></tr>
<tr class="memdesc:a3de7dd0e5c09211ee4a15f13c9fb932c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-xor the bit vector with the given bits.  <a href="#a3de7dd0e5c09211ee4a15f13c9fb932c">More...</a><br /></td></tr>
<tr class="separator:a3de7dd0e5c09211ee4a15f13c9fb932c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155b67c62ef98f0cedfd10fe54d62dab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#a155b67c62ef98f0cedfd10fe54d62dab">operator-=</a> (const <a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;bits)</td></tr>
<tr class="memdesc:a155b67c62ef98f0cedfd10fe54d62dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-delete (set minus) the bit vector with the given bits.  <a href="#a155b67c62ef98f0cedfd10fe54d62dab">More...</a><br /></td></tr>
<tr class="separator:a155b67c62ef98f0cedfd10fe54d62dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4aa634abafed337ff54081ffc745f48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_bits.html">Bits</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#ac4aa634abafed337ff54081ffc745f48">operator|</a> (const <a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;bits) const </td></tr>
<tr class="memdesc:ac4aa634abafed337ff54081ffc745f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-or (set union) of two bit vectors.  <a href="#ac4aa634abafed337ff54081ffc745f48">More...</a><br /></td></tr>
<tr class="separator:ac4aa634abafed337ff54081ffc745f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e2fd08b23a879b19914ade7da650ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_bits.html">Bits</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#a94e2fd08b23a879b19914ade7da650ee">operator&amp;</a> (const <a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;bits) const </td></tr>
<tr class="memdesc:a94e2fd08b23a879b19914ade7da650ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-and (set intersection) of two bit vectors.  <a href="#a94e2fd08b23a879b19914ade7da650ee">More...</a><br /></td></tr>
<tr class="separator:a94e2fd08b23a879b19914ade7da650ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82adff70812b58388cd07c5613991e38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_bits.html">Bits</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#a82adff70812b58388cd07c5613991e38">operator^</a> (const <a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;bits) const </td></tr>
<tr class="memdesc:a82adff70812b58388cd07c5613991e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-xor of two bit vectors.  <a href="#a82adff70812b58388cd07c5613991e38">More...</a><br /></td></tr>
<tr class="separator:a82adff70812b58388cd07c5613991e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8981b775bc4e1ca61f38d4b58d25da4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_bits.html">Bits</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#af8981b775bc4e1ca61f38d4b58d25da4">operator-</a> (const <a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;bits) const </td></tr>
<tr class="memdesc:af8981b775bc4e1ca61f38d4b58d25da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-delete (set minus) of two bit vectors.  <a href="#af8981b775bc4e1ca61f38d4b58d25da4">More...</a><br /></td></tr>
<tr class="separator:af8981b775bc4e1ca61f38d4b58d25da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55857d3f823da8526418e1f99fe034e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_bits.html">Bits</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#ab55857d3f823da8526418e1f99fe034e">operator~</a> () const </td></tr>
<tr class="memdesc:ab55857d3f823da8526418e1f99fe034e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complement of the bit vector with all bits flipped.  <a href="#ab55857d3f823da8526418e1f99fe034e">More...</a><br /></td></tr>
<tr class="separator:ab55857d3f823da8526418e1f99fe034e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae877e24f5bd0dfb68a87c9b21f0c9859"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#ae877e24f5bd0dfb68a87c9b21f0c9859">operator==</a> (const <a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;bits) const </td></tr>
<tr class="memdesc:ae877e24f5bd0dfb68a87c9b21f0c9859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if bit vectors are equal.  <a href="#ae877e24f5bd0dfb68a87c9b21f0c9859">More...</a><br /></td></tr>
<tr class="separator:ae877e24f5bd0dfb68a87c9b21f0c9859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0628eaf155a723db873a61d6a272d84b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#a0628eaf155a723db873a61d6a272d84b">operator!=</a> (const <a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;bits) const </td></tr>
<tr class="memdesc:a0628eaf155a723db873a61d6a272d84b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if bit vectors are unequal.  <a href="#a0628eaf155a723db873a61d6a272d84b">More...</a><br /></td></tr>
<tr class="separator:a0628eaf155a723db873a61d6a272d84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc13e8f63354375cf00c2da1795d8d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#a8dc13e8f63354375cf00c2da1795d8d6">operator&lt;</a> (const <a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;bits) const </td></tr>
<tr class="memdesc:a8dc13e8f63354375cf00c2da1795d8d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the bit vector is lexicographically less than the given right-hand side bits.  <a href="#a8dc13e8f63354375cf00c2da1795d8d6">More...</a><br /></td></tr>
<tr class="separator:a8dc13e8f63354375cf00c2da1795d8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7f149ae92ca60ee63b9b59376082d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#a6c7f149ae92ca60ee63b9b59376082d6">operator&gt;</a> (const <a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;bits) const </td></tr>
<tr class="memdesc:a6c7f149ae92ca60ee63b9b59376082d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the bit vector is lexicographically greater than the given right-hand side bits.  <a href="#a6c7f149ae92ca60ee63b9b59376082d6">More...</a><br /></td></tr>
<tr class="separator:a6c7f149ae92ca60ee63b9b59376082d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab5fbed1af24ecff7a3c4a104da00aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#a9ab5fbed1af24ecff7a3c4a104da00aa">operator&lt;=</a> (const <a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;bits) const </td></tr>
<tr class="memdesc:a9ab5fbed1af24ecff7a3c4a104da00aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the bit vector is lexicographically less-or-equal to the given right-hand side bits.  <a href="#a9ab5fbed1af24ecff7a3c4a104da00aa">More...</a><br /></td></tr>
<tr class="separator:a9ab5fbed1af24ecff7a3c4a104da00aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935b56b5f7b0d767d73165a80f9e410e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#a935b56b5f7b0d767d73165a80f9e410e">operator&gt;=</a> (const <a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;bits) const </td></tr>
<tr class="memdesc:a935b56b5f7b0d767d73165a80f9e410e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the bit vector is lexicographically greater-or-equal to the given right-hand side bits.  <a href="#a935b56b5f7b0d767d73165a80f9e410e">More...</a><br /></td></tr>
<tr class="separator:a935b56b5f7b0d767d73165a80f9e410e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2310e8491e6fbd4e0dc1e9e62a633c0a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#a2310e8491e6fbd4e0dc1e9e62a633c0a">all</a> () const </td></tr>
<tr class="memdesc:a2310e8491e6fbd4e0dc1e9e62a633c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all bits are set.  <a href="#a2310e8491e6fbd4e0dc1e9e62a633c0a">More...</a><br /></td></tr>
<tr class="separator:a2310e8491e6fbd4e0dc1e9e62a633c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99fb648e7b339ce719232dec39b7fc1f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#a99fb648e7b339ce719232dec39b7fc1f">any</a> () const </td></tr>
<tr class="memdesc:a99fb648e7b339ce719232dec39b7fc1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if any bit is set.  <a href="#a99fb648e7b339ce719232dec39b7fc1f">More...</a><br /></td></tr>
<tr class="separator:a99fb648e7b339ce719232dec39b7fc1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ad4ff056134aba0d01bb4242a1617e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#a93ad4ff056134aba0d01bb4242a1617e">clear</a> ()</td></tr>
<tr class="memdesc:a93ad4ff056134aba0d01bb4242a1617e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all bits.  <a href="#a93ad4ff056134aba0d01bb4242a1617e">More...</a><br /></td></tr>
<tr class="separator:a93ad4ff056134aba0d01bb4242a1617e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac40e5b072f58d3204eb09be490fefd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#a5ac40e5b072f58d3204eb09be490fefd">flip</a> ()</td></tr>
<tr class="memdesc:a5ac40e5b072f58d3204eb09be490fefd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip all bits.  <a href="#a5ac40e5b072f58d3204eb09be490fefd">More...</a><br /></td></tr>
<tr class="separator:a5ac40e5b072f58d3204eb09be490fefd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08f8ead079c96ffceadc62fb1c3eb91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#af08f8ead079c96ffceadc62fb1c3eb91">reserve</a> (size_t len)</td></tr>
<tr class="memdesc:af08f8ead079c96ffceadc62fb1c3eb91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves space in the bit vector for len bits without changing its current content.  <a href="#af08f8ead079c96ffceadc62fb1c3eb91">More...</a><br /></td></tr>
<tr class="separator:af08f8ead079c96ffceadc62fb1c3eb91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab08f8cdebd0678507d8f62d25336713"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#aab08f8cdebd0678507d8f62d25336713">size</a> () const </td></tr>
<tr class="memdesc:aab08f8cdebd0678507d8f62d25336713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current length of the bit vector.  <a href="#aab08f8cdebd0678507d8f62d25336713">More...</a><br /></td></tr>
<tr class="separator:aab08f8cdebd0678507d8f62d25336713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e6e437dac9eafbcad0bf286e202e38"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#a78e6e437dac9eafbcad0bf286e202e38">count</a> () const </td></tr>
<tr class="memdesc:a78e6e437dac9eafbcad0bf286e202e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bits set.  <a href="#a78e6e437dac9eafbcad0bf286e202e38">More...</a><br /></td></tr>
<tr class="separator:a78e6e437dac9eafbcad0bf286e202e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb8cd25c81bf48e53fe9d02e016c059"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#a1fb8cd25c81bf48e53fe9d02e016c059">intersects</a> (const <a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;bits) const </td></tr>
<tr class="memdesc:a1fb8cd25c81bf48e53fe9d02e016c059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the bit vector intersects with the given bits, false if the bit vectors are disjoint.  <a href="#a1fb8cd25c81bf48e53fe9d02e016c059">More...</a><br /></td></tr>
<tr class="separator:a1fb8cd25c81bf48e53fe9d02e016c059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b528a08e89e3d83ab902123769819b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#a4b528a08e89e3d83ab902123769819b4">contains</a> (const <a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;bits) const </td></tr>
<tr class="memdesc:a4b528a08e89e3d83ab902123769819b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given bits are a subset of the bit vector, i.e. for each bit in bits, the corresponding bit in the bit vector is set.  <a href="#a4b528a08e89e3d83ab902123769819b4">More...</a><br /></td></tr>
<tr class="separator:a4b528a08e89e3d83ab902123769819b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb8e2c53cc8f09261740e342d4a43cb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#a0fb8e2c53cc8f09261740e342d4a43cb">find_first</a> (size_t n=0) const </td></tr>
<tr class="memdesc:a0fb8e2c53cc8f09261740e342d4a43cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of the first bit set in the bit vector, or <a class="el" href="classreflex_1_1_bits.html#a7a4b11558c758009cd2aa66e3fe5041a">Bits::npos</a> if none.  <a href="#a0fb8e2c53cc8f09261740e342d4a43cb">More...</a><br /></td></tr>
<tr class="separator:a0fb8e2c53cc8f09261740e342d4a43cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8b51223c078fe74528de476243d9c8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#a5e8b51223c078fe74528de476243d9c8">find_next</a> (size_t n) const </td></tr>
<tr class="memdesc:a5e8b51223c078fe74528de476243d9c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next position of a bit set in the bit vector, or <a class="el" href="classreflex_1_1_bits.html#a7a4b11558c758009cd2aa66e3fe5041a">Bits::npos</a> if none.  <a href="#a5e8b51223c078fe74528de476243d9c8">More...</a><br /></td></tr>
<tr class="separator:a5e8b51223c078fe74528de476243d9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f00a16706690aae4f8acaf5c5307e2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#a0f00a16706690aae4f8acaf5c5307e2f">swap</a> (<a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;bits)</td></tr>
<tr class="memdesc:a0f00a16706690aae4f8acaf5c5307e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap bit vectors.  <a href="#a0f00a16706690aae4f8acaf5c5307e2f">More...</a><br /></td></tr>
<tr class="separator:a0f00a16706690aae4f8acaf5c5307e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a7a4b11558c758009cd2aa66e3fe5041a"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#a7a4b11558c758009cd2aa66e3fe5041a">npos</a> = static_cast&lt;size_t&gt;(-1)</td></tr>
<tr class="separator:a7a4b11558c758009cd2aa66e3fe5041a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ad0df0bf645e45c4673edc987fcd7566e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#ad0df0bf645e45c4673edc987fcd7566e">alloc</a> (size_t len)</td></tr>
<tr class="memdesc:ad0df0bf645e45c4673edc987fcd7566e"><td class="mdescLeft">&#160;</td><td class="mdescRight">On-demand allocator.  <a href="#ad0df0bf645e45c4673edc987fcd7566e">More...</a><br /></td></tr>
<tr class="separator:ad0df0bf645e45c4673edc987fcd7566e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a3e4e4d06fde5f4232246d83c3ced4566"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#a3e4e4d06fde5f4232246d83c3ced4566">len_</a></td></tr>
<tr class="memdesc:a3e4e4d06fde5f4232246d83c3ced4566"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of words  <a href="#a3e4e4d06fde5f4232246d83c3ced4566">More...</a><br /></td></tr>
<tr class="separator:a3e4e4d06fde5f4232246d83c3ced4566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cdb4482b166361b2a8640a7ad986675"><td class="memItemLeft" align="right" valign="top">uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_bits.html#a2cdb4482b166361b2a8640a7ad986675">vec_</a></td></tr>
<tr class="memdesc:a2cdb4482b166361b2a8640a7ad986675"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of words  <a href="#a2cdb4482b166361b2a8640a7ad986675">More...</a><br /></td></tr>
<tr class="separator:a2cdb4482b166361b2a8640a7ad986675"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>RE/flex <a class="el" href="classreflex_1_1_bits.html" title="RE/flex Bits class for dynamic bit vectors. ">Bits</a> class for dynamic bit vectors. </p>
<p>Dynamic bit vectors are stored in <a class="el" href="classreflex_1_1_bits.html" title="RE/flex Bits class for dynamic bit vectors. ">Bits</a> objects, which can be manipulated with the usual bit-operations (<code>|</code> (bitor), <code>&amp;</code> (bitand), <code>^</code> (bitxor)). Supports comparison relations on bit vectors, check if all bits set, check if any bits are set, flip bits, shift bits left or right, count bits, check if a bit vectors intersects another, check if a bit vector contains another. find_first bit, find_next bit.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><a class="code" href="classreflex_1_1_bits.html">reflex::Bits</a> digit(<span class="charliteral">&#39;0&#39;</span>, <span class="charliteral">&#39;9&#39;</span>); <span class="comment">// bits &#39;0&#39; (48th bit) to &#39;9&#39; (57th bit)</span></div><div class="line"><a class="code" href="classreflex_1_1_bits.html">reflex::Bits</a> upper(<span class="charliteral">&#39;A&#39;</span>, <span class="charliteral">&#39;Z&#39;</span>); <span class="comment">// bits &#39;A&#39; (65th bit) to &#39;Z&#39; (92th bit)</span></div><div class="line"><a class="code" href="classreflex_1_1_bits.html">reflex::Bits</a> lower(<span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;z&#39;</span>); <span class="comment">// bits &#39;a&#39; (97th bit) to &#39;z&#39; (122th bit)</span></div><div class="line"><span class="keywordflow">if</span> (upper.intersects(lower) == <span class="keyword">false</span>)</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;upper and lower are disjoint\n&quot;</span>;</div><div class="line"><a class="code" href="classreflex_1_1_bits.html">reflex::Bits</a> alnum = digit | upper | lower;</div><div class="line"><span class="keywordflow">if</span> (alnum.<a class="code" href="classreflex_1_1_bits.html#a4b528a08e89e3d83ab902123769819b4">contains</a>(digit) == <span class="keyword">true</span>)</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;digit is a subset of alnum\n&quot;</span>;</div><div class="line"><span class="keywordflow">if</span> (alnum[<span class="charliteral">&#39;_&#39;</span>] == <span class="keyword">false</span>)</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;_ is not in alnum\n&quot;</span>;</div><div class="line">alnum[<span class="charliteral">&#39;_&#39;</span>] = <span class="keyword">true</span>;</div><div class="line"><span class="keywordflow">if</span> (alnum[<span class="charliteral">&#39;_&#39;</span>] == <span class="keyword">true</span>)</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;_ is in updated alnum\n&quot;</span>;</div><div class="line">std::cout &lt;&lt; alnum.<a class="code" href="classreflex_1_1_bits.html#a78e6e437dac9eafbcad0bf286e202e38">count</a>() &lt;&lt; <span class="stringliteral">&quot; bits in alnum\n&quot;</span>;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = alnum.<a class="code" href="classreflex_1_1_bits.html#a0fb8e2c53cc8f09261740e342d4a43cb">find_first</a>(); i != <a class="code" href="classreflex_1_1_bits.html#a7a4b11558c758009cd2aa66e3fe5041a">reflex::Bits::npos</a>; i = alnum.<a class="code" href="classreflex_1_1_bits.html#a5e8b51223c078fe74528de476243d9c8">find_next</a>(i))</div><div class="line">  std::cout &lt;&lt; (<span class="keywordtype">char</span>)i;</div></div><!-- fragment --><p>Output: </p><pre class="fragment">upper and lower are disjoint
digit is a subset of alnum
_ is not in alnum
_ is in updated alnum
63 bits in alnum
0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae077b0ee7614ebeba83ab0e7f27452c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Bits::Bits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an empty bit vector. </p>

</div>
</div>
<a class="anchor" id="abb961a8c79ad7090d8a2d27672018b1a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Bits::Bits </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;&#160;</td>
          <td class="paramname"><em>bits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bits</td><td>bits to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8cebd7741c96f873fa03ca04d74ae38a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Bits::Bits </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a bit vector and set n'th bit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>n'th bit to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab2e06bdf54b6492aef0c6d93aedda3b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Bits::Bits </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a bit vector and set a range of bits n1'th to n2'th. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n1</td><td>first bit to set </td></tr>
    <tr><td class="paramname">n2</td><td>last bit to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa3ff4b079eea699ef30a12db76f8bdfd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Bits::~Bits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy bits. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2310e8491e6fbd4e0dc1e9e62a633c0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Bits::all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all bits are set. </p>
<dl class="section return"><dt>Returns</dt><dd>true if all bits set, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ad0df0bf645e45c4673edc987fcd7566e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Bits::alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>On-demand allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>number of words required </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a99fb648e7b339ce719232dec39b7fc1f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Bits::any </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if any bit is set. </p>
<dl class="section return"><dt>Returns</dt><dd>true if any bit set, false if none. </dd></dl>

</div>
</div>
<a class="anchor" id="a93ad4ff056134aba0d01bb4242a1617e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_bits.html">Bits</a>&amp; reflex::Bits::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase all bits. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b528a08e89e3d83ab902123769819b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Bits::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;&#160;</td>
          <td class="paramname"><em>bits</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the given bits are a subset of the bit vector, i.e. for each bit in bits, the corresponding bit in the bit vector is set. </p>
<dl class="section return"><dt>Returns</dt><dd>true if bits is a subset. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bits</td><td>bits </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a78e6e437dac9eafbcad0bf286e202e38"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::Bits::count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of bits set. </p>
<dl class="section return"><dt>Returns</dt><dd>number of 1 bits. </dd></dl>

</div>
</div>
<a class="anchor" id="a4a0eed42abf159a0fadfdfdb97fdc89d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_bits.html">Bits</a>&amp; reflex::Bits::erase </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase a bit in the bit vector. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to this object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>n'th bit to erase </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a35cf04543c4d87dbf406f061fdd9cb92"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_bits.html">Bits</a>&amp; reflex::Bits::erase </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase a range of bits in the bit vector. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to this object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n1</td><td>first bit to erase </td></tr>
    <tr><td class="paramname">n2</td><td>last bit to erase </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0fb8e2c53cc8f09261740e342d4a43cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::Bits::find_first </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the position of the first bit set in the bit vector, or <a class="el" href="classreflex_1_1_bits.html#a7a4b11558c758009cd2aa66e3fe5041a">Bits::npos</a> if none. </p>
<dl class="section return"><dt>Returns</dt><dd>first position or <a class="el" href="classreflex_1_1_bits.html#a7a4b11558c758009cd2aa66e3fe5041a">Bits::npos</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>internal parameter (do not use) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e8b51223c078fe74528de476243d9c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::Bits::find_next </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the next position of a bit set in the bit vector, or <a class="el" href="classreflex_1_1_bits.html#a7a4b11558c758009cd2aa66e3fe5041a">Bits::npos</a> if none. </p>
<dl class="section return"><dt>Returns</dt><dd>next position or <a class="el" href="classreflex_1_1_bits.html#a7a4b11558c758009cd2aa66e3fe5041a">Bits::npos</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the current position to search from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aba3d5eb8b76cfdccf51afb9f01c0afa9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_bits.html">Bits</a>&amp; reflex::Bits::flip </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flips a bit in the bit vector. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to this object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>n'th bit to flip </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6b01ae9954310d6ca2f03ad014f8f614"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_bits.html">Bits</a>&amp; reflex::Bits::flip </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flip a range of bits in the bit vector. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to this object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n1</td><td>first bit to flip </td></tr>
    <tr><td class="paramname">n2</td><td>last bit to flip </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5ac40e5b072f58d3204eb09be490fefd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_bits.html">Bits</a>&amp; reflex::Bits::flip </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flip all bits. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a65dab33f00d00f90cbd188dd6f250476"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_bits.html">Bits</a>&amp; reflex::Bits::insert </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert and set a bit in the bit vector. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to this object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>n'th bit to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4a8b2b0dbee4837057a070907e4548fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_bits.html">Bits</a>&amp; reflex::Bits::insert </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert and set a range of bits in the bit vector. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to this object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n1</td><td>first bit to set </td></tr>
    <tr><td class="paramname">n2</td><td>last bit to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1fb8cd25c81bf48e53fe9d02e016c059"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Bits::intersects </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;&#160;</td>
          <td class="paramname"><em>bits</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the bit vector intersects with the given bits, false if the bit vectors are disjoint. </p>
<dl class="section return"><dt>Returns</dt><dd>true if bits intersect or false if disjoint. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bits</td><td>bits </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeda1f31b0c1ec7fe84bfac17995995e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_bits.html">Bits</a>&amp; reflex::Bits::lshift </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bit-shift left by one. </p>

</div>
</div>
<a class="anchor" id="a0628eaf155a723db873a61d6a272d84b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Bits::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;&#160;</td>
          <td class="paramname"><em>bits</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if bit vectors are unequal. </p>
<dl class="section return"><dt>Returns</dt><dd>true (unequal) or false (equal). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bits</td><td>rhs bits </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a94e2fd08b23a879b19914ade7da650ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_bits.html">Bits</a> reflex::Bits::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;&#160;</td>
          <td class="paramname"><em>bits</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bit-and (set intersection) of two bit vectors. </p>
<dl class="section return"><dt>Returns</dt><dd>bit vector of the result. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bits</td><td>bits </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8c3ca7ea4be7cb808dff49bfe563ab9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_bits.html">Bits</a>&amp; reflex::Bits::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;&#160;</td>
          <td class="paramname"><em>bits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bit-and (set intersection) the bit vector with the given bits. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to this object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bits</td><td>bits </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af8981b775bc4e1ca61f38d4b58d25da4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_bits.html">Bits</a> reflex::Bits::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;&#160;</td>
          <td class="paramname"><em>bits</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bit-delete (set minus) of two bit vectors. </p>
<dl class="section return"><dt>Returns</dt><dd>bit vector of the result. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bits</td><td>bits </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a155b67c62ef98f0cedfd10fe54d62dab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_bits.html">Bits</a>&amp; reflex::Bits::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;&#160;</td>
          <td class="paramname"><em>bits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bit-delete (set minus) the bit vector with the given bits. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to this object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bits</td><td>bits </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8dc13e8f63354375cf00c2da1795d8d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Bits::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;&#160;</td>
          <td class="paramname"><em>bits</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the bit vector is lexicographically less than the given right-hand side bits. </p>
<dl class="section return"><dt>Returns</dt><dd>true (less) or false (greater-or-equal). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bits</td><td>rhs bits </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9ab5fbed1af24ecff7a3c4a104da00aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Bits::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;&#160;</td>
          <td class="paramname"><em>bits</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the bit vector is lexicographically less-or-equal to the given right-hand side bits. </p>
<dl class="section return"><dt>Returns</dt><dd>true (less-or-equal) or false (greater). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bits</td><td>rhs bits </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad0fba2b3dc252c65ccceedac01fc2bbf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_bits.html">Bits</a>&amp; reflex::Bits::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;&#160;</td>
          <td class="paramname"><em>bits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign bits. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to this object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bits</td><td>bits to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae877e24f5bd0dfb68a87c9b21f0c9859"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Bits::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;&#160;</td>
          <td class="paramname"><em>bits</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if bit vectors are equal. </p>
<dl class="section return"><dt>Returns</dt><dd>true (equal) or false (unequal). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bits</td><td>rhs bits </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6c7f149ae92ca60ee63b9b59376082d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Bits::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;&#160;</td>
          <td class="paramname"><em>bits</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the bit vector is lexicographically greater than the given right-hand side bits. </p>
<dl class="section return"><dt>Returns</dt><dd>true (greater) or false (less-or-equal). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bits</td><td>rhs bits </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a935b56b5f7b0d767d73165a80f9e410e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Bits::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;&#160;</td>
          <td class="paramname"><em>bits</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the bit vector is lexicographically greater-or-equal to the given right-hand side bits. </p>
<dl class="section return"><dt>Returns</dt><dd>true (greater-or-equal) or false (less). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bits</td><td>rhs bits </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae0b37c1bd009d04de5e31063d1cd3e57"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structreflex_1_1_bits_1_1_bitref.html">Bitref</a> reflex::Bits::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reference n'th bit in the bit vector to assign a value to that bit. </p>
<dl class="section return"><dt>Returns</dt><dd>bit reference to assign. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>n'th bit </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9583e4fcb869c739e217603f88eb1b13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Bits::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns n'th bit. </p>
<dl class="section return"><dt>Returns</dt><dd>true if n'th bit is set, false otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>n'th bit to return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a82adff70812b58388cd07c5613991e38"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_bits.html">Bits</a> reflex::Bits::operator^ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;&#160;</td>
          <td class="paramname"><em>bits</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bit-xor of two bit vectors. </p>
<dl class="section return"><dt>Returns</dt><dd>bit vector of the result. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bits</td><td>bits </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3de7dd0e5c09211ee4a15f13c9fb932c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_bits.html">Bits</a>&amp; reflex::Bits::operator^= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;&#160;</td>
          <td class="paramname"><em>bits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bit-xor the bit vector with the given bits. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to this object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bits</td><td>bits </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac4aa634abafed337ff54081ffc745f48"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_bits.html">Bits</a> reflex::Bits::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;&#160;</td>
          <td class="paramname"><em>bits</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bit-or (set union) of two bit vectors. </p>
<dl class="section return"><dt>Returns</dt><dd>bit vector of the result. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bits</td><td>bits </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4f5eb0c2b46d731895e64933d2c6b3df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_bits.html">Bits</a>&amp; reflex::Bits::operator|= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;&#160;</td>
          <td class="paramname"><em>bits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bit-or (set union) the bit vector with the given bits. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to this object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bits</td><td>bits </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab55857d3f823da8526418e1f99fe034e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_bits.html">Bits</a> reflex::Bits::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Complement of the bit vector with all bits flipped. </p>
<dl class="section return"><dt>Returns</dt><dd>bit vector of the result. </dd></dl>

</div>
</div>
<a class="anchor" id="af08f8ead079c96ffceadc62fb1c3eb91"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_bits.html">Bits</a>&amp; reflex::Bits::reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserves space in the bit vector for len bits without changing its current content. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to this object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>number of bits to reserve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af310869c725d595b38f47e5c5b6a71ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_bits.html">Bits</a>&amp; reflex::Bits::rshift </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bit-shift right by one. </p>

</div>
</div>
<a class="anchor" id="aab08f8cdebd0678507d8f62d25336713"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::Bits::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current length of the bit vector. </p>
<dl class="section return"><dt>Returns</dt><dd>number of bits. </dd></dl>

</div>
</div>
<a class="anchor" id="a0f00a16706690aae4f8acaf5c5307e2f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Bits::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classreflex_1_1_bits.html">Bits</a> &amp;&#160;</td>
          <td class="paramname"><em>bits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap bit vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bits</td><td>bits </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a3e4e4d06fde5f4232246d83c3ced4566"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::Bits::len_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>number of words </p>

</div>
</div>
<a class="anchor" id="a7a4b11558c758009cd2aa66e3fe5041a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t reflex::Bits::npos = static_cast&lt;size_t&gt;(-1)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>npos returned by <a class="el" href="classreflex_1_1_bits.html#a0fb8e2c53cc8f09261740e342d4a43cb" title="Returns the position of the first bit set in the bit vector, or Bits::npos if none. ">find_first()</a> and <a class="el" href="classreflex_1_1_bits.html#a5e8b51223c078fe74528de476243d9c8" title="Returns the next position of a bit set in the bit vector, or Bits::npos if none. ">find_next()</a> </p>

</div>
</div>
<a class="anchor" id="a2cdb4482b166361b2a8640a7ad986675"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t* reflex::Bits::vec_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>array of words </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bits_8h.html">bits.h</a></li>
</ul>
</div><!-- contents -->
<hr class="footer">
<address class="footer"><small>
Converted on Fri Jan 24 2025 10:30:13 by <a target="_blank" href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.11</small></address>
<br>
<div style="height: 246px; background: #DBDBDB;">
</body>
</html>
