<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta http-equiv="cache-control" content="no-cache">
<title>reflex::AbstractMatcher Class Reference</title>
<link href="doxygen_tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="doxygen_content.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top">
 <div id="titlearea">
  <table height="72px" width="100%" cellspacing="0" cellpadding="0">
   <tbody>
    <tr>
     <td width="10%">&nbsp;</td>
     <td><a href="https://github.com/Genivia/RE-flex"><img src="reflex-logo.png"/></a></td>
     <td>
      <div style="float: right; font-size: 18px; font-weight: bold;">reflex::AbstractMatcher Class Reference</div>
      <br>
      <div style="float: right; font-size: 10px;">updated Fri Jan 24 2025 by Robert van Engelen</div>
     </td>
     <td width="10%">&nbsp;</td>
    </tr>
   </tbody>
  </table>
 </div>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacereflex.html">reflex</a></li><li class="navelem"><a class="el" href="classreflex_1_1_abstract_matcher.html">AbstractMatcher</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classreflex_1_1_abstract_matcher-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">reflex::AbstractMatcher Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>The abstract matcher base class template defines an interface for all pattern matcher engines.  
 <a href="classreflex_1_1_abstract_matcher.html#details">More...</a></p>

<p><code>#include &lt;absmatcher.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for reflex::AbstractMatcher:</div>
<div class="dyncontent">
<div class="center"><img src="classreflex_1_1_abstract_matcher__inherit__graph.png" border="0" usemap="#reflex_1_1_abstract_matcher_inherit__map" alt="Inheritance graph"/></div>
<map name="reflex_1_1_abstract_matcher_inherit__map" id="reflex_1_1_abstract_matcher_inherit__map">
<area shape="rect" id="node2" href="classreflex_1_1_pattern_matcher.html" title="reflex::PatternMatcher\l\&lt; boost::regex \&gt;" alt="" coords="227,41,378,83"/>
<area shape="rect" id="node6" href="classreflex_1_1_pattern_matcher.html" title="reflex::PatternMatcher\l\&lt; reflex::Pattern \&gt;" alt="" coords="227,107,378,149"/>
<area shape="rect" id="node9" href="classreflex_1_1_pattern_matcher.html" title="reflex::PatternMatcher\l\&lt; std::regex \&gt;" alt="" coords="227,174,378,216"/>
<area shape="rect" id="node13" href="classreflex_1_1_line_matcher.html" title="Line matcher engine class implements reflex::PatternMatcher pattern matching interface with scan..." alt="" coords="236,240,369,267"/>
<area shape="rect" id="node14" href="classreflex_1_1_pattern_matcher.html" title="The pattern matcher class template extends abstract matcher base class. " alt="" coords="211,291,394,318"/>
<area shape="rect" id="node15" href="classreflex_1_1_pattern_matcher_3_01std_1_1string_01_4.html" title="A specialization of the pattern matcher class template for std::string, extends abstract matcher base..." alt="" coords="227,342,378,384"/>
<area shape="rect" id="node3" href="classreflex_1_1_boost_matcher.html" title="Boost matcher engine class implements reflex::PatternMatcher pattern matching interface with scan..." alt="" coords="448,48,590,75"/>
<area shape="rect" id="node4" href="classreflex_1_1_boost_perl_matcher.html" title="Boost matcher engine class, extends reflex::BoostMatcher for Boost Perl regex matching. " alt="" coords="650,5,816,32"/>
<area shape="rect" id="node5" href="classreflex_1_1_boost_posix_matcher.html" title="Boost matcher engine class, extends reflex::BoostMatcher for Boost POSIX regex matching. " alt="" coords="645,56,821,83"/>
<area shape="rect" id="node7" href="classreflex_1_1_matcher.html" title="RE/flex matcher engine class, implements reflex::PatternMatcher pattern matching interface with scan..." alt="" coords="465,115,573,142"/>
<area shape="rect" id="node8" href="classreflex_1_1_fuzzy_matcher.html" title="RE/flex fuzzy matcher engine class, implements reflex::Matcher fuzzy pattern matching interface with ..." alt="" coords="661,115,805,142"/>
<area shape="rect" id="node10" href="classreflex_1_1_std_matcher.html" title="std matcher engine class implements reflex::PatternMatcher pattern matching interface with scan..." alt="" coords="455,181,583,208"/>
<area shape="rect" id="node11" href="classreflex_1_1_std_ecma_matcher.html" title="std matcher engine class, extends reflex::StdMatcher for ECMA std::regex::ECMAScript syntax and regex..." alt="" coords="652,173,814,200"/>
<area shape="rect" id="node12" href="classreflex_1_1_std_posix_matcher.html" title="std matcher engine class, extends reflex::StdMatcher for POSIX ERE std::regex::awk syntax and regex m..." alt="" coords="652,224,814,251"/>
<area shape="rect" id="node16" href="classreflex_1_1_p_c_r_e2_matcher.html" title="PCRE2 JIT&#45;optimized matcher engine class implements reflex::PatternMatcher pattern matching interface..." alt="" coords="442,349,595,376"/>
<area shape="rect" id="node17" href="classreflex_1_1_p_c_r_e2_u_t_f_matcher.html" title="PCRE2 JIT&#45;optimized native PCRE2_UTF+PCRE2_UCP matcher engine class, extends PCRE2Matcher. " alt="" coords="643,349,823,376"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for reflex::AbstractMatcher:</div>
<div class="dyncontent">
<div class="center"><img src="classreflex_1_1_abstract_matcher__coll__graph.png" border="0" usemap="#reflex_1_1_abstract_matcher_coll__map" alt="Collaboration graph"/></div>
<map name="reflex_1_1_abstract_matcher_coll__map" id="reflex_1_1_abstract_matcher_coll__map">
<area shape="rect" id="node4" href="classreflex_1_1_abstract_matcher_1_1_operation.html" title="AbstractMatcher::Operation functor to match input to a pattern, also provides a (const) AbstractMatch..." alt="" coords="1293,71,1452,112"/>
<area shape="rect" id="node2" href="structreflex_1_1_abstract_matcher_1_1_handler.html" title="Event handler functor base class to invoke when the buffer contents are shifted out, e.g. for logging the data searched. " alt="" coords="787,5,945,47"/>
<area shape="rect" id="node3" href="structreflex_1_1_abstract_matcher_1_1_option.html" title="AbstractMatcher::Options for matcher engines. " alt="" coords="787,71,945,112"/>
<area shape="rect" id="node5" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. " alt="" coords="820,137,912,163"/>
<area shape="rect" id="node6" href="structreflex_1_1_input_1_1_handler.html" title="FILE* handler functor base class to handle FILE* errors and non&#45;blocking FILE* reads. " alt="" coords="537,111,683,138"/>
<area shape="rect" id="node7" title="STL class. " alt="" coords="565,162,655,189"/>
<area shape="rect" id="node8" title="STL class. " alt="" coords="359,155,488,196"/>
<area shape="rect" id="node9" title="STL class. " alt="" coords="155,162,309,189"/>
<area shape="rect" id="node10" title="STL class. " alt="" coords="5,162,105,189"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html">Const</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html" title="AbstractMatcher::Const common constants. ">AbstractMatcher::Const</a> common constants.  <a href="structreflex_1_1_abstract_matcher_1_1_const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreflex_1_1_abstract_matcher_1_1_context.html">Context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_abstract_matcher_1_1_context.html" title="Context returned by before() and after() ">Context</a> returned by <a class="el" href="classreflex_1_1_abstract_matcher.html#ae08cc80655fe7c723dd15da0ac80eb35" title="Get the buffered context before the matching line. ">before()</a> and <a class="el" href="classreflex_1_1_abstract_matcher.html#a1422cc4d5a78f997393081a1416b1f52" title="Get the buffered context after EOF is reached. ">after()</a>  <a href="structreflex_1_1_abstract_matcher_1_1_context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreflex_1_1_abstract_matcher_1_1_handler.html">Handler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event handler functor base class to invoke when the buffer contents are shifted out, e.g. for logging the data searched.  <a href="structreflex_1_1_abstract_matcher_1_1_handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher_1_1_iterator.html">Iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classreflex_1_1_abstract_matcher_1_1_iterator.html" title="AbstractMatcher::Iterator class for scanning, searching, and splitting input character sequences...">AbstractMatcher::Iterator</a> class for scanning, searching, and splitting input character sequences.  <a href="classreflex_1_1_abstract_matcher_1_1_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher_1_1_operation.html">Operation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classreflex_1_1_abstract_matcher_1_1_operation.html" title="AbstractMatcher::Operation functor to match input to a pattern, also provides a (const) AbstractMatch...">AbstractMatcher::Operation</a> functor to match input to a pattern, also provides a (const) <a class="el" href="classreflex_1_1_abstract_matcher.html#a7237c1fb8ab2a2283117739e6516c31f" title="std::input_iterator for scanning, searching, and splitting input character sequences ...">AbstractMatcher::iterator</a> to iterate over matches.  <a href="classreflex_1_1_abstract_matcher_1_1_operation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreflex_1_1_abstract_matcher_1_1_option.html">Option</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AbstractMatcher::Options for matcher engines.  <a href="structreflex_1_1_abstract_matcher_1_1_option.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7237c1fb8ab2a2283117739e6516c31f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classreflex_1_1_abstract_matcher_1_1_iterator.html">AbstractMatcher::Iterator</a>&lt; <a class="el" href="classreflex_1_1_abstract_matcher.html">AbstractMatcher</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a7237c1fb8ab2a2283117739e6516c31f">iterator</a></td></tr>
<tr class="memdesc:a7237c1fb8ab2a2283117739e6516c31f"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::input_iterator for scanning, searching, and splitting input character sequences  <a href="#a7237c1fb8ab2a2283117739e6516c31f">More...</a><br /></td></tr>
<tr class="separator:a7237c1fb8ab2a2283117739e6516c31f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24336f3d3f122aa0e904fc18954943f8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classreflex_1_1_abstract_matcher_1_1_iterator.html">AbstractMatcher::Iterator</a>&lt; const <a class="el" href="classreflex_1_1_abstract_matcher.html">AbstractMatcher</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a24336f3d3f122aa0e904fc18954943f8">const_iterator</a></td></tr>
<tr class="separator:a24336f3d3f122aa0e904fc18954943f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1678067737066140c605e4e2e65ad1bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a1678067737066140c605e4e2e65ad1bb">AbstractMatcher</a> (const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;<a class="el" href="classreflex_1_1_abstract_matcher.html#ab49c7878fc1d7c39e0ca264a5c919f08">input</a>, const char *opt)</td></tr>
<tr class="memdesc:a1678067737066140c605e4e2e65ad1bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a base abstract matcher.  <a href="#a1678067737066140c605e4e2e65ad1bb">More...</a><br /></td></tr>
<tr class="separator:a1678067737066140c605e4e2e65ad1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa845e2492e9dfae56e9192c8330143b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#afa845e2492e9dfae56e9192c8330143b">AbstractMatcher</a> (const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;<a class="el" href="classreflex_1_1_abstract_matcher.html#ab49c7878fc1d7c39e0ca264a5c919f08">input</a>, const <a class="el" href="structreflex_1_1_abstract_matcher_1_1_option.html">Option</a> &amp;opt)</td></tr>
<tr class="memdesc:afa845e2492e9dfae56e9192c8330143b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a base abstract matcher.  <a href="#afa845e2492e9dfae56e9192c8330143b">More...</a><br /></td></tr>
<tr class="separator:afa845e2492e9dfae56e9192c8330143b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1687bb274cfa3af4de2cc8f0e9fcd10d"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a1687bb274cfa3af4de2cc8f0e9fcd10d">~AbstractMatcher</a> ()</td></tr>
<tr class="memdesc:a1687bb274cfa3af4de2cc8f0e9fcd10d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete abstract matcher, deletes this matcher's internal buffer.  <a href="#a1687bb274cfa3af4de2cc8f0e9fcd10d">More...</a><br /></td></tr>
<tr class="separator:a1687bb274cfa3af4de2cc8f0e9fcd10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990b0f98e3b73ae3a2f4a9aa91626b8d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classreflex_1_1_abstract_matcher.html">AbstractMatcher</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a990b0f98e3b73ae3a2f4a9aa91626b8d">clone</a> ()=0</td></tr>
<tr class="memdesc:a990b0f98e3b73ae3a2f4a9aa91626b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic cloning.  <a href="#a990b0f98e3b73ae3a2f4a9aa91626b8d">More...</a><br /></td></tr>
<tr class="separator:a990b0f98e3b73ae3a2f4a9aa91626b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f487ab96e7cef1a66e9780dc45e315"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a66f487ab96e7cef1a66e9780dc45e315">reset</a> (const char *opt=NULL)</td></tr>
<tr class="memdesc:a66f487ab96e7cef1a66e9780dc45e315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset this matcher's state to the initial state and set options (when provided).  <a href="#a66f487ab96e7cef1a66e9780dc45e315">More...</a><br /></td></tr>
<tr class="separator:a66f487ab96e7cef1a66e9780dc45e315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb96965d228951194f0a2b9ee574dcf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a0fb96965d228951194f0a2b9ee574dcf">buffer</a> (size_t blk=0)</td></tr>
<tr class="memdesc:a0fb96965d228951194f0a2b9ee574dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set buffer block size for reading: use 0 (or omit argument) to buffer all input in which case returns true if all the data could be read and false if a read error occurred.  <a href="#a0fb96965d228951194f0a2b9ee574dcf">More...</a><br /></td></tr>
<tr class="separator:a0fb96965d228951194f0a2b9ee574dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7e85c26dc2e1252f8fb0511cf16067"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#aaf7e85c26dc2e1252f8fb0511cf16067">set_handler</a> (<a class="el" href="structreflex_1_1_abstract_matcher_1_1_handler.html">Handler</a> *handler)</td></tr>
<tr class="memdesc:aaf7e85c26dc2e1252f8fb0511cf16067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set event handler functor to invoke when the buffer contents are shifted out, e.g. for logging the data searched.  <a href="#aaf7e85c26dc2e1252f8fb0511cf16067">More...</a><br /></td></tr>
<tr class="separator:aaf7e85c26dc2e1252f8fb0511cf16067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa245e6bd153a154df15c6f9fb099cdbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#aa245e6bd153a154df15c6f9fb099cdbe">set_reserve</a> (size_t n)</td></tr>
<tr class="memdesc:aa245e6bd153a154df15c6f9fb099cdbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set reserved bytes for buffer shifting.  <a href="#aa245e6bd153a154df15c6f9fb099cdbe">More...</a><br /></td></tr>
<tr class="separator:aa245e6bd153a154df15c6f9fb099cdbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08cc80655fe7c723dd15da0ac80eb35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structreflex_1_1_abstract_matcher_1_1_context.html">Context</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ae08cc80655fe7c723dd15da0ac80eb35">before</a> ()</td></tr>
<tr class="memdesc:ae08cc80655fe7c723dd15da0ac80eb35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the buffered context before the matching line.  <a href="#ae08cc80655fe7c723dd15da0ac80eb35">More...</a><br /></td></tr>
<tr class="separator:ae08cc80655fe7c723dd15da0ac80eb35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1422cc4d5a78f997393081a1416b1f52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structreflex_1_1_abstract_matcher_1_1_context.html">Context</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a1422cc4d5a78f997393081a1416b1f52">after</a> ()</td></tr>
<tr class="memdesc:a1422cc4d5a78f997393081a1416b1f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the buffered context after EOF is reached.  <a href="#a1422cc4d5a78f997393081a1416b1f52">More...</a><br /></td></tr>
<tr class="separator:a1422cc4d5a78f997393081a1416b1f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1d22133cb4cf88f208c45ee8cdc0e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#acb1d22133cb4cf88f208c45ee8cdc0e0">interactive</a> ()</td></tr>
<tr class="memdesc:acb1d22133cb4cf88f208c45ee8cdc0e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interactive input with buffer size of 1 to read data bytewise which is very slow.  <a href="#acb1d22133cb4cf88f208c45ee8cdc0e0">More...</a><br /></td></tr>
<tr class="separator:acb1d22133cb4cf88f208c45ee8cdc0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acafc5782952bb1e80c7e5bf367ffc6af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#acafc5782952bb1e80c7e5bf367ffc6af">flush</a> ()</td></tr>
<tr class="memdesc:acafc5782952bb1e80c7e5bf367ffc6af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the buffer's remaining content.  <a href="#acafc5782952bb1e80c7e5bf367ffc6af">More...</a><br /></td></tr>
<tr class="separator:acafc5782952bb1e80c7e5bf367ffc6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92391ce2c5eab5a6dbce067a8326702e"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a92391ce2c5eab5a6dbce067a8326702e">get</a> (char *s, size_t n)</td></tr>
<tr class="memdesc:a92391ce2c5eab5a6dbce067a8326702e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns more input data directly from the source (method can be overriden, as by reflex::FlexLexer::get(s, n) for example that invokes reflex::FlexLexer::LexerInput(s, n)).  <a href="#a92391ce2c5eab5a6dbce067a8326702e">More...</a><br /></td></tr>
<tr class="separator:a92391ce2c5eab5a6dbce067a8326702e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046e0696b048d229ea2d77f5010c41e1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a046e0696b048d229ea2d77f5010c41e1">wrap</a> ()</td></tr>
<tr class="memdesc:a046e0696b048d229ea2d77f5010c41e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if wrapping of input after EOF is supported.  <a href="#a046e0696b048d229ea2d77f5010c41e1">More...</a><br /></td></tr>
<tr class="separator:a046e0696b048d229ea2d77f5010c41e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49c7878fc1d7c39e0ca264a5c919f08"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classreflex_1_1_abstract_matcher.html">AbstractMatcher</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ab49c7878fc1d7c39e0ca264a5c919f08">input</a> (const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;input)</td></tr>
<tr class="memdesc:ab49c7878fc1d7c39e0ca264a5c919f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the input character sequence for this matcher and reset/restart the matcher.  <a href="#ab49c7878fc1d7c39e0ca264a5c919f08">More...</a><br /></td></tr>
<tr class="separator:ab49c7878fc1d7c39e0ca264a5c919f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3939efa95649d0b8543109669818a097"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_matcher.html">AbstractMatcher</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a3939efa95649d0b8543109669818a097">buffer</a> (char *base, size_t <a class="el" href="classreflex_1_1_abstract_matcher.html#adb5fec59e6c6a86b8cf405c40f93d1de">size</a>)</td></tr>
<tr class="memdesc:a3939efa95649d0b8543109669818a097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the buffer base containing 0-terminated character data to scan in place (data may be modified), reset/restart the matcher.  <a href="#a3939efa95649d0b8543109669818a097">More...</a><br /></td></tr>
<tr class="separator:a3939efa95649d0b8543109669818a097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab880e6c8fe0df7c4ee7bb629aab41d0f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ab880e6c8fe0df7c4ee7bb629aab41d0f">matches</a> ()</td></tr>
<tr class="memdesc:ab880e6c8fe0df7c4ee7bb629aab41d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns nonzero capture index (i.e. true) if the entire input matches this matcher's pattern (and internally caches the true/false result to permit repeat invocations).  <a href="#ab880e6c8fe0df7c4ee7bb629aab41d0f">More...</a><br /></td></tr>
<tr class="separator:ab880e6c8fe0df7c4ee7bb629aab41d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51252ce359e6106b58c81f70776ccfb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#af51252ce359e6106b58c81f70776ccfb">accept</a> () const </td></tr>
<tr class="memdesc:af51252ce359e6106b58c81f70776ccfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a positive integer (true) indicating the capture index of the matched text in the pattern or zero (false) for a mismatch.  <a href="#af51252ce359e6106b58c81f70776ccfb">More...</a><br /></td></tr>
<tr class="separator:af51252ce359e6106b58c81f70776ccfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329001b2880a756dd4d6f6fd0192d004"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a329001b2880a756dd4d6f6fd0192d004">begin</a> () const </td></tr>
<tr class="memdesc:a329001b2880a756dd4d6f6fd0192d004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the begin of the matched text (non-0-terminated), a constant-time operation, use with <a class="el" href="classreflex_1_1_abstract_matcher.html#aaf1c25cf25951b7eeda7aa50d4736fd4" title="Returns pointer to the exclusive end of the matched text, a constant-time operation. ">end()</a> or use <a class="el" href="classreflex_1_1_abstract_matcher.html#adb5fec59e6c6a86b8cf405c40f93d1de" title="Returns the length of the matched text in number of bytes, including pattern-matched \0s...">size()</a> for text end/length.  <a href="#a329001b2880a756dd4d6f6fd0192d004">More...</a><br /></td></tr>
<tr class="separator:a329001b2880a756dd4d6f6fd0192d004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1c25cf25951b7eeda7aa50d4736fd4"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#aaf1c25cf25951b7eeda7aa50d4736fd4">end</a> () const </td></tr>
<tr class="memdesc:aaf1c25cf25951b7eeda7aa50d4736fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the exclusive end of the matched text, a constant-time operation.  <a href="#aaf1c25cf25951b7eeda7aa50d4736fd4">More...</a><br /></td></tr>
<tr class="separator:aaf1c25cf25951b7eeda7aa50d4736fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009bad2d87f9bc2f18a9ae52cc08b9e1"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1">text</a> ()</td></tr>
<tr class="memdesc:a009bad2d87f9bc2f18a9ae52cc08b9e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 0-terminated pattern match as a char pointer, does not include matched \0s, this is a constant-time operation.  <a href="#a009bad2d87f9bc2f18a9ae52cc08b9e1">More...</a><br /></td></tr>
<tr class="separator:a009bad2d87f9bc2f18a9ae52cc08b9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1d2913a158699703eee6d5f603701b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a9c1d2913a158699703eee6d5f603701b">str</a> () const </td></tr>
<tr class="memdesc:a9c1d2913a158699703eee6d5f603701b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the text matched as a string, a copy of <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated pattern match as a char pointer, does not include matched \0s, this is a constant-time operation. ">text()</a>, may include pattern-matched \0s.  <a href="#a9c1d2913a158699703eee6d5f603701b">More...</a><br /></td></tr>
<tr class="separator:a9c1d2913a158699703eee6d5f603701b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28cef361d991985fc4b28166d91ee15d"><td class="memItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a28cef361d991985fc4b28166d91ee15d">wstr</a> () const </td></tr>
<tr class="memdesc:a28cef361d991985fc4b28166d91ee15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pattern match as a wide string, converted from UTF-8 <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated pattern match as a char pointer, does not include matched \0s, this is a constant-time operation. ">text()</a>, may include pattern-matched \0s.  <a href="#a28cef361d991985fc4b28166d91ee15d">More...</a><br /></td></tr>
<tr class="separator:a28cef361d991985fc4b28166d91ee15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb5fec59e6c6a86b8cf405c40f93d1de"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#adb5fec59e6c6a86b8cf405c40f93d1de">size</a> () const </td></tr>
<tr class="memdesc:adb5fec59e6c6a86b8cf405c40f93d1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the matched text in number of bytes, including pattern-matched \0s, a constant-time operation.  <a href="#adb5fec59e6c6a86b8cf405c40f93d1de">More...</a><br /></td></tr>
<tr class="separator:adb5fec59e6c6a86b8cf405c40f93d1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4bcff50974291fa01d4f7f7db4c77f5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#af4bcff50974291fa01d4f7f7db4c77f5">wsize</a> () const </td></tr>
<tr class="memdesc:af4bcff50974291fa01d4f7f7db4c77f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the matched text in number of wide characters.  <a href="#af4bcff50974291fa01d4f7f7db4c77f5">More...</a><br /></td></tr>
<tr class="separator:af4bcff50974291fa01d4f7f7db4c77f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e24702dba5c0c15e5f680b174a4758"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a12e24702dba5c0c15e5f680b174a4758">chr</a> () const </td></tr>
<tr class="memdesc:a12e24702dba5c0c15e5f680b174a4758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first 8-bit character of the text matched.  <a href="#a12e24702dba5c0c15e5f680b174a4758">More...</a><br /></td></tr>
<tr class="separator:a12e24702dba5c0c15e5f680b174a4758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b7e09cf2e74ffbf09fb65ebac337f5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#aa1b7e09cf2e74ffbf09fb65ebac337f5">wchr</a> () const </td></tr>
<tr class="memdesc:aa1b7e09cf2e74ffbf09fb65ebac337f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first wide character of the text matched.  <a href="#aa1b7e09cf2e74ffbf09fb65ebac337f5">More...</a><br /></td></tr>
<tr class="separator:aa1b7e09cf2e74ffbf09fb65ebac337f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a69f32040ea02b605f6fa0f31af0be7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a3a69f32040ea02b605f6fa0f31af0be7">lineno_skip</a> (bool f=false)</td></tr>
<tr class="memdesc:a3a69f32040ea02b605f6fa0f31af0be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set or reset mode to count matching lines only and skip other (e.g. for speed).  <a href="#a3a69f32040ea02b605f6fa0f31af0be7">More...</a><br /></td></tr>
<tr class="separator:a3a69f32040ea02b605f6fa0f31af0be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3812c606737fdf861eb64023e9e9cec6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a3812c606737fdf861eb64023e9e9cec6">lineno</a> (size_t n)</td></tr>
<tr class="memdesc:a3812c606737fdf861eb64023e9e9cec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set or change the starting line number of the last match.  <a href="#a3812c606737fdf861eb64023e9e9cec6">More...</a><br /></td></tr>
<tr class="separator:a3812c606737fdf861eb64023e9e9cec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbfcc6386048d9c3613f7de919ba242"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a3bbfcc6386048d9c3613f7de919ba242">lineno</a> ()</td></tr>
<tr class="memdesc:a3bbfcc6386048d9c3613f7de919ba242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates and returns the starting line number of the match in the input character sequence.  <a href="#a3bbfcc6386048d9c3613f7de919ba242">More...</a><br /></td></tr>
<tr class="separator:a3bbfcc6386048d9c3613f7de919ba242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1258c856660344404af7e2019450c727"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a1258c856660344404af7e2019450c727">lines</a> ()</td></tr>
<tr class="memdesc:a1258c856660344404af7e2019450c727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of lines that the match spans.  <a href="#a1258c856660344404af7e2019450c727">More...</a><br /></td></tr>
<tr class="separator:a1258c856660344404af7e2019450c727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa822685ae6ffae7283a9ea1dbfe5899d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#aa822685ae6ffae7283a9ea1dbfe5899d">lineno_end</a> ()</td></tr>
<tr class="memdesc:aa822685ae6ffae7283a9ea1dbfe5899d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inclusive ending line number of the match in the input character sequence.  <a href="#aa822685ae6ffae7283a9ea1dbfe5899d">More...</a><br /></td></tr>
<tr class="separator:aa822685ae6ffae7283a9ea1dbfe5899d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab566032e82437721d590250b358d5704"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ab566032e82437721d590250b358d5704">columno</a> (size_t n)</td></tr>
<tr class="memdesc:ab566032e82437721d590250b358d5704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set or change the starting column number of the last match.  <a href="#ab566032e82437721d590250b358d5704">More...</a><br /></td></tr>
<tr class="separator:ab566032e82437721d590250b358d5704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51527a637b1964627dd34c722d905b65"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a51527a637b1964627dd34c722d905b65">columno</a> ()</td></tr>
<tr class="memdesc:a51527a637b1964627dd34c722d905b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates and returns the starting column number of the matched text, taking tab spacing into account and counting wide characters as one character each.  <a href="#a51527a637b1964627dd34c722d905b65">More...</a><br /></td></tr>
<tr class="separator:a51527a637b1964627dd34c722d905b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84fe081ea4237a44ea659c5400fffccd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a84fe081ea4237a44ea659c5400fffccd">columns</a> ()</td></tr>
<tr class="memdesc:a84fe081ea4237a44ea659c5400fffccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of columns of the matched text, taking tab spacing into account and counting wide characters as one character each.  <a href="#a84fe081ea4237a44ea659c5400fffccd">More...</a><br /></td></tr>
<tr class="separator:a84fe081ea4237a44ea659c5400fffccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47d0699975797b828b3a8e1a5470ec2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#af47d0699975797b828b3a8e1a5470ec2">columno_end</a> ()</td></tr>
<tr class="memdesc:af47d0699975797b828b3a8e1a5470ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inclusive ending column number of the matched text on the ending matching line, taking tab spacing into account and counting wide characters as one character each.  <a href="#af47d0699975797b828b3a8e1a5470ec2">More...</a><br /></td></tr>
<tr class="separator:af47d0699975797b828b3a8e1a5470ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc573eafc849b275d21b114abe1ea570"><td class="memItemLeft" align="right" valign="top">std::pair&lt; size_t, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#abc573eafc849b275d21b114abe1ea570">pair</a> () const </td></tr>
<tr class="memdesc:abc573eafc849b275d21b114abe1ea570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns std::pair&lt;size_t,std::string&gt;(<a class="el" href="classreflex_1_1_abstract_matcher.html#af51252ce359e6106b58c81f70776ccfb" title="Returns a positive integer (true) indicating the capture index of the matched text in the pattern or ...">accept()</a>, <a class="el" href="classreflex_1_1_abstract_matcher.html#a9c1d2913a158699703eee6d5f603701b" title="Returns the text matched as a string, a copy of text(), may include pattern-matched \0s...">str()</a>), useful for tokenizing input into containers of pairs.  <a href="#abc573eafc849b275d21b114abe1ea570">More...</a><br /></td></tr>
<tr class="separator:abc573eafc849b275d21b114abe1ea570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51a6d149b4147a1ac7d64b2d6587bd3"><td class="memItemLeft" align="right" valign="top">std::pair&lt; size_t, std::wstring &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ae51a6d149b4147a1ac7d64b2d6587bd3">wpair</a> () const </td></tr>
<tr class="memdesc:ae51a6d149b4147a1ac7d64b2d6587bd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns std::pair&lt;size_t,std::wstring&gt;(<a class="el" href="classreflex_1_1_abstract_matcher.html#af51252ce359e6106b58c81f70776ccfb" title="Returns a positive integer (true) indicating the capture index of the matched text in the pattern or ...">accept()</a>, <a class="el" href="classreflex_1_1_abstract_matcher.html#a28cef361d991985fc4b28166d91ee15d" title="Returns the pattern match as a wide string, converted from UTF-8 text(), may include pattern-matched ...">wstr()</a>), useful for tokenizing input into containers of pairs.  <a href="#ae51a6d149b4147a1ac7d64b2d6587bd3">More...</a><br /></td></tr>
<tr class="separator:ae51a6d149b4147a1ac7d64b2d6587bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112117a78682b9634806158e018dc6b4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a112117a78682b9634806158e018dc6b4">first</a> () const </td></tr>
<tr class="memdesc:a112117a78682b9634806158e018dc6b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of the first character of the match in the input character sequence, a constant-time operation.  <a href="#a112117a78682b9634806158e018dc6b4">More...</a><br /></td></tr>
<tr class="separator:a112117a78682b9634806158e018dc6b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7840043710c3c45820390480c8f42315"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a7840043710c3c45820390480c8f42315">last</a> () const </td></tr>
<tr class="memdesc:a7840043710c3c45820390480c8f42315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the exclusive position of the last character of the match in the input character sequence, a constant-time operation.  <a href="#a7840043710c3c45820390480c8f42315">More...</a><br /></td></tr>
<tr class="separator:a7840043710c3c45820390480c8f42315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a146013ac9f6dcb1af9edef6ee5f3dc58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a146013ac9f6dcb1af9edef6ee5f3dc58">at_bob</a> () const </td></tr>
<tr class="memdesc:a146013ac9f6dcb1af9edef6ee5f3dc58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this matcher is at the start of a buffer to read an input character sequence. Use <a class="el" href="classreflex_1_1_abstract_matcher.html#a66f487ab96e7cef1a66e9780dc45e315" title="Reset this matcher&#39;s state to the initial state and set options (when provided). ">reset()</a> to restart reading new input.  <a href="#a146013ac9f6dcb1af9edef6ee5f3dc58">More...</a><br /></td></tr>
<tr class="separator:a146013ac9f6dcb1af9edef6ee5f3dc58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0b546187f2ad8f6d7f39207e683a7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a8e0b546187f2ad8f6d7f39207e683a7f">set_bob</a> (bool bob)</td></tr>
<tr class="memdesc:a8e0b546187f2ad8f6d7f39207e683a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set/reset the begin of a buffer state.  <a href="#a8e0b546187f2ad8f6d7f39207e683a7f">More...</a><br /></td></tr>
<tr class="separator:a8e0b546187f2ad8f6d7f39207e683a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac843ab490d5ad9ba71a96c3b323eba19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ac843ab490d5ad9ba71a96c3b323eba19">at_end</a> ()</td></tr>
<tr class="memdesc:ac843ab490d5ad9ba71a96c3b323eba19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this matcher has no more input to read from the input character sequence.  <a href="#ac843ab490d5ad9ba71a96c3b323eba19">More...</a><br /></td></tr>
<tr class="separator:ac843ab490d5ad9ba71a96c3b323eba19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5ec19555d6e0f4a8210651f9343987"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#afb5ec19555d6e0f4a8210651f9343987">hit_end</a> () const </td></tr>
<tr class="memdesc:afb5ec19555d6e0f4a8210651f9343987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this matcher hit the end of the input character sequence.  <a href="#afb5ec19555d6e0f4a8210651f9343987">More...</a><br /></td></tr>
<tr class="separator:afb5ec19555d6e0f4a8210651f9343987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6dcc2b180a7139b52a6bfe1ebabf1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#aec6dcc2b180a7139b52a6bfe1ebabf1b">set_end</a> (bool eof)</td></tr>
<tr class="memdesc:aec6dcc2b180a7139b52a6bfe1ebabf1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set and force the end of input state.  <a href="#aec6dcc2b180a7139b52a6bfe1ebabf1b">More...</a><br /></td></tr>
<tr class="separator:aec6dcc2b180a7139b52a6bfe1ebabf1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240d7d235b5a1d7aa32d464891cb96a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a240d7d235b5a1d7aa32d464891cb96a5">at_bol</a> () const </td></tr>
<tr class="memdesc:a240d7d235b5a1d7aa32d464891cb96a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this matcher reached the begin of a new line.  <a href="#a240d7d235b5a1d7aa32d464891cb96a5">More...</a><br /></td></tr>
<tr class="separator:a240d7d235b5a1d7aa32d464891cb96a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0860fa58e41f5a0d7e74d1fe33559df3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a0860fa58e41f5a0d7e74d1fe33559df3">set_bol</a> (bool <a class="el" href="classreflex_1_1_abstract_matcher.html#a640e70bf23e06e40ae52cadea0ecf19a">bol</a>)</td></tr>
<tr class="memdesc:a0860fa58e41f5a0d7e74d1fe33559df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set/reset the begin of a new line state.  <a href="#a0860fa58e41f5a0d7e74d1fe33559df3">More...</a><br /></td></tr>
<tr class="separator:a0860fa58e41f5a0d7e74d1fe33559df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2eb7cb29b0fd2c87aade0db5b3ab10"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a4d2eb7cb29b0fd2c87aade0db5b3ab10">at_bow</a> ()</td></tr>
<tr class="memdesc:a4d2eb7cb29b0fd2c87aade0db5b3ab10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this matcher matched text that begins an ASCII word.  <a href="#a4d2eb7cb29b0fd2c87aade0db5b3ab10">More...</a><br /></td></tr>
<tr class="separator:a4d2eb7cb29b0fd2c87aade0db5b3ab10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17b43ef74d35dc503f8057ec410a3fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ac17b43ef74d35dc503f8057ec410a3fa">at_eow</a> ()</td></tr>
<tr class="memdesc:ac17b43ef74d35dc503f8057ec410a3fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this matcher matched text that ends an ASCII word.  <a href="#ac17b43ef74d35dc503f8057ec410a3fa">More...</a><br /></td></tr>
<tr class="separator:ac17b43ef74d35dc503f8057ec410a3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827817fd1ed8edbe8eec84eeefa8a88e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a827817fd1ed8edbe8eec84eeefa8a88e">input</a> ()</td></tr>
<tr class="memdesc:a827817fd1ed8edbe8eec84eeefa8a88e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next 8-bit character (unsigned char 0..255 or EOF) from the input character sequence, while preserving the current <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated pattern match as a char pointer, does not include matched \0s, this is a constant-time operation. ">text()</a> match (but pointer returned by <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated pattern match as a char pointer, does not include matched \0s, this is a constant-time operation. ">text()</a> may change; warning: does not preserve the yytext string pointer when options &ndash;flex and &ndash;bison are used).  <a href="#a827817fd1ed8edbe8eec84eeefa8a88e">More...</a><br /></td></tr>
<tr class="separator:a827817fd1ed8edbe8eec84eeefa8a88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee94acd13edc05acfa087499d650a8f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a6ee94acd13edc05acfa087499d650a8f">winput</a> ()</td></tr>
<tr class="memdesc:a6ee94acd13edc05acfa087499d650a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next wide character (unsigned 0..U+10FFFF or EOF) from the input character sequence, while preserving the current <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated pattern match as a char pointer, does not include matched \0s, this is a constant-time operation. ">text()</a> match (but pointer returned by <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated pattern match as a char pointer, does not include matched \0s, this is a constant-time operation. ">text()</a> may change; warning: does not preserve the yytext string pointer when options &ndash;flex and &ndash;bison are used).  <a href="#a6ee94acd13edc05acfa087499d650a8f">More...</a><br /></td></tr>
<tr class="separator:a6ee94acd13edc05acfa087499d650a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb536d7812fcf52017e9d452e96381a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a5fb536d7812fcf52017e9d452e96381a">unput</a> (char c)</td></tr>
<tr class="memdesc:a5fb536d7812fcf52017e9d452e96381a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put back one character (8-bit) on the input character sequence for matching, DANGER: invalidates the previous <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated pattern match as a char pointer, does not include matched \0s, this is a constant-time operation. ">text()</a> pointer and match info, unput is not honored when matching in-place using buffer(base, size) and nothing has been read yet.  <a href="#a5fb536d7812fcf52017e9d452e96381a">More...</a><br /></td></tr>
<tr class="separator:a5fb536d7812fcf52017e9d452e96381a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd671ea3d606cab955cf6353267f62fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#abd671ea3d606cab955cf6353267f62fa">wunput</a> (int c)</td></tr>
<tr class="memdesc:abd671ea3d606cab955cf6353267f62fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put back one (wide) character on the input character sequence for matching, DANGER: invalidates the previous <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated pattern match as a char pointer, does not include matched \0s, this is a constant-time operation. ">text()</a> pointer and match info, unput is not honored when matching in-place using buffer(base, size) and nothing has been read yet.  <a href="#abd671ea3d606cab955cf6353267f62fa">More...</a><br /></td></tr>
<tr class="separator:abd671ea3d606cab955cf6353267f62fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8a8eff9fc980c7028c9399a1310849"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#acb8a8eff9fc980c7028c9399a1310849">peek</a> ()</td></tr>
<tr class="memdesc:acb8a8eff9fc980c7028c9399a1310849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek at the next character available for reading from the current input source.  <a href="#acb8a8eff9fc980c7028c9399a1310849">More...</a><br /></td></tr>
<tr class="separator:acb8a8eff9fc980c7028c9399a1310849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640e70bf23e06e40ae52cadea0ecf19a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a640e70bf23e06e40ae52cadea0ecf19a">bol</a> ()</td></tr>
<tr class="memdesc:a640e70bf23e06e40ae52cadea0ecf19a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the begin of the line in the buffer containing the matched text.  <a href="#a640e70bf23e06e40ae52cadea0ecf19a">More...</a><br /></td></tr>
<tr class="separator:a640e70bf23e06e40ae52cadea0ecf19a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5244017d854301305afbf8326c9e98"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a7b5244017d854301305afbf8326c9e98">eol</a> (bool inclusive=false)</td></tr>
<tr class="memdesc:a7b5244017d854301305afbf8326c9e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the end of the line (last char + 1) in the buffer containing the matched text, DANGER: invalidates previous <a class="el" href="classreflex_1_1_abstract_matcher.html#a640e70bf23e06e40ae52cadea0ecf19a" title="Returns pointer to the begin of the line in the buffer containing the matched text. ">bol()</a> and <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated pattern match as a char pointer, does not include matched \0s, this is a constant-time operation. ">text()</a> pointers, use <a class="el" href="classreflex_1_1_abstract_matcher.html#a7b5244017d854301305afbf8326c9e98" title="Returns pointer to the end of the line (last char + 1) in the buffer containing the matched text...">eol()</a> before <a class="el" href="classreflex_1_1_abstract_matcher.html#a640e70bf23e06e40ae52cadea0ecf19a" title="Returns pointer to the begin of the line in the buffer containing the matched text. ">bol()</a>, <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated pattern match as a char pointer, does not include matched \0s, this is a constant-time operation. ">text()</a>, <a class="el" href="classreflex_1_1_abstract_matcher.html#a329001b2880a756dd4d6f6fd0192d004" title="Returns pointer to the begin of the matched text (non-0-terminated), a constant-time operation...">begin()</a>, and <a class="el" href="classreflex_1_1_abstract_matcher.html#aaf1c25cf25951b7eeda7aa50d4736fd4" title="Returns pointer to the exclusive end of the matched text, a constant-time operation. ">end()</a> when those are used.  <a href="#a7b5244017d854301305afbf8326c9e98">More...</a><br /></td></tr>
<tr class="separator:a7b5244017d854301305afbf8326c9e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ce5aac6ad3a5b9ec8bc04b9c6f9fa1"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#af3ce5aac6ad3a5b9ec8bc04b9c6f9fa1">aft</a> (size_t len)</td></tr>
<tr class="memdesc:af3ce5aac6ad3a5b9ec8bc04b9c6f9fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to the end of the match + len after, or at end of file, DANGER: invalidates previous <a class="el" href="classreflex_1_1_abstract_matcher.html#a640e70bf23e06e40ae52cadea0ecf19a" title="Returns pointer to the begin of the line in the buffer containing the matched text. ">bol()</a> and <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated pattern match as a char pointer, does not include matched \0s, this is a constant-time operation. ">text()</a> pointers, use <a class="el" href="classreflex_1_1_abstract_matcher.html#af3ce5aac6ad3a5b9ec8bc04b9c6f9fa1" title="Return pointer to the end of the match + len after, or at end of file, DANGER: invalidates previous b...">aft()</a> before <a class="el" href="classreflex_1_1_abstract_matcher.html#a640e70bf23e06e40ae52cadea0ecf19a" title="Returns pointer to the begin of the line in the buffer containing the matched text. ">bol()</a>, <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated pattern match as a char pointer, does not include matched \0s, this is a constant-time operation. ">text()</a>, <a class="el" href="classreflex_1_1_abstract_matcher.html#a329001b2880a756dd4d6f6fd0192d004" title="Returns pointer to the begin of the matched text (non-0-terminated), a constant-time operation...">begin()</a>, and <a class="el" href="classreflex_1_1_abstract_matcher.html#aaf1c25cf25951b7eeda7aa50d4736fd4" title="Returns pointer to the exclusive end of the matched text, a constant-time operation. ">end()</a> when those are used.  <a href="#af3ce5aac6ad3a5b9ec8bc04b9c6f9fa1">More...</a><br /></td></tr>
<tr class="separator:af3ce5aac6ad3a5b9ec8bc04b9c6f9fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a49dd953a2b4f15091a33466d37a613"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a9a49dd953a2b4f15091a33466d37a613">bef</a> (size_t len)</td></tr>
<tr class="memdesc:a9a49dd953a2b4f15091a33466d37a613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to the begin of the match - len before, or at the begin of the file.  <a href="#a9a49dd953a2b4f15091a33466d37a613">More...</a><br /></td></tr>
<tr class="separator:a9a49dd953a2b4f15091a33466d37a613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71eb02005f4225d04a39c112296a000"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ac71eb02005f4225d04a39c112296a000">fetch</a> (size_t len)</td></tr>
<tr class="memdesc:ac71eb02005f4225d04a39c112296a000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of bytes available given number of bytes to fetch ahead, limited by input size and buffer size, DANGER: invalidates previous <a class="el" href="classreflex_1_1_abstract_matcher.html#a640e70bf23e06e40ae52cadea0ecf19a" title="Returns pointer to the begin of the line in the buffer containing the matched text. ">bol()</a> and <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated pattern match as a char pointer, does not include matched \0s, this is a constant-time operation. ">text()</a> pointers, use <a class="el" href="classreflex_1_1_abstract_matcher.html#ac71eb02005f4225d04a39c112296a000" title="Return number of bytes available given number of bytes to fetch ahead, limited by input size and buff...">fetch()</a> before <a class="el" href="classreflex_1_1_abstract_matcher.html#a640e70bf23e06e40ae52cadea0ecf19a" title="Returns pointer to the begin of the line in the buffer containing the matched text. ">bol()</a>, <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated pattern match as a char pointer, does not include matched \0s, this is a constant-time operation. ">text()</a>, <a class="el" href="classreflex_1_1_abstract_matcher.html#a329001b2880a756dd4d6f6fd0192d004" title="Returns pointer to the begin of the matched text (non-0-terminated), a constant-time operation...">begin()</a>, and <a class="el" href="classreflex_1_1_abstract_matcher.html#aaf1c25cf25951b7eeda7aa50d4736fd4" title="Returns pointer to the exclusive end of the matched text, a constant-time operation. ">end()</a> when those are used.  <a href="#ac71eb02005f4225d04a39c112296a000">More...</a><br /></td></tr>
<tr class="separator:ac71eb02005f4225d04a39c112296a000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c8231e2a0fbf53aa188448c9f9b229"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a66c8231e2a0fbf53aa188448c9f9b229">avail</a> ()</td></tr>
<tr class="memdesc:a66c8231e2a0fbf53aa188448c9f9b229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes in the buffer available to search from the current <a class="el" href="classreflex_1_1_abstract_matcher.html#a329001b2880a756dd4d6f6fd0192d004" title="Returns pointer to the begin of the matched text (non-0-terminated), a constant-time operation...">begin()</a>/text() position.  <a href="#a66c8231e2a0fbf53aa188448c9f9b229">More...</a><br /></td></tr>
<tr class="separator:a66c8231e2a0fbf53aa188448c9f9b229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc9812e0bdaadc404a962754ce11226"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a1cc9812e0bdaadc404a962754ce11226">border</a> ()</td></tr>
<tr class="memdesc:a1cc9812e0bdaadc404a962754ce11226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the byte offset of the match from the start of the line.  <a href="#a1cc9812e0bdaadc404a962754ce11226">More...</a><br /></td></tr>
<tr class="separator:a1cc9812e0bdaadc404a962754ce11226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771e92db1fbe8cc7dfdd5d4972e7679a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a771e92db1fbe8cc7dfdd5d4972e7679a">span</a> ()</td></tr>
<tr class="memdesc:a771e92db1fbe8cc7dfdd5d4972e7679a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enlarge the match to span the entire line of input (excluding <br />
), return <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated pattern match as a char pointer, does not include matched \0s, this is a constant-time operation. ">text()</a>.  <a href="#a771e92db1fbe8cc7dfdd5d4972e7679a">More...</a><br /></td></tr>
<tr class="separator:a771e92db1fbe8cc7dfdd5d4972e7679a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017eccee23af26c81f8f91be878c4711"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a017eccee23af26c81f8f91be878c4711">line</a> ()</td></tr>
<tr class="memdesc:a017eccee23af26c81f8f91be878c4711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the line of input (excluding <br />
) as a string containing the matched text as a substring.  <a href="#a017eccee23af26c81f8f91be878c4711">More...</a><br /></td></tr>
<tr class="separator:a017eccee23af26c81f8f91be878c4711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e5d61efacabcb1807922e2d9404a1b"><td class="memItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a95e5d61efacabcb1807922e2d9404a1b">wline</a> ()</td></tr>
<tr class="memdesc:a95e5d61efacabcb1807922e2d9404a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the line of input (excluding <br />
) as a wide string containing the matched text as a substring.  <a href="#a95e5d61efacabcb1807922e2d9404a1b">More...</a><br /></td></tr>
<tr class="separator:a95e5d61efacabcb1807922e2d9404a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a0eec56234f6a9bf41ccac081eefcc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ae2a0eec56234f6a9bf41ccac081eefcc">skip</a> (char c)</td></tr>
<tr class="memdesc:ae2a0eec56234f6a9bf41ccac081eefcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip input until the specified ASCII character is consumed and return true, or EOF is reached and return false.  <a href="#ae2a0eec56234f6a9bf41ccac081eefcc">More...</a><br /></td></tr>
<tr class="separator:ae2a0eec56234f6a9bf41ccac081eefcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70edc517e887a9e5ce6c84b0f9cd2bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#af70edc517e887a9e5ce6c84b0f9cd2bb">skip</a> (wchar_t c)</td></tr>
<tr class="memdesc:af70edc517e887a9e5ce6c84b0f9cd2bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip input until the specified <a class="el" href="namespacereflex_1_1_unicode.html">Unicode</a> character is consumed and return true, or EOF is reached and return false.  <a href="#af70edc517e887a9e5ce6c84b0f9cd2bb">More...</a><br /></td></tr>
<tr class="separator:af70edc517e887a9e5ce6c84b0f9cd2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd635f7dd7cedc5178f0c200ae154b6b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#acd635f7dd7cedc5178f0c200ae154b6b">skip</a> (const char *s)</td></tr>
<tr class="memdesc:acd635f7dd7cedc5178f0c200ae154b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip input until the specified literal UTF-8 string is consumed and return true, or EOF is reached and return false.  <a href="#acd635f7dd7cedc5178f0c200ae154b6b">More...</a><br /></td></tr>
<tr class="separator:acd635f7dd7cedc5178f0c200ae154b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39dc592de42a7e044296f03bee4fdb3"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ab39dc592de42a7e044296f03bee4fdb3">rest</a> ()</td></tr>
<tr class="memdesc:ab39dc592de42a7e044296f03bee4fdb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the rest of the input as text, useful for searching/splitting up to n times after which the rest is needed.  <a href="#ab39dc592de42a7e044296f03bee4fdb3">More...</a><br /></td></tr>
<tr class="separator:ab39dc592de42a7e044296f03bee4fdb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9577e765c5c1be82cb3f9b0ccdaf633f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a9577e765c5c1be82cb3f9b0ccdaf633f">more</a> ()</td></tr>
<tr class="memdesc:a9577e765c5c1be82cb3f9b0ccdaf633f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the next match to the currently matched text returned by <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated pattern match as a char pointer, does not include matched \0s, this is a constant-time operation. ">AbstractMatcher::text</a>, when the next match found is adjacent to the current match.  <a href="#a9577e765c5c1be82cb3f9b0ccdaf633f">More...</a><br /></td></tr>
<tr class="separator:a9577e765c5c1be82cb3f9b0ccdaf633f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ca0aa2d6ff88ac26f565ec5660787a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a12ca0aa2d6ff88ac26f565ec5660787a">less</a> (size_t n)</td></tr>
<tr class="memdesc:a12ca0aa2d6ff88ac26f565ec5660787a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate the <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated pattern match as a char pointer, does not include matched \0s, this is a constant-time operation. ">AbstractMatcher::text</a> length of the match to n characters in length and reposition for next match.  <a href="#a12ca0aa2d6ff88ac26f565ec5660787a">More...</a><br /></td></tr>
<tr class="separator:a12ca0aa2d6ff88ac26f565ec5660787a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8cd6c7fde713a5ac68ec168291e03e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a2e8cd6c7fde713a5ac68ec168291e03e">operator size_t</a> () const </td></tr>
<tr class="memdesc:a2e8cd6c7fde713a5ac68ec168291e03e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast this matcher to positive integer indicating the nonzero capture index of the matched text in the pattern, same as <a class="el" href="classreflex_1_1_abstract_matcher.html#af51252ce359e6106b58c81f70776ccfb" title="Returns a positive integer (true) indicating the capture index of the matched text in the pattern or ...">AbstractMatcher::accept</a>.  <a href="#a2e8cd6c7fde713a5ac68ec168291e03e">More...</a><br /></td></tr>
<tr class="separator:a2e8cd6c7fde713a5ac68ec168291e03e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360028bf97e0da02f6ffbcae031f9f35"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a360028bf97e0da02f6ffbcae031f9f35">operator std::string</a> () const </td></tr>
<tr class="memdesc:a360028bf97e0da02f6ffbcae031f9f35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast this matcher to a std::string of the text matched by this matcher.  <a href="#a360028bf97e0da02f6ffbcae031f9f35">More...</a><br /></td></tr>
<tr class="separator:a360028bf97e0da02f6ffbcae031f9f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1c0ee67ce2062f8c1c518170cd2a74"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#aab1c0ee67ce2062f8c1c518170cd2a74">operator std::wstring</a> () const </td></tr>
<tr class="memdesc:aab1c0ee67ce2062f8c1c518170cd2a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast this matcher to a std::wstring of the text matched by this matcher.  <a href="#aab1c0ee67ce2062f8c1c518170cd2a74">More...</a><br /></td></tr>
<tr class="separator:aab1c0ee67ce2062f8c1c518170cd2a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aeee06821a94df33a8c531d3913a5d7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a6aeee06821a94df33a8c531d3913a5d7">operator std::pair&lt; size_t, std::string &gt;</a> () const </td></tr>
<tr class="memdesc:a6aeee06821a94df33a8c531d3913a5d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast the match to std::pair&lt;size_t,std::wstring&gt;(<a class="el" href="classreflex_1_1_abstract_matcher.html#af51252ce359e6106b58c81f70776ccfb" title="Returns a positive integer (true) indicating the capture index of the matched text in the pattern or ...">accept()</a>, <a class="el" href="classreflex_1_1_abstract_matcher.html#a28cef361d991985fc4b28166d91ee15d" title="Returns the pattern match as a wide string, converted from UTF-8 text(), may include pattern-matched ...">wstr()</a>), useful for tokenization into containers.  <a href="#a6aeee06821a94df33a8c531d3913a5d7">More...</a><br /></td></tr>
<tr class="separator:a6aeee06821a94df33a8c531d3913a5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ccba7e796bc4cbf0fca4ddca5c7435"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ac0ccba7e796bc4cbf0fca4ddca5c7435">operator==</a> (const char *rhs) const </td></tr>
<tr class="memdesc:ac0ccba7e796bc4cbf0fca4ddca5c7435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if matched text is equal to a string, useful for std::algorithm.  <a href="#ac0ccba7e796bc4cbf0fca4ddca5c7435">More...</a><br /></td></tr>
<tr class="separator:ac0ccba7e796bc4cbf0fca4ddca5c7435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80d8b2a00e7e4342187f3e820aae4cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ad80d8b2a00e7e4342187f3e820aae4cc">operator==</a> (const std::string &amp;rhs) const </td></tr>
<tr class="memdesc:ad80d8b2a00e7e4342187f3e820aae4cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if matched text is equalt to a string, useful for std::algorithm.  <a href="#ad80d8b2a00e7e4342187f3e820aae4cc">More...</a><br /></td></tr>
<tr class="separator:ad80d8b2a00e7e4342187f3e820aae4cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9bd073a805aa84f99af13d4f4d7810a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ac9bd073a805aa84f99af13d4f4d7810a">operator==</a> (size_t rhs) const </td></tr>
<tr class="memdesc:ac9bd073a805aa84f99af13d4f4d7810a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if capture index is equal to a given size_t value, useful for std::algorithm.  <a href="#ac9bd073a805aa84f99af13d4f4d7810a">More...</a><br /></td></tr>
<tr class="separator:ac9bd073a805aa84f99af13d4f4d7810a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca9e1c83a9e7ea32adc7dedcba8891e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#aeca9e1c83a9e7ea32adc7dedcba8891e">operator==</a> (int rhs) const </td></tr>
<tr class="memdesc:aeca9e1c83a9e7ea32adc7dedcba8891e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if capture index is equal to a given int value, useful for std::algorithm.  <a href="#aeca9e1c83a9e7ea32adc7dedcba8891e">More...</a><br /></td></tr>
<tr class="separator:aeca9e1c83a9e7ea32adc7dedcba8891e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a502f0e864626cbdc5a09b6045c7fd801"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a502f0e864626cbdc5a09b6045c7fd801">operator!=</a> (const char *rhs) const </td></tr>
<tr class="memdesc:a502f0e864626cbdc5a09b6045c7fd801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if matched text is not equal to a string, useful for std::algorithm.  <a href="#a502f0e864626cbdc5a09b6045c7fd801">More...</a><br /></td></tr>
<tr class="separator:a502f0e864626cbdc5a09b6045c7fd801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85763cb3d9dbb87906edb69545d4f616"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a85763cb3d9dbb87906edb69545d4f616">operator!=</a> (const std::string &amp;rhs) const </td></tr>
<tr class="memdesc:a85763cb3d9dbb87906edb69545d4f616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if matched text is not equal to a string, useful for std::algorithm.  <a href="#a85763cb3d9dbb87906edb69545d4f616">More...</a><br /></td></tr>
<tr class="separator:a85763cb3d9dbb87906edb69545d4f616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e20564598a3871d32d95af33db5ea4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a08e20564598a3871d32d95af33db5ea4">operator!=</a> (size_t rhs) const </td></tr>
<tr class="memdesc:a08e20564598a3871d32d95af33db5ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if capture index is not equal to a given size_t value, useful for std::algorithm.  <a href="#a08e20564598a3871d32d95af33db5ea4">More...</a><br /></td></tr>
<tr class="separator:a08e20564598a3871d32d95af33db5ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7157e28939ecc094dca648b3bf9759a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a7157e28939ecc094dca648b3bf9759a2">operator!=</a> (int rhs) const </td></tr>
<tr class="memdesc:a7157e28939ecc094dca648b3bf9759a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if capture index is not equal to a given int value, useful for std::algorithm.  <a href="#a7157e28939ecc094dca648b3bf9759a2">More...</a><br /></td></tr>
<tr class="separator:a7157e28939ecc094dca648b3bf9759a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e23c24c8e576f4f6463eda78539d05"><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; const char *, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a99e23c24c8e576f4f6463eda78539d05">operator[]</a> (size_t n) const  =0</td></tr>
<tr class="memdesc:a99e23c24c8e576f4f6463eda78539d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns captured text as a std::pair&lt;const char*,size_t&gt; with string pointer (non-0-terminated) and length.  <a href="#a99e23c24c8e576f4f6463eda78539d05">More...</a><br /></td></tr>
<tr class="separator:a99e23c24c8e576f4f6463eda78539d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afffc3490ec1d0b72b7fb56653f2afe3e"><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; size_t, const char * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#afffc3490ec1d0b72b7fb56653f2afe3e">group_id</a> ()=0</td></tr>
<tr class="memdesc:afffc3490ec1d0b72b7fb56653f2afe3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the group capture identifier containing the group capture index &gt;0 and name (or NULL) of a named group capture, or (1,NULL) by default.  <a href="#afffc3490ec1d0b72b7fb56653f2afe3e">More...</a><br /></td></tr>
<tr class="separator:afffc3490ec1d0b72b7fb56653f2afe3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b6cc6ab090c4539b08fa575b34d065"><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; size_t, const char * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a68b6cc6ab090c4539b08fa575b34d065">group_next_id</a> ()=0</td></tr>
<tr class="memdesc:a68b6cc6ab090c4539b08fa575b34d065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next group capture identifier containing the group capture index &gt;0 and name (or NULL) of a named group capture, or (0,NULL) when no more groups matched.  <a href="#a68b6cc6ab090c4539b08fa575b34d065">More...</a><br /></td></tr>
<tr class="separator:a68b6cc6ab090c4539b08fa575b34d065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56a20f5b1cb4d25faea0e40508900c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ae56a20f5b1cb4d25faea0e40508900c0">tabs</a> (char n)</td></tr>
<tr class="memdesc:ae56a20f5b1cb4d25faea0e40508900c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set tab size 1, 2, 4, or 8.  <a href="#ae56a20f5b1cb4d25faea0e40508900c0">More...</a><br /></td></tr>
<tr class="separator:ae56a20f5b1cb4d25faea0e40508900c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfeac276b47b376ed2d8ace623d75efe"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#adfeac276b47b376ed2d8ace623d75efe">tabs</a> ()</td></tr>
<tr class="memdesc:adfeac276b47b376ed2d8ace623d75efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns current tab size 1, 2, 4, or 8.  <a href="#adfeac276b47b376ed2d8ace623d75efe">More...</a><br /></td></tr>
<tr class="separator:adfeac276b47b376ed2d8ace623d75efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a489c6327fb6521cc722852ada690f5ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_matcher_1_1_operation.html">Operation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a489c6327fb6521cc722852ada690f5ca">scan</a></td></tr>
<tr class="memdesc:a489c6327fb6521cc722852ada690f5ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">functor to scan input (to tokenize input)  <a href="#a489c6327fb6521cc722852ada690f5ca">More...</a><br /></td></tr>
<tr class="separator:a489c6327fb6521cc722852ada690f5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec40e4c9070975bcafa94af5db0e514"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_matcher_1_1_operation.html">Operation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a3ec40e4c9070975bcafa94af5db0e514">find</a></td></tr>
<tr class="memdesc:a3ec40e4c9070975bcafa94af5db0e514"><td class="mdescLeft">&#160;</td><td class="mdescRight">functor to search input  <a href="#a3ec40e4c9070975bcafa94af5db0e514">More...</a><br /></td></tr>
<tr class="separator:a3ec40e4c9070975bcafa94af5db0e514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d0cb13c2dca93cc556c06c24633b8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_matcher_1_1_operation.html">Operation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a16d0cb13c2dca93cc556c06c24633b8d">split</a></td></tr>
<tr class="memdesc:a16d0cb13c2dca93cc556c06c24633b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">functor to split input  <a href="#a16d0cb13c2dca93cc556c06c24633b8d">More...</a><br /></td></tr>
<tr class="separator:a16d0cb13c2dca93cc556c06c24633b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e1dd16b4c2deca18d9093fc727ee3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_input.html">Input</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ae4e1dd16b4c2deca18d9093fc727ee3b">in</a></td></tr>
<tr class="memdesc:ae4e1dd16b4c2deca18d9093fc727ee3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">input character sequence being matched by this matcher  <a href="#ae4e1dd16b4c2deca18d9093fc727ee3b">More...</a><br /></td></tr>
<tr class="separator:ae4e1dd16b4c2deca18d9093fc727ee3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a82ed7b2c125bd897dea73443d2650ac6"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a82ed7b2c125bd897dea73443d2650ac6">Method</a></td></tr>
<tr class="memdesc:a82ed7b2c125bd897dea73443d2650ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">a method is one of <a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#a57efdf6e79f50205036bc4d55e9908e7" title="AbstractMatcher::match method is to scan input (tokenizer) ">Const::SCAN</a>, <a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#af03daba13cf299ee0e6be2e37ebe59b7" title="AbstractMatcher::match method is to find pattern in input. ">Const::FIND</a>, <a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#a48f6d3e22c2f018fef95b2367a2a9aa4" title="AbstractMatcher::match method is to split input at pattern matches. ">Const::SPLIT</a>, <a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#aa1fe9eb434ef5ff539b01a601977f9ee" title="AbstractMatcher::match method is to match the entire input. ">Const::MATCH</a>  <a href="#a82ed7b2c125bd897dea73443d2650ac6">More...</a><br /></td></tr>
<tr class="separator:a82ed7b2c125bd897dea73443d2650ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:afb2962482f26a93cd207a6e8de59da83"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#afb2962482f26a93cd207a6e8de59da83">init</a> (const char *opt=NULL)</td></tr>
<tr class="memdesc:afb2962482f26a93cd207a6e8de59da83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the base abstract matcher at construction.  <a href="#afb2962482f26a93cd207a6e8de59da83">More...</a><br /></td></tr>
<tr class="separator:afb2962482f26a93cd207a6e8de59da83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3276cec0bb2daba22261e8aec147669"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#aa3276cec0bb2daba22261e8aec147669">match</a> (<a class="el" href="classreflex_1_1_abstract_matcher.html#a82ed7b2c125bd897dea73443d2650ac6">Method</a> method)=0</td></tr>
<tr class="memdesc:aa3276cec0bb2daba22261e8aec147669"><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract match operation implemented by pattern matching engines derived from <a class="el" href="classreflex_1_1_abstract_matcher.html" title="The abstract matcher base class template defines an interface for all pattern matcher engines...">AbstractMatcher</a>.  <a href="#aa3276cec0bb2daba22261e8aec147669">More...</a><br /></td></tr>
<tr class="separator:aa3276cec0bb2daba22261e8aec147669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450e338dc97b63c595ae3b583ccc9037"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a450e338dc97b63c595ae3b583ccc9037">grow</a> (size_t need=<a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#a6f7de58d1118b6f74f117a6b259359be">Const::BLOCK</a>)</td></tr>
<tr class="memdesc:a450e338dc97b63c595ae3b583ccc9037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift or expand the internal buffer when it is too small to accommodate more input, where the buffer size is doubled when needed, change cur_, pos_, end_, max_, ind_, buf_, bol_, lpb_, and txt_.  <a href="#a450e338dc97b63c595ae3b583ccc9037">More...</a><br /></td></tr>
<tr class="separator:a450e338dc97b63c595ae3b583ccc9037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33cea639acc9ea8ff0afba554432ba64"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a33cea639acc9ea8ff0afba554432ba64">get</a> ()</td></tr>
<tr class="memdesc:a33cea639acc9ea8ff0afba554432ba64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next character read from the current input source.  <a href="#a33cea639acc9ea8ff0afba554432ba64">More...</a><br /></td></tr>
<tr class="separator:a33cea639acc9ea8ff0afba554432ba64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab09e1287291012d0c7fd05506b69f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a6ab09e1287291012d0c7fd05506b69f2">reset_text</a> ()</td></tr>
<tr class="memdesc:a6ab09e1287291012d0c7fd05506b69f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the matched text by removing the terminating \0 when applicable, which is needed to search for a new match.  <a href="#a6ab09e1287291012d0c7fd05506b69f2">More...</a><br /></td></tr>
<tr class="separator:a6ab09e1287291012d0c7fd05506b69f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8d28fc8c5326d5f05f84aaa588d564"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a5f8d28fc8c5326d5f05f84aaa588d564">set_current</a> (size_t loc)</td></tr>
<tr class="memdesc:a5f8d28fc8c5326d5f05f84aaa588d564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current position in the buffer for the next match.  <a href="#a5f8d28fc8c5326d5f05f84aaa588d564">More...</a><br /></td></tr>
<tr class="separator:a5f8d28fc8c5326d5f05f84aaa588d564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f1ab76f52e6a0c4c05168b29932647"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a25f1ab76f52e6a0c4c05168b29932647">set_current_and_peek_more</a> (size_t loc)</td></tr>
<tr class="memdesc:a25f1ab76f52e6a0c4c05168b29932647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current match position in the buffer and peek for more text, allows large buffer shifts that aren't pinned to txt_.  <a href="#a25f1ab76f52e6a0c4c05168b29932647">More...</a><br /></td></tr>
<tr class="separator:a25f1ab76f52e6a0c4c05168b29932647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6889e7a74017302ef588e7371d06e6a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ad6889e7a74017302ef588e7371d06e6a">get_more</a> ()</td></tr>
<tr class="memdesc:ad6889e7a74017302ef588e7371d06e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next character and grow the buffer to make more room if necessary.  <a href="#ad6889e7a74017302ef588e7371d06e6a">More...</a><br /></td></tr>
<tr class="separator:ad6889e7a74017302ef588e7371d06e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a57145ce5ead569c3758be586d28f41"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a7a57145ce5ead569c3758be586d28f41">peek_more</a> ()</td></tr>
<tr class="memdesc:a7a57145ce5ead569c3758be586d28f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek at the next character and grow the buffer to make more room if necessary.  <a href="#a7a57145ce5ead569c3758be586d28f41">More...</a><br /></td></tr>
<tr class="separator:a7a57145ce5ead569c3758be586d28f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a7d944c389bc36abb15ba6c9f0601ab1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structreflex_1_1_abstract_matcher_1_1_option.html">Option</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a7d944c389bc36abb15ba6c9f0601ab1b">opt_</a></td></tr>
<tr class="memdesc:a7d944c389bc36abb15ba6c9f0601ab1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">options for matcher engines  <a href="#a7d944c389bc36abb15ba6c9f0601ab1b">More...</a><br /></td></tr>
<tr class="separator:a7d944c389bc36abb15ba6c9f0601ab1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522144cc1e11d86a7a44f3f41acc4ba9"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a522144cc1e11d86a7a44f3f41acc4ba9">buf_</a></td></tr>
<tr class="memdesc:a522144cc1e11d86a7a44f3f41acc4ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">input character sequence buffer  <a href="#a522144cc1e11d86a7a44f3f41acc4ba9">More...</a><br /></td></tr>
<tr class="separator:a522144cc1e11d86a7a44f3f41acc4ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce676b26fd73f76186ed5cfb4a9b9dc"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a6ce676b26fd73f76186ed5cfb4a9b9dc">txt_</a></td></tr>
<tr class="memdesc:a6ce676b26fd73f76186ed5cfb4a9b9dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">points to the matched text in buffer <a class="el" href="classreflex_1_1_abstract_matcher.html#a522144cc1e11d86a7a44f3f41acc4ba9" title="input character sequence buffer ">AbstractMatcher::buf_</a>  <a href="#a6ce676b26fd73f76186ed5cfb4a9b9dc">More...</a><br /></td></tr>
<tr class="separator:a6ce676b26fd73f76186ed5cfb4a9b9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c1bbabe9a7e0dd1a8b43b9bce58dfc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a63c1bbabe9a7e0dd1a8b43b9bce58dfc">len_</a></td></tr>
<tr class="memdesc:a63c1bbabe9a7e0dd1a8b43b9bce58dfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">size of the matched text  <a href="#a63c1bbabe9a7e0dd1a8b43b9bce58dfc">More...</a><br /></td></tr>
<tr class="separator:a63c1bbabe9a7e0dd1a8b43b9bce58dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc1bd57b738b0eb3320a1861312d78e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a7dc1bd57b738b0eb3320a1861312d78e">cap_</a></td></tr>
<tr class="memdesc:a7dc1bd57b738b0eb3320a1861312d78e"><td class="mdescLeft">&#160;</td><td class="mdescRight">nonzero capture index of an accepted match or zero  <a href="#a7dc1bd57b738b0eb3320a1861312d78e">More...</a><br /></td></tr>
<tr class="separator:a7dc1bd57b738b0eb3320a1861312d78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d1bb45408688e9fe41050363a2240c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a19d1bb45408688e9fe41050363a2240c">cur_</a></td></tr>
<tr class="memdesc:a19d1bb45408688e9fe41050363a2240c"><td class="mdescLeft">&#160;</td><td class="mdescRight">next position in <a class="el" href="classreflex_1_1_abstract_matcher.html#a522144cc1e11d86a7a44f3f41acc4ba9" title="input character sequence buffer ">AbstractMatcher::buf_</a> to assign to <a class="el" href="classreflex_1_1_abstract_matcher.html#a6ce676b26fd73f76186ed5cfb4a9b9dc" title="points to the matched text in buffer AbstractMatcher::buf_ ">AbstractMatcher::txt_</a>  <a href="#a19d1bb45408688e9fe41050363a2240c">More...</a><br /></td></tr>
<tr class="separator:a19d1bb45408688e9fe41050363a2240c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028118ceb0a16e9ee12cfb74d7141689"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a028118ceb0a16e9ee12cfb74d7141689">pos_</a></td></tr>
<tr class="memdesc:a028118ceb0a16e9ee12cfb74d7141689"><td class="mdescLeft">&#160;</td><td class="mdescRight">position in <a class="el" href="classreflex_1_1_abstract_matcher.html#a522144cc1e11d86a7a44f3f41acc4ba9" title="input character sequence buffer ">AbstractMatcher::buf_</a> after <a class="el" href="classreflex_1_1_abstract_matcher.html#a6ce676b26fd73f76186ed5cfb4a9b9dc" title="points to the matched text in buffer AbstractMatcher::buf_ ">AbstractMatcher::txt_</a>  <a href="#a028118ceb0a16e9ee12cfb74d7141689">More...</a><br /></td></tr>
<tr class="separator:a028118ceb0a16e9ee12cfb74d7141689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5567cb2217e7d76122b4a7332cf12215"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a5567cb2217e7d76122b4a7332cf12215">end_</a></td></tr>
<tr class="memdesc:a5567cb2217e7d76122b4a7332cf12215"><td class="mdescLeft">&#160;</td><td class="mdescRight">ending position of the input buffered in <a class="el" href="classreflex_1_1_abstract_matcher.html#a522144cc1e11d86a7a44f3f41acc4ba9" title="input character sequence buffer ">AbstractMatcher::buf_</a>  <a href="#a5567cb2217e7d76122b4a7332cf12215">More...</a><br /></td></tr>
<tr class="separator:a5567cb2217e7d76122b4a7332cf12215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3372a98e775f5dd2d816d4f8dacf78"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a8c3372a98e775f5dd2d816d4f8dacf78">max_</a></td></tr>
<tr class="memdesc:a8c3372a98e775f5dd2d816d4f8dacf78"><td class="mdescLeft">&#160;</td><td class="mdescRight">total buffer size and max position + 1 to fill  <a href="#a8c3372a98e775f5dd2d816d4f8dacf78">More...</a><br /></td></tr>
<tr class="separator:a8c3372a98e775f5dd2d816d4f8dacf78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0eb104096b1e02b78420bb02c89896c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ab0eb104096b1e02b78420bb02c89896c">ind_</a></td></tr>
<tr class="memdesc:ab0eb104096b1e02b78420bb02c89896c"><td class="mdescLeft">&#160;</td><td class="mdescRight">current indent position  <a href="#ab0eb104096b1e02b78420bb02c89896c">More...</a><br /></td></tr>
<tr class="separator:ab0eb104096b1e02b78420bb02c89896c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e77a5e960482ff2ee1bb89e3c06c5eb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a6e77a5e960482ff2ee1bb89e3c06c5eb">blk_</a></td></tr>
<tr class="memdesc:a6e77a5e960482ff2ee1bb89e3c06c5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">block size for block-based input reading, as set by <a class="el" href="classreflex_1_1_abstract_matcher.html#a0fb96965d228951194f0a2b9ee574dcf" title="Set buffer block size for reading: use 0 (or omit argument) to buffer all input in which case returns...">AbstractMatcher::buffer</a>  <a href="#a6e77a5e960482ff2ee1bb89e3c06c5eb">More...</a><br /></td></tr>
<tr class="separator:a6e77a5e960482ff2ee1bb89e3c06c5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e3fb0e851b132fd1e902de9ab56dba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a15e3fb0e851b132fd1e902de9ab56dba">got_</a></td></tr>
<tr class="memdesc:a15e3fb0e851b132fd1e902de9ab56dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">last unsigned character we looked at (to determine anchors and boundaries)  <a href="#a15e3fb0e851b132fd1e902de9ab56dba">More...</a><br /></td></tr>
<tr class="separator:a15e3fb0e851b132fd1e902de9ab56dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae712053969ae8fadeee28c1e08421cf5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ae712053969ae8fadeee28c1e08421cf5">chr_</a></td></tr>
<tr class="memdesc:ae712053969ae8fadeee28c1e08421cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">the character located at <a class="el" href="classreflex_1_1_abstract_matcher.html#a6ce676b26fd73f76186ed5cfb4a9b9dc" title="points to the matched text in buffer AbstractMatcher::buf_ ">AbstractMatcher::txt_</a>[<a class="el" href="classreflex_1_1_abstract_matcher.html#a63c1bbabe9a7e0dd1a8b43b9bce58dfc" title="size of the matched text ">AbstractMatcher::len_</a>]  <a href="#ae712053969ae8fadeee28c1e08421cf5">More...</a><br /></td></tr>
<tr class="separator:ae712053969ae8fadeee28c1e08421cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3c54afa437eb1e6b0d9d227632c676"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#acd3c54afa437eb1e6b0d9d227632c676">bol_</a></td></tr>
<tr class="memdesc:acd3c54afa437eb1e6b0d9d227632c676"><td class="mdescLeft">&#160;</td><td class="mdescRight">begin of line pointer in buffer  <a href="#acd3c54afa437eb1e6b0d9d227632c676">More...</a><br /></td></tr>
<tr class="separator:acd3c54afa437eb1e6b0d9d227632c676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4857240b9fc10fae94e23401c345e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structreflex_1_1_abstract_matcher_1_1_handler.html">Handler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a8d4857240b9fc10fae94e23401c345e1">evh_</a></td></tr>
<tr class="memdesc:a8d4857240b9fc10fae94e23401c345e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">event handler functor to invoke when buffer contents are shifted out  <a href="#a8d4857240b9fc10fae94e23401c345e1">More...</a><br /></td></tr>
<tr class="separator:a8d4857240b9fc10fae94e23401c345e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c72db1f90f67885fe585f27dc4eae8"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#aa1c72db1f90f67885fe585f27dc4eae8">lpb_</a></td></tr>
<tr class="memdesc:aa1c72db1f90f67885fe585f27dc4eae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">line pointer in buffer, updated when counting line numbers with <a class="el" href="classreflex_1_1_abstract_matcher.html#a3bbfcc6386048d9c3613f7de919ba242" title="Updates and returns the starting line number of the match in the input character sequence. ">lineno()</a>  <a href="#aa1c72db1f90f67885fe585f27dc4eae8">More...</a><br /></td></tr>
<tr class="separator:aa1c72db1f90f67885fe585f27dc4eae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad237874fc8405e2f701765de41d6cd37"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ad237874fc8405e2f701765de41d6cd37">lno_</a></td></tr>
<tr class="memdesc:ad237874fc8405e2f701765de41d6cd37"><td class="mdescLeft">&#160;</td><td class="mdescRight">line number count (cached)  <a href="#ad237874fc8405e2f701765de41d6cd37">More...</a><br /></td></tr>
<tr class="separator:ad237874fc8405e2f701765de41d6cd37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81507da95a6c54b6cc785a5460f0d57"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ac81507da95a6c54b6cc785a5460f0d57">cpb_</a></td></tr>
<tr class="memdesc:ac81507da95a6c54b6cc785a5460f0d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">column pointer in buffer, updated when counting column numbers with <a class="el" href="classreflex_1_1_abstract_matcher.html#a51527a637b1964627dd34c722d905b65" title="Updates and returns the starting column number of the matched text, taking tab spacing into account a...">columno()</a>  <a href="#ac81507da95a6c54b6cc785a5460f0d57">More...</a><br /></td></tr>
<tr class="separator:ac81507da95a6c54b6cc785a5460f0d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d20b0cfaa79571f201b52289c3fe2c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a92d20b0cfaa79571f201b52289c3fe2c">cno_</a></td></tr>
<tr class="memdesc:a92d20b0cfaa79571f201b52289c3fe2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">column number count (cached)  <a href="#a92d20b0cfaa79571f201b52289c3fe2c">More...</a><br /></td></tr>
<tr class="separator:a92d20b0cfaa79571f201b52289c3fe2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf059b818f76cda98cfd8ef059d8586e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#acf059b818f76cda98cfd8ef059d8586e">num_</a></td></tr>
<tr class="memdesc:acf059b818f76cda98cfd8ef059d8586e"><td class="mdescLeft">&#160;</td><td class="mdescRight">character count of the input till bol_  <a href="#acf059b818f76cda98cfd8ef059d8586e">More...</a><br /></td></tr>
<tr class="separator:acf059b818f76cda98cfd8ef059d8586e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd02b16f2713de6acc4aa19b459848e5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#abd02b16f2713de6acc4aa19b459848e5">res_</a></td></tr>
<tr class="memdesc:abd02b16f2713de6acc4aa19b459848e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">reserve bytes to keep in the buffer before bol_ when shifting, use only w/o <a class="el" href="classreflex_1_1_abstract_matcher.html#a8d4857240b9fc10fae94e23401c345e1" title="event handler functor to invoke when buffer contents are shifted out ">evh_()</a> set  <a href="#abd02b16f2713de6acc4aa19b459848e5">More...</a><br /></td></tr>
<tr class="separator:abd02b16f2713de6acc4aa19b459848e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b02b00048ab1b2bbb2b548f8b7aa02"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a62b02b00048ab1b2bbb2b548f8b7aa02">own_</a></td></tr>
<tr class="memdesc:a62b02b00048ab1b2bbb2b548f8b7aa02"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if <a class="el" href="classreflex_1_1_abstract_matcher.html#a522144cc1e11d86a7a44f3f41acc4ba9" title="input character sequence buffer ">AbstractMatcher::buf_</a> was allocated and should be deleted  <a href="#a62b02b00048ab1b2bbb2b548f8b7aa02">More...</a><br /></td></tr>
<tr class="separator:a62b02b00048ab1b2bbb2b548f8b7aa02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bbc10723ccc884bb90ed85a0dbdaabd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a2bbc10723ccc884bb90ed85a0dbdaabd">eof_</a></td></tr>
<tr class="memdesc:a2bbc10723ccc884bb90ed85a0dbdaabd"><td class="mdescLeft">&#160;</td><td class="mdescRight">input has reached EOF  <a href="#a2bbc10723ccc884bb90ed85a0dbdaabd">More...</a><br /></td></tr>
<tr class="separator:a2bbc10723ccc884bb90ed85a0dbdaabd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fdfd4999a13a782643d33da7bd2b5cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a4fdfd4999a13a782643d33da7bd2b5cf">mat_</a></td></tr>
<tr class="memdesc:a4fdfd4999a13a782643d33da7bd2b5cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if <a class="el" href="classreflex_1_1_abstract_matcher.html#ab880e6c8fe0df7c4ee7bb629aab41d0f" title="Returns nonzero capture index (i.e. true) if the entire input matches this matcher&#39;s pattern (and int...">AbstractMatcher::matches()</a> was successful  <a href="#a4fdfd4999a13a782643d33da7bd2b5cf">More...</a><br /></td></tr>
<tr class="separator:a4fdfd4999a13a782643d33da7bd2b5cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355e00f049bb4151a282ce4ba0e91ef7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a355e00f049bb4151a282ce4ba0e91ef7">cml_</a></td></tr>
<tr class="memdesc:a355e00f049bb4151a282ce4ba0e91ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">true when counting matching lines instead of line numbers  <a href="#a355e00f049bb4151a282ce4ba0e91ef7">More...</a><br /></td></tr>
<tr class="separator:a355e00f049bb4151a282ce4ba0e91ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The abstract matcher base class template defines an interface for all pattern matcher engines. </p>
<p>The buffer expands when matches do not fit. The buffer size is initially BUFSZ.</p>
<div class="fragment"><div class="line">      _________________</div><div class="line">     |  |    |    |    |</div><div class="line"><a class="code" href="classreflex_1_1_abstract_matcher.html#a522144cc1e11d86a7a44f3f41acc4ba9">buf_</a>=|  |<a class="code" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1">text</a>|<a class="code" href="classreflex_1_1_abstract_matcher.html#ab39dc592de42a7e044296f03bee4fdb3">rest</a>|free|</div><div class="line">     |__|____|____|____|</div><div class="line">        ^    ^    ^    ^</div><div class="line">        <a class="code" href="classreflex_1_1_abstract_matcher.html#a19d1bb45408688e9fe41050363a2240c">cur_</a> <a class="code" href="classreflex_1_1_abstract_matcher.html#a028118ceb0a16e9ee12cfb74d7141689">pos_</a> <a class="code" href="classreflex_1_1_abstract_matcher.html#a5567cb2217e7d76122b4a7332cf12215">end_</a> <a class="code" href="classreflex_1_1_abstract_matcher.html#a8c3372a98e775f5dd2d816d4f8dacf78">max_</a></div><div class="line"></div><div class="line"><a class="code" href="classreflex_1_1_abstract_matcher.html#a522144cc1e11d86a7a44f3f41acc4ba9">buf_</a> <span class="comment">// points to buffered input, buffer may grow to fit long matches</span></div><div class="line"><a class="code" href="classreflex_1_1_abstract_matcher.html#a19d1bb45408688e9fe41050363a2240c">cur_</a> <span class="comment">// current position in buf_ while matching text, cur_ = pos_ afterwards, may be changed by peek() and more()</span></div><div class="line"><a class="code" href="classreflex_1_1_abstract_matcher.html#a028118ceb0a16e9ee12cfb74d7141689">pos_</a> <span class="comment">// position in buf_ to start the next match</span></div><div class="line"><a class="code" href="classreflex_1_1_abstract_matcher.html#a5567cb2217e7d76122b4a7332cf12215">end_</a> <span class="comment">// position in buf_ that is free to fill with more input</span></div><div class="line"><a class="code" href="classreflex_1_1_abstract_matcher.html#a8c3372a98e775f5dd2d816d4f8dacf78">max_</a> <span class="comment">// allocated size of buf_, must ensure that max_ &gt; end_ for text() to add a final \0</span></div><div class="line"><a class="code" href="classreflex_1_1_abstract_matcher.html#a6ce676b26fd73f76186ed5cfb4a9b9dc">txt_</a> <span class="comment">// points to the match, will be 0-terminated when text() or rest() are called</span></div><div class="line"><a class="code" href="classreflex_1_1_abstract_matcher.html#a63c1bbabe9a7e0dd1a8b43b9bce58dfc">len_</a> <span class="comment">// length of the match</span></div><div class="line"><a class="code" href="classreflex_1_1_abstract_matcher.html#ae712053969ae8fadeee28c1e08421cf5">chr_</a> <span class="comment">// char located at txt_[len_] when txt_[len_] is set to \0 by text(), is \0 otherwise</span></div><div class="line"><a class="code" href="classreflex_1_1_abstract_matcher.html#a15e3fb0e851b132fd1e902de9ab56dba">got_</a> <span class="comment">// buf_[cur_-1] or txt_[-1] character before this match (assigned before each match), initially Const::BOB</span></div><div class="line"><a class="code" href="classreflex_1_1_abstract_matcher.html#a2bbc10723ccc884bb90ed85a0dbdaabd">eof_</a> <span class="comment">// true if no more data can/should be fetched to fill the buffer</span></div></div><!-- fragment --> </div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a24336f3d3f122aa0e904fc18954943f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classreflex_1_1_abstract_matcher_1_1_iterator.html">AbstractMatcher::Iterator</a>&lt;const <a class="el" href="classreflex_1_1_abstract_matcher.html">AbstractMatcher</a>&gt; <a class="el" href="classreflex_1_1_abstract_matcher.html#a24336f3d3f122aa0e904fc18954943f8">reflex::AbstractMatcher::const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>std::input_iterator for scanning, searching, and splitting input character sequences </p>

</div>
</div>
<a class="anchor" id="a7237c1fb8ab2a2283117739e6516c31f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classreflex_1_1_abstract_matcher_1_1_iterator.html">AbstractMatcher::Iterator</a>&lt;<a class="el" href="classreflex_1_1_abstract_matcher.html">AbstractMatcher</a>&gt; <a class="el" href="classreflex_1_1_abstract_matcher.html#a7237c1fb8ab2a2283117739e6516c31f">reflex::AbstractMatcher::iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>std::input_iterator for scanning, searching, and splitting input character sequences </p>

</div>
</div>
<a class="anchor" id="a82ed7b2c125bd897dea73443d2650ac6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="classreflex_1_1_abstract_matcher.html#a82ed7b2c125bd897dea73443d2650ac6">reflex::AbstractMatcher::Method</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a method is one of <a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#a57efdf6e79f50205036bc4d55e9908e7" title="AbstractMatcher::match method is to scan input (tokenizer) ">Const::SCAN</a>, <a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#af03daba13cf299ee0e6be2e37ebe59b7" title="AbstractMatcher::match method is to find pattern in input. ">Const::FIND</a>, <a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#a48f6d3e22c2f018fef95b2367a2a9aa4" title="AbstractMatcher::match method is to split input at pattern matches. ">Const::SPLIT</a>, <a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#aa1fe9eb434ef5ff539b01a601977f9ee" title="AbstractMatcher::match method is to match the entire input. ">Const::MATCH</a> </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1678067737066140c605e4e2e65ad1bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::AbstractMatcher::AbstractMatcher </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a base abstract matcher. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>input character sequence for this matcher </td></tr>
    <tr><td class="paramname">opt</td><td>option string of the form <code>(A|N|T(=[[:digit:]])?|;)*</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afa845e2492e9dfae56e9192c8330143b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::AbstractMatcher::AbstractMatcher </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structreflex_1_1_abstract_matcher_1_1_option.html">Option</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a base abstract matcher. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>input character sequence for this matcher </td></tr>
    <tr><td class="paramname">opt</td><td>options </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1687bb274cfa3af4de2cc8f0e9fcd10d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual reflex::AbstractMatcher::~AbstractMatcher </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete abstract matcher, deletes this matcher's internal buffer. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="af51252ce359e6106b58c81f70776ccfb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::AbstractMatcher::accept </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a positive integer (true) indicating the capture index of the matched text in the pattern or zero (false) for a mismatch. </p>
<dl class="section return"><dt>Returns</dt><dd>nonzero capture index of the match in the pattern, which may be matcher dependent, or zero for a mismatch, or <a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#a7c42ab60928bcc59f420876e741aae0b" title="accept() returns &quot;empty&quot; last split at end of input ">Const::EMPTY</a> for the empty last split </dd></dl>

</div>
</div>
<a class="anchor" id="af3ce5aac6ad3a5b9ec8bc04b9c6f9fa1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* reflex::AbstractMatcher::aft </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return pointer to the end of the match + len after, or at end of file, DANGER: invalidates previous <a class="el" href="classreflex_1_1_abstract_matcher.html#a640e70bf23e06e40ae52cadea0ecf19a" title="Returns pointer to the begin of the line in the buffer containing the matched text. ">bol()</a> and <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated pattern match as a char pointer, does not include matched \0s, this is a constant-time operation. ">text()</a> pointers, use <a class="el" href="classreflex_1_1_abstract_matcher.html#af3ce5aac6ad3a5b9ec8bc04b9c6f9fa1" title="Return pointer to the end of the match + len after, or at end of file, DANGER: invalidates previous b...">aft()</a> before <a class="el" href="classreflex_1_1_abstract_matcher.html#a640e70bf23e06e40ae52cadea0ecf19a" title="Returns pointer to the begin of the line in the buffer containing the matched text. ">bol()</a>, <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated pattern match as a char pointer, does not include matched \0s, this is a constant-time operation. ">text()</a>, <a class="el" href="classreflex_1_1_abstract_matcher.html#a329001b2880a756dd4d6f6fd0192d004" title="Returns pointer to the begin of the matched text (non-0-terminated), a constant-time operation...">begin()</a>, and <a class="el" href="classreflex_1_1_abstract_matcher.html#aaf1c25cf25951b7eeda7aa50d4736fd4" title="Returns pointer to the exclusive end of the matched text, a constant-time operation. ">end()</a> when those are used. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the end of the match + len. </dd></dl>

</div>
</div>
<a class="anchor" id="a1422cc4d5a78f997393081a1416b1f52"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structreflex_1_1_abstract_matcher_1_1_context.html">Context</a> reflex::AbstractMatcher::after </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the buffered context after EOF is reached. </p>

</div>
</div>
<a class="anchor" id="a146013ac9f6dcb1af9edef6ee5f3dc58"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::AbstractMatcher::at_bob </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this matcher is at the start of a buffer to read an input character sequence. Use <a class="el" href="classreflex_1_1_abstract_matcher.html#a66f487ab96e7cef1a66e9780dc45e315" title="Reset this matcher&#39;s state to the initial state and set options (when provided). ">reset()</a> to restart reading new input. </p>
<dl class="section return"><dt>Returns</dt><dd>true if at the begin of an input sequence </dd></dl>

</div>
</div>
<a class="anchor" id="a240d7d235b5a1d7aa32d464891cb96a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::AbstractMatcher::at_bol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this matcher reached the begin of a new line. </p>
<dl class="section return"><dt>Returns</dt><dd>true if at begin of a new line </dd></dl>

</div>
</div>
<a class="anchor" id="a4d2eb7cb29b0fd2c87aade0db5b3ab10"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::AbstractMatcher::at_bow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this matcher matched text that begins an ASCII word. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this matcher matched text that begins a word </dd></dl>

</div>
</div>
<a class="anchor" id="ac843ab490d5ad9ba71a96c3b323eba19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::AbstractMatcher::at_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this matcher has no more input to read from the input character sequence. </p>
<dl class="section return"><dt>Returns</dt><dd>true if at end of input and a read attempt will produce EOF </dd></dl>

</div>
</div>
<a class="anchor" id="ac17b43ef74d35dc503f8057ec410a3fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::AbstractMatcher::at_eow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this matcher matched text that ends an ASCII word. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this matcher matched text that ends a word </dd></dl>

</div>
</div>
<a class="anchor" id="a66c8231e2a0fbf53aa188448c9f9b229"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::AbstractMatcher::avail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of bytes in the buffer available to search from the current <a class="el" href="classreflex_1_1_abstract_matcher.html#a329001b2880a756dd4d6f6fd0192d004" title="Returns pointer to the begin of the matched text (non-0-terminated), a constant-time operation...">begin()</a>/text() position. </p>

</div>
</div>
<a class="anchor" id="a9a49dd953a2b4f15091a33466d37a613"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* reflex::AbstractMatcher::bef </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return pointer to the begin of the match - len before, or at the begin of the file. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the begin of the match - len. </dd></dl>

</div>
</div>
<a class="anchor" id="ae08cc80655fe7c723dd15da0ac80eb35"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structreflex_1_1_abstract_matcher_1_1_context.html">Context</a> reflex::AbstractMatcher::before </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the buffered context before the matching line. </p>

</div>
</div>
<a class="anchor" id="a329001b2880a756dd4d6f6fd0192d004"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* reflex::AbstractMatcher::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to the begin of the matched text (non-0-terminated), a constant-time operation, use with <a class="el" href="classreflex_1_1_abstract_matcher.html#aaf1c25cf25951b7eeda7aa50d4736fd4" title="Returns pointer to the exclusive end of the matched text, a constant-time operation. ">end()</a> or use <a class="el" href="classreflex_1_1_abstract_matcher.html#adb5fec59e6c6a86b8cf405c40f93d1de" title="Returns the length of the matched text in number of bytes, including pattern-matched \0s...">size()</a> for text end/length. </p>
<dl class="section return"><dt>Returns</dt><dd>const char* pointer to the matched text in the buffer </dd></dl>

</div>
</div>
<a class="anchor" id="a640e70bf23e06e40ae52cadea0ecf19a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* reflex::AbstractMatcher::bol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to the begin of the line in the buffer containing the matched text. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the begin of line </dd></dl>

</div>
</div>
<a class="anchor" id="a1cc9812e0bdaadc404a962754ce11226"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::AbstractMatcher::border </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the byte offset of the match from the start of the line. </p>
<dl class="section return"><dt>Returns</dt><dd>border offset </dd></dl>

</div>
</div>
<a class="anchor" id="a0fb96965d228951194f0a2b9ee574dcf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::AbstractMatcher::buffer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>blk</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set buffer block size for reading: use 0 (or omit argument) to buffer all input in which case returns true if all the data could be read and false if a read error occurred. </p>
<dl class="section return"><dt>Returns</dt><dd>true when successful to buffer all input when n=0 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blk</td><td>new block size between 1 and <a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#a6f7de58d1118b6f74f117a6b259359be" title="minimum remaining unused space in the buffer, to prevent excessive shifting ">Const::BLOCK</a>, or 0 to buffer all input (default) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3939efa95649d0b8543109669818a097"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_abstract_matcher.html">AbstractMatcher</a>&amp; reflex::AbstractMatcher::buffer </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the buffer base containing 0-terminated character data to scan in place (data may be modified), reset/restart the matcher. </p>
<dl class="section return"><dt>Returns</dt><dd>this matcher </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>base of the buffer containing 0-terminated character data </td></tr>
    <tr><td class="paramname">size</td><td>nonzero size of the buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a12e24702dba5c0c15e5f680b174a4758"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int reflex::AbstractMatcher::chr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first 8-bit character of the text matched. </p>
<dl class="section return"><dt>Returns</dt><dd>8-bit char </dd></dl>

</div>
</div>
<a class="anchor" id="a990b0f98e3b73ae3a2f4a9aa91626b8d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classreflex_1_1_abstract_matcher.html">AbstractMatcher</a>* reflex::AbstractMatcher::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Polymorphic cloning. </p>

<p>Implemented in <a class="el" href="classreflex_1_1_matcher.html#a70d0469bd7c8ad7697dc877d4d30b8b5">reflex::Matcher</a>, <a class="el" href="classreflex_1_1_p_c_r_e2_matcher.html#aca2313a4a5f32cf7655e13036a71ca7a">reflex::PCRE2Matcher</a>, <a class="el" href="classreflex_1_1_fuzzy_matcher.html#aefa7b85ef43429530eb268d3d9a4d19c">reflex::FuzzyMatcher</a>, <a class="el" href="classreflex_1_1_boost_matcher.html#a5b5fad3842e63bfe631249b2d5c49850">reflex::BoostMatcher</a>, <a class="el" href="classreflex_1_1_std_matcher.html#aa96807bdc0b350aef4a92c595eb8aef5">reflex::StdMatcher</a>, and <a class="el" href="classreflex_1_1_line_matcher.html#a32bb49912df9961f1d07f42e2cc96de2">reflex::LineMatcher</a>.</p>

</div>
</div>
<a class="anchor" id="ab566032e82437721d590250b358d5704"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::AbstractMatcher::columno </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set or change the starting column number of the last match. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>new column number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a51527a637b1964627dd34c722d905b65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::AbstractMatcher::columno </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates and returns the starting column number of the matched text, taking tab spacing into account and counting wide characters as one character each. </p>
<dl class="section return"><dt>Returns</dt><dd>column number </dd></dl>

</div>
</div>
<a class="anchor" id="af47d0699975797b828b3a8e1a5470ec2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::AbstractMatcher::columno_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the inclusive ending column number of the matched text on the ending matching line, taking tab spacing into account and counting wide characters as one character each. </p>
<dl class="section return"><dt>Returns</dt><dd>column number </dd></dl>

</div>
</div>
<a class="anchor" id="a84fe081ea4237a44ea659c5400fffccd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::AbstractMatcher::columns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of columns of the matched text, taking tab spacing into account and counting wide characters as one character each. </p>
<dl class="section return"><dt>Returns</dt><dd>number of columns </dd></dl>

</div>
</div>
<a class="anchor" id="aaf1c25cf25951b7eeda7aa50d4736fd4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* reflex::AbstractMatcher::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to the exclusive end of the matched text, a constant-time operation. </p>
<dl class="section return"><dt>Returns</dt><dd>const char* pointer to the exclusive end of the matched text in the buffer </dd></dl>

</div>
</div>
<a class="anchor" id="a7b5244017d854301305afbf8326c9e98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* reflex::AbstractMatcher::eol </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inclusive</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to the end of the line (last char + 1) in the buffer containing the matched text, DANGER: invalidates previous <a class="el" href="classreflex_1_1_abstract_matcher.html#a640e70bf23e06e40ae52cadea0ecf19a" title="Returns pointer to the begin of the line in the buffer containing the matched text. ">bol()</a> and <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated pattern match as a char pointer, does not include matched \0s, this is a constant-time operation. ">text()</a> pointers, use <a class="el" href="classreflex_1_1_abstract_matcher.html#a7b5244017d854301305afbf8326c9e98" title="Returns pointer to the end of the line (last char + 1) in the buffer containing the matched text...">eol()</a> before <a class="el" href="classreflex_1_1_abstract_matcher.html#a640e70bf23e06e40ae52cadea0ecf19a" title="Returns pointer to the begin of the line in the buffer containing the matched text. ">bol()</a>, <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated pattern match as a char pointer, does not include matched \0s, this is a constant-time operation. ">text()</a>, <a class="el" href="classreflex_1_1_abstract_matcher.html#a329001b2880a756dd4d6f6fd0192d004" title="Returns pointer to the begin of the matched text (non-0-terminated), a constant-time operation...">begin()</a>, and <a class="el" href="classreflex_1_1_abstract_matcher.html#aaf1c25cf25951b7eeda7aa50d4736fd4" title="Returns pointer to the exclusive end of the matched text, a constant-time operation. ">end()</a> when those are used. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the end of line </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inclusive</td><td>true if inclusive, i.e. point after <br />
 instead of at <br />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac71eb02005f4225d04a39c112296a000"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::AbstractMatcher::fetch </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return number of bytes available given number of bytes to fetch ahead, limited by input size and buffer size, DANGER: invalidates previous <a class="el" href="classreflex_1_1_abstract_matcher.html#a640e70bf23e06e40ae52cadea0ecf19a" title="Returns pointer to the begin of the line in the buffer containing the matched text. ">bol()</a> and <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated pattern match as a char pointer, does not include matched \0s, this is a constant-time operation. ">text()</a> pointers, use <a class="el" href="classreflex_1_1_abstract_matcher.html#ac71eb02005f4225d04a39c112296a000" title="Return number of bytes available given number of bytes to fetch ahead, limited by input size and buff...">fetch()</a> before <a class="el" href="classreflex_1_1_abstract_matcher.html#a640e70bf23e06e40ae52cadea0ecf19a" title="Returns pointer to the begin of the line in the buffer containing the matched text. ">bol()</a>, <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated pattern match as a char pointer, does not include matched \0s, this is a constant-time operation. ">text()</a>, <a class="el" href="classreflex_1_1_abstract_matcher.html#a329001b2880a756dd4d6f6fd0192d004" title="Returns pointer to the begin of the matched text (non-0-terminated), a constant-time operation...">begin()</a>, and <a class="el" href="classreflex_1_1_abstract_matcher.html#aaf1c25cf25951b7eeda7aa50d4736fd4" title="Returns pointer to the exclusive end of the matched text, a constant-time operation. ">end()</a> when those are used. </p>
<dl class="section return"><dt>Returns</dt><dd>number of bytes available after fetching. </dd></dl>

</div>
</div>
<a class="anchor" id="a112117a78682b9634806158e018dc6b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::AbstractMatcher::first </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the position of the first character of the match in the input character sequence, a constant-time operation. </p>
<dl class="section return"><dt>Returns</dt><dd>position in the input character sequence </dd></dl>

</div>
</div>
<a class="anchor" id="acafc5782952bb1e80c7e5bf367ffc6af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::AbstractMatcher::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flush the buffer's remaining content. </p>

</div>
</div>
<a class="anchor" id="a92391ce2c5eab5a6dbce067a8326702e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t reflex::AbstractMatcher::get </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns more input data directly from the source (method can be overriden, as by reflex::FlexLexer::get(s, n) for example that invokes reflex::FlexLexer::LexerInput(s, n)). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nonzero number of (less or equal to n) 8-bit characters added to buffer s from the current input, or zero when EOF points to the string buffer to fill with input </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>size of buffer pointed to by s </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a33cea639acc9ea8ff0afba554432ba64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int reflex::AbstractMatcher::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the next character read from the current input source. </p>
<dl class="section return"><dt>Returns</dt><dd>the character read (unsigned char 0..255) or EOF (-1) </dd></dl>

</div>
</div>
<a class="anchor" id="ad6889e7a74017302ef588e7371d06e6a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int reflex::AbstractMatcher::get_more </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the next character and grow the buffer to make more room if necessary. </p>
<dl class="section return"><dt>Returns</dt><dd>the character read (unsigned char 0..255) or EOF (-1) </dd></dl>

</div>
</div>
<a class="anchor" id="afffc3490ec1d0b72b7fb56653f2afe3e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::pair&lt;size_t,const char*&gt; reflex::AbstractMatcher::group_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the group capture identifier containing the group capture index &gt;0 and name (or NULL) of a named group capture, or (1,NULL) by default. </p>
<dl class="section return"><dt>Returns</dt><dd>a pair of size_t and string </dd></dl>

<p>Implemented in <a class="el" href="classreflex_1_1_p_c_r_e2_matcher.html#a2e4cddcd72c972bbfbd9e7a410818da4">reflex::PCRE2Matcher</a>, <a class="el" href="classreflex_1_1_matcher.html#a19ee864fe3ae325d28b900c7bd4b919a">reflex::Matcher</a>, <a class="el" href="classreflex_1_1_boost_matcher.html#a354995008f1e51281594cc72749ef1b9">reflex::BoostMatcher</a>, <a class="el" href="classreflex_1_1_std_matcher.html#a82f61242adaa3db4d546cefb5a518a92">reflex::StdMatcher</a>, and <a class="el" href="classreflex_1_1_line_matcher.html#afc3f0e21b37132dbe2512aafc56c2610">reflex::LineMatcher</a>.</p>

</div>
</div>
<a class="anchor" id="a68b6cc6ab090c4539b08fa575b34d065"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::pair&lt;size_t,const char*&gt; reflex::AbstractMatcher::group_next_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the next group capture identifier containing the group capture index &gt;0 and name (or NULL) of a named group capture, or (0,NULL) when no more groups matched. </p>
<dl class="section return"><dt>Returns</dt><dd>a pair of size_t and string </dd></dl>

<p>Implemented in <a class="el" href="classreflex_1_1_p_c_r_e2_matcher.html#abe198fe92683178695e6d772a4207176">reflex::PCRE2Matcher</a>, <a class="el" href="classreflex_1_1_matcher.html#aff7790e539b65f03b5c45403c37da7c9">reflex::Matcher</a>, <a class="el" href="classreflex_1_1_boost_matcher.html#a0693b14273884a92a3682c1524c61646">reflex::BoostMatcher</a>, <a class="el" href="classreflex_1_1_std_matcher.html#a818cf4601fcb97125890e1935315d4e9">reflex::StdMatcher</a>, and <a class="el" href="classreflex_1_1_line_matcher.html#ac452fbdf3ba2412b8089b4aea68c83de">reflex::LineMatcher</a>.</p>

</div>
</div>
<a class="anchor" id="a450e338dc97b63c595ae3b583ccc9037"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::AbstractMatcher::grow </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>need</em> = <code><a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#a6f7de58d1118b6f74f117a6b259359be">Const::BLOCK</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift or expand the internal buffer when it is too small to accommodate more input, where the buffer size is doubled when needed, change cur_, pos_, end_, max_, ind_, buf_, bol_, lpb_, and txt_. </p>
<dl class="section return"><dt>Returns</dt><dd>true if buffer was shifted or enlarged </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">need</td><td>optional needed space = <a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#a6f7de58d1118b6f74f117a6b259359be" title="minimum remaining unused space in the buffer, to prevent excessive shifting ">Const::BLOCK</a> size by default </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb5ec19555d6e0f4a8210651f9343987"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::AbstractMatcher::hit_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this matcher hit the end of the input character sequence. </p>
<dl class="section return"><dt>Returns</dt><dd>true if EOF was hit (and possibly more input would have changed the result), false otherwise (but next read attempt may return EOF immediately) </dd></dl>

</div>
</div>
<a class="anchor" id="afb2962482f26a93cd207a6e8de59da83"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reflex::AbstractMatcher::init </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>opt</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the base abstract matcher at construction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td>options </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab49c7878fc1d7c39e0ca264a5c919f08"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classreflex_1_1_abstract_matcher.html">AbstractMatcher</a>&amp; reflex::AbstractMatcher::input </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the input character sequence for this matcher and reset/restart the matcher. </p>
<dl class="section return"><dt>Returns</dt><dd>this matcher </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>input character sequence for this matcher </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a827817fd1ed8edbe8eec84eeefa8a88e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int reflex::AbstractMatcher::input </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the next 8-bit character (unsigned char 0..255 or EOF) from the input character sequence, while preserving the current <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated pattern match as a char pointer, does not include matched \0s, this is a constant-time operation. ">text()</a> match (but pointer returned by <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated pattern match as a char pointer, does not include matched \0s, this is a constant-time operation. ">text()</a> may change; warning: does not preserve the yytext string pointer when options &ndash;flex and &ndash;bison are used). </p>
<dl class="section return"><dt>Returns</dt><dd>the next character (unsigned char 0..255) from input or EOF (-1) </dd></dl>

</div>
</div>
<a class="anchor" id="acb1d22133cb4cf88f208c45ee8cdc0e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::AbstractMatcher::interactive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set interactive input with buffer size of 1 to read data bytewise which is very slow. </p>
<dl class="section note"><dt>Note</dt><dd>Use this method before any matching is done and before any input is read since the last time input was (re)set. </dd></dl>

</div>
</div>
<a class="anchor" id="a7840043710c3c45820390480c8f42315"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::AbstractMatcher::last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the exclusive position of the last character of the match in the input character sequence, a constant-time operation. </p>
<dl class="section return"><dt>Returns</dt><dd>position in the input character sequence </dd></dl>

</div>
</div>
<a class="anchor" id="a12ca0aa2d6ff88ac26f565ec5660787a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::AbstractMatcher::less </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Truncate the <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated pattern match as a char pointer, does not include matched \0s, this is a constant-time operation. ">AbstractMatcher::text</a> length of the match to n characters in length and reposition for next match. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>truncated string length </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a017eccee23af26c81f8f91be878c4711"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string reflex::AbstractMatcher::line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the line of input (excluding <br />
) as a string containing the matched text as a substring. </p>
<dl class="section return"><dt>Returns</dt><dd>matching line as a string </dd></dl>

</div>
</div>
<a class="anchor" id="a3812c606737fdf861eb64023e9e9cec6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::AbstractMatcher::lineno </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set or change the starting line number of the last match. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>new line number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3bbfcc6386048d9c3613f7de919ba242"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::AbstractMatcher::lineno </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates and returns the starting line number of the match in the input character sequence. </p>
<dl class="section return"><dt>Returns</dt><dd>line number </dd></dl>

</div>
</div>
<a class="anchor" id="aa822685ae6ffae7283a9ea1dbfe5899d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::AbstractMatcher::lineno_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the inclusive ending line number of the match in the input character sequence. </p>
<dl class="section return"><dt>Returns</dt><dd>line number </dd></dl>

</div>
</div>
<a class="anchor" id="a3a69f32040ea02b605f6fa0f31af0be7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::AbstractMatcher::lineno_skip </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>f</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set or reset mode to count matching lines only and skip other (e.g. for speed). </p>

</div>
</div>
<a class="anchor" id="a1258c856660344404af7e2019450c727"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::AbstractMatcher::lines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of lines that the match spans. </p>
<dl class="section return"><dt>Returns</dt><dd>number of lines </dd></dl>

</div>
</div>
<a class="anchor" id="aa3276cec0bb2daba22261e8aec147669"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t reflex::AbstractMatcher::match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classreflex_1_1_abstract_matcher.html#a82ed7b2c125bd897dea73443d2650ac6">Method</a>&#160;</td>
          <td class="paramname"><em>method</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The abstract match operation implemented by pattern matching engines derived from <a class="el" href="classreflex_1_1_abstract_matcher.html" title="The abstract matcher base class template defines an interface for all pattern matcher engines...">AbstractMatcher</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>nonzero when input matched the pattern using method <a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#a57efdf6e79f50205036bc4d55e9908e7" title="AbstractMatcher::match method is to scan input (tokenizer) ">Const::SCAN</a>, <a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#af03daba13cf299ee0e6be2e37ebe59b7" title="AbstractMatcher::match method is to find pattern in input. ">Const::FIND</a>, <a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#a48f6d3e22c2f018fef95b2367a2a9aa4" title="AbstractMatcher::match method is to split input at pattern matches. ">Const::SPLIT</a>, or <a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#aa1fe9eb434ef5ff539b01a601977f9ee" title="AbstractMatcher::match method is to match the entire input. ">Const::MATCH</a> </dd></dl>

<p>Implemented in <a class="el" href="classreflex_1_1_matcher.html#ab8a1264b3ede06dbba853b1ca0baead5">reflex::Matcher</a>, <a class="el" href="classreflex_1_1_fuzzy_matcher.html#ae5e33648276703cebc989cfbcf5efb6a">reflex::FuzzyMatcher</a>, <a class="el" href="classreflex_1_1_p_c_r_e2_matcher.html#a8eb8ecc2d77e92660b078a28294ffa45">reflex::PCRE2Matcher</a>, <a class="el" href="classreflex_1_1_boost_matcher.html#a90178f2e17c8dea08fcc8efc2b85339e">reflex::BoostMatcher</a>, <a class="el" href="classreflex_1_1_std_matcher.html#abf3a32ee06cd50c2ec10c1825ea2aee7">reflex::StdMatcher</a>, and <a class="el" href="classreflex_1_1_line_matcher.html#a2a3b582585be02f39b93f18519f2d503">reflex::LineMatcher</a>.</p>

</div>
</div>
<a class="anchor" id="ab880e6c8fe0df7c4ee7bb629aab41d0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::AbstractMatcher::matches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns nonzero capture index (i.e. true) if the entire input matches this matcher's pattern (and internally caches the true/false result to permit repeat invocations). </p>
<dl class="section return"><dt>Returns</dt><dd>nonzero capture index if the entire input matched this matcher's pattern, zero (i.e. false) otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a9577e765c5c1be82cb3f9b0ccdaf633f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::AbstractMatcher::more </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append the next match to the currently matched text returned by <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated pattern match as a char pointer, does not include matched \0s, this is a constant-time operation. ">AbstractMatcher::text</a>, when the next match found is adjacent to the current match. </p>

</div>
</div>
<a class="anchor" id="a2e8cd6c7fde713a5ac68ec168291e03e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::AbstractMatcher::operator size_t </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast this matcher to positive integer indicating the nonzero capture index of the matched text in the pattern, same as <a class="el" href="classreflex_1_1_abstract_matcher.html#af51252ce359e6106b58c81f70776ccfb" title="Returns a positive integer (true) indicating the capture index of the matched text in the pattern or ...">AbstractMatcher::accept</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>nonzero capture index of a match, which may be matcher dependent, or zero for a mismatch </dd></dl>

</div>
</div>
<a class="anchor" id="a6aeee06821a94df33a8c531d3913a5d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::AbstractMatcher::operator std::pair&lt; size_t, std::string &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast the match to std::pair&lt;size_t,std::wstring&gt;(<a class="el" href="classreflex_1_1_abstract_matcher.html#af51252ce359e6106b58c81f70776ccfb" title="Returns a positive integer (true) indicating the capture index of the matched text in the pattern or ...">accept()</a>, <a class="el" href="classreflex_1_1_abstract_matcher.html#a28cef361d991985fc4b28166d91ee15d" title="Returns the pattern match as a wide string, converted from UTF-8 text(), may include pattern-matched ...">wstr()</a>), useful for tokenization into containers. </p>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;size_t,std::wstring&gt;(<a class="el" href="classreflex_1_1_abstract_matcher.html#af51252ce359e6106b58c81f70776ccfb" title="Returns a positive integer (true) indicating the capture index of the matched text in the pattern or ...">accept()</a>, <a class="el" href="classreflex_1_1_abstract_matcher.html#a28cef361d991985fc4b28166d91ee15d" title="Returns the pattern match as a wide string, converted from UTF-8 text(), may include pattern-matched ...">wstr()</a>) </dd></dl>

</div>
</div>
<a class="anchor" id="a360028bf97e0da02f6ffbcae031f9f35"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::AbstractMatcher::operator std::string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast this matcher to a std::string of the text matched by this matcher. </p>
<dl class="section return"><dt>Returns</dt><dd>std::string with matched text </dd></dl>

</div>
</div>
<a class="anchor" id="aab1c0ee67ce2062f8c1c518170cd2a74"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::AbstractMatcher::operator std::wstring </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast this matcher to a std::wstring of the text matched by this matcher. </p>
<dl class="section return"><dt>Returns</dt><dd>std::wstring converted to UCS from the 0-terminated matched UTF-8 text </dd></dl>

</div>
</div>
<a class="anchor" id="a502f0e864626cbdc5a09b6045c7fd801"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::AbstractMatcher::operator!= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if matched text is not equal to a string, useful for std::algorithm. </p>
<dl class="section return"><dt>Returns</dt><dd>true if matched text is not equal to rhs string </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>rhs string to compare to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a85763cb3d9dbb87906edb69545d4f616"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::AbstractMatcher::operator!= </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if matched text is not equal to a string, useful for std::algorithm. </p>
<dl class="section return"><dt>Returns</dt><dd>true if matched text is not equal to rhs string </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>rhs string to compare to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a08e20564598a3871d32d95af33db5ea4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::AbstractMatcher::operator!= </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if capture index is not equal to a given size_t value, useful for std::algorithm. </p>
<dl class="section return"><dt>Returns</dt><dd>true if capture index is not equal to rhs </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>capture index to compare <a class="el" href="classreflex_1_1_abstract_matcher.html#af51252ce359e6106b58c81f70776ccfb" title="Returns a positive integer (true) indicating the capture index of the matched text in the pattern or ...">accept()</a> to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7157e28939ecc094dca648b3bf9759a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::AbstractMatcher::operator!= </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if capture index is not equal to a given int value, useful for std::algorithm. </p>
<dl class="section return"><dt>Returns</dt><dd>true if capture index is not equal to rhs </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>capture index to compare <a class="el" href="classreflex_1_1_abstract_matcher.html#af51252ce359e6106b58c81f70776ccfb" title="Returns a positive integer (true) indicating the capture index of the matched text in the pattern or ...">accept()</a> to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac0ccba7e796bc4cbf0fca4ddca5c7435"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::AbstractMatcher::operator== </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if matched text is equal to a string, useful for std::algorithm. </p>
<dl class="section return"><dt>Returns</dt><dd>true if matched text is equal to rhs string </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>rhs string to compare to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad80d8b2a00e7e4342187f3e820aae4cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::AbstractMatcher::operator== </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if matched text is equalt to a string, useful for std::algorithm. </p>
<dl class="section return"><dt>Returns</dt><dd>true if matched text is equal to rhs string </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>rhs string to compare to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac9bd073a805aa84f99af13d4f4d7810a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::AbstractMatcher::operator== </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if capture index is equal to a given size_t value, useful for std::algorithm. </p>
<dl class="section return"><dt>Returns</dt><dd>true if capture index is equal to rhs </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>capture index to compare <a class="el" href="classreflex_1_1_abstract_matcher.html#af51252ce359e6106b58c81f70776ccfb" title="Returns a positive integer (true) indicating the capture index of the matched text in the pattern or ...">accept()</a> to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeca9e1c83a9e7ea32adc7dedcba8891e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::AbstractMatcher::operator== </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if capture index is equal to a given int value, useful for std::algorithm. </p>
<dl class="section return"><dt>Returns</dt><dd>true if capture index is equal to rhs </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>capture index to compare <a class="el" href="classreflex_1_1_abstract_matcher.html#af51252ce359e6106b58c81f70776ccfb" title="Returns a positive integer (true) indicating the capture index of the matched text in the pattern or ...">accept()</a> to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a99e23c24c8e576f4f6463eda78539d05"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::pair&lt;const char*,size_t&gt; reflex::AbstractMatcher::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns captured text as a std::pair&lt;const char*,size_t&gt; with string pointer (non-0-terminated) and length. </p>
<dl class="section return"><dt>Returns</dt><dd>std::pair of string pointer and length in the captured text, where [0] returns std::pair(<a class="el" href="classreflex_1_1_abstract_matcher.html#a329001b2880a756dd4d6f6fd0192d004" title="Returns pointer to the begin of the matched text (non-0-terminated), a constant-time operation...">begin()</a>, <a class="el" href="classreflex_1_1_abstract_matcher.html#adb5fec59e6c6a86b8cf405c40f93d1de" title="Returns the length of the matched text in number of bytes, including pattern-matched \0s...">size()</a>) </dd></dl>

<p>Implemented in <a class="el" href="classreflex_1_1_p_c_r_e2_matcher.html#a0c9a3b53d00fb2bba35956c437018530">reflex::PCRE2Matcher</a>, <a class="el" href="classreflex_1_1_matcher.html#acf0031339b3f8426b730a6860e5feba2">reflex::Matcher</a>, <a class="el" href="classreflex_1_1_std_matcher.html#aa48c631145c803cbda9f3891eccc1b3e">reflex::StdMatcher</a>, <a class="el" href="classreflex_1_1_boost_matcher.html#aafdb43bb11cab6eac43ba846e17ca33e">reflex::BoostMatcher</a>, and <a class="el" href="classreflex_1_1_line_matcher.html#a691d52bfed1523c7b4c3f70d280a875c">reflex::LineMatcher</a>.</p>

</div>
</div>
<a class="anchor" id="abc573eafc849b275d21b114abe1ea570"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;size_t,std::string&gt; reflex::AbstractMatcher::pair </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns std::pair&lt;size_t,std::string&gt;(<a class="el" href="classreflex_1_1_abstract_matcher.html#af51252ce359e6106b58c81f70776ccfb" title="Returns a positive integer (true) indicating the capture index of the matched text in the pattern or ...">accept()</a>, <a class="el" href="classreflex_1_1_abstract_matcher.html#a9c1d2913a158699703eee6d5f603701b" title="Returns the text matched as a string, a copy of text(), may include pattern-matched \0s...">str()</a>), useful for tokenizing input into containers of pairs. </p>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;size_t,std::string&gt;(<a class="el" href="classreflex_1_1_abstract_matcher.html#af51252ce359e6106b58c81f70776ccfb" title="Returns a positive integer (true) indicating the capture index of the matched text in the pattern or ...">accept()</a>, <a class="el" href="classreflex_1_1_abstract_matcher.html#a9c1d2913a158699703eee6d5f603701b" title="Returns the text matched as a string, a copy of text(), may include pattern-matched \0s...">str()</a>) </dd></dl>

</div>
</div>
<a class="anchor" id="acb8a8eff9fc980c7028c9399a1310849"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int reflex::AbstractMatcher::peek </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Peek at the next character available for reading from the current input source. </p>
<dl class="section return"><dt>Returns</dt><dd>the character (unsigned char 0..255) or EOF (-1) </dd></dl>

</div>
</div>
<a class="anchor" id="a7a57145ce5ead569c3758be586d28f41"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int reflex::AbstractMatcher::peek_more </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Peek at the next character and grow the buffer to make more room if necessary. </p>
<dl class="section return"><dt>Returns</dt><dd>the character (unsigned char 0..255) or EOF (-1) </dd></dl>

</div>
</div>
<a class="anchor" id="a66f487ab96e7cef1a66e9780dc45e315"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reflex::AbstractMatcher::reset </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>opt</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset this matcher's state to the initial state and set options (when provided). </p>

<p>Reimplemented in <a class="el" href="classreflex_1_1_matcher.html#a641754cf7025a978c7dc672a563ac5c0">reflex::Matcher</a>, <a class="el" href="classreflex_1_1_p_c_r_e2_matcher.html#a7dacee924aa6e994fc18df71661a565c">reflex::PCRE2Matcher</a>, <a class="el" href="classreflex_1_1_boost_matcher.html#a49d2b5f7c6261d57274447345b6c7c81">reflex::BoostMatcher</a>, <a class="el" href="classreflex_1_1_std_matcher.html#aeb6cb1ab8afe16437091c1e29af2b7e4">reflex::StdMatcher</a>, and <a class="el" href="classreflex_1_1_line_matcher.html#a1a87a154ff3c862e0ba1d899dc87e140">reflex::LineMatcher</a>.</p>

</div>
</div>
<a class="anchor" id="a6ab09e1287291012d0c7fd05506b69f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::AbstractMatcher::reset_text </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the matched text by removing the terminating \0 when applicable, which is needed to search for a new match. </p>

</div>
</div>
<a class="anchor" id="ab39dc592de42a7e044296f03bee4fdb3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* reflex::AbstractMatcher::rest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch the rest of the input as text, useful for searching/splitting up to n times after which the rest is needed. </p>
<dl class="section return"><dt>Returns</dt><dd>const char* string of the remaining input (wrapped with more input when <a class="el" href="classreflex_1_1_abstract_matcher.html#a046e0696b048d229ea2d77f5010c41e1" title="Returns true if wrapping of input after EOF is supported. ">AbstractMatcher::wrap</a> is defined) </dd></dl>

</div>
</div>
<a class="anchor" id="a8e0b546187f2ad8f6d7f39207e683a7f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::AbstractMatcher::set_bob </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bob</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set/reset the begin of a buffer state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bob</td><td>if true: set begin of buffer state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0860fa58e41f5a0d7e74d1fe33559df3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::AbstractMatcher::set_bol </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set/reset the begin of a new line state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bol</td><td>if true: set begin of a new line state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5f8d28fc8c5326d5f05f84aaa588d564"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::AbstractMatcher::set_current </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the current position in the buffer for the next match. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loc</td><td>new location in buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a25f1ab76f52e6a0c4c05168b29932647"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::AbstractMatcher::set_current_and_peek_more </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the current match position in the buffer and peek for more text, allows large buffer shifts that aren't pinned to txt_. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loc</td><td>we don't need to keep text before this location in the buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aec6dcc2b180a7139b52a6bfe1ebabf1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::AbstractMatcher::set_end </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>eof</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set and force the end of input state. </p>

</div>
</div>
<a class="anchor" id="aaf7e85c26dc2e1252f8fb0511cf16067"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::AbstractMatcher::set_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structreflex_1_1_abstract_matcher_1_1_handler.html">Handler</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set event handler functor to invoke when the buffer contents are shifted out, e.g. for logging the data searched. </p>

</div>
</div>
<a class="anchor" id="aa245e6bd153a154df15c6f9fb099cdbe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::AbstractMatcher::set_reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set reserved bytes for buffer shifting. </p>

</div>
</div>
<a class="anchor" id="adb5fec59e6c6a86b8cf405c40f93d1de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::AbstractMatcher::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the matched text in number of bytes, including pattern-matched \0s, a constant-time operation. </p>
<dl class="section return"><dt>Returns</dt><dd>match size in bytes </dd></dl>

</div>
</div>
<a class="anchor" id="ae2a0eec56234f6a9bf41ccac081eefcc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::AbstractMatcher::skip </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skip input until the specified ASCII character is consumed and return true, or EOF is reached and return false. </p>
<dl class="section return"><dt>Returns</dt><dd>true if skipped to c, false if EOF is reached </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>ASCII character to skip to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af70edc517e887a9e5ce6c84b0f9cd2bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::AbstractMatcher::skip </td>
          <td>(</td>
          <td class="paramtype">wchar_t&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skip input until the specified <a class="el" href="namespacereflex_1_1_unicode.html">Unicode</a> character is consumed and return true, or EOF is reached and return false. </p>
<dl class="section return"><dt>Returns</dt><dd>true if skipped to c, false if EOF is reached </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td><a class="el" href="namespacereflex_1_1_unicode.html">Unicode</a> character to skip to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acd635f7dd7cedc5178f0c200ae154b6b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::AbstractMatcher::skip </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skip input until the specified literal UTF-8 string is consumed and return true, or EOF is reached and return false. </p>
<dl class="section return"><dt>Returns</dt><dd>true if skipped to c, false if EOF is reached </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>literal UTF-8 string to skip to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a771e92db1fbe8cc7dfdd5d4972e7679a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* reflex::AbstractMatcher::span </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enlarge the match to span the entire line of input (excluding <br />
), return <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated pattern match as a char pointer, does not include matched \0s, this is a constant-time operation. ">text()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>const char* span of text for the entire line </dd></dl>

</div>
</div>
<a class="anchor" id="a9c1d2913a158699703eee6d5f603701b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string reflex::AbstractMatcher::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the text matched as a string, a copy of <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated pattern match as a char pointer, does not include matched \0s, this is a constant-time operation. ">text()</a>, may include pattern-matched \0s. </p>
<dl class="section return"><dt>Returns</dt><dd>string with text matched </dd></dl>

</div>
</div>
<a class="anchor" id="ae56a20f5b1cb4d25faea0e40508900c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::AbstractMatcher::tabs </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set tab size 1, 2, 4, or 8. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>tab size 1, 2, 4, or 8 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adfeac276b47b376ed2d8ace623d75efe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char reflex::AbstractMatcher::tabs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns current tab size 1, 2, 4, or 8. </p>

</div>
</div>
<a class="anchor" id="a009bad2d87f9bc2f18a9ae52cc08b9e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* reflex::AbstractMatcher::text </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns 0-terminated pattern match as a char pointer, does not include matched \0s, this is a constant-time operation. </p>
<dl class="section return"><dt>Returns</dt><dd>0-terminated const char* string with text matched </dd></dl>

</div>
</div>
<a class="anchor" id="a5fb536d7812fcf52017e9d452e96381a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::AbstractMatcher::unput </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put back one character (8-bit) on the input character sequence for matching, DANGER: invalidates the previous <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated pattern match as a char pointer, does not include matched \0s, this is a constant-time operation. ">text()</a> pointer and match info, unput is not honored when matching in-place using buffer(base, size) and nothing has been read yet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>8-bit character to put back </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa1b7e09cf2e74ffbf09fb65ebac337f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int reflex::AbstractMatcher::wchr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first wide character of the text matched. </p>
<dl class="section return"><dt>Returns</dt><dd>wide char (UTF-8 converted to <a class="el" href="namespacereflex_1_1_unicode.html">Unicode</a>) </dd></dl>

</div>
</div>
<a class="anchor" id="a6ee94acd13edc05acfa087499d650a8f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int reflex::AbstractMatcher::winput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the next wide character (unsigned 0..U+10FFFF or EOF) from the input character sequence, while preserving the current <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated pattern match as a char pointer, does not include matched \0s, this is a constant-time operation. ">text()</a> match (but pointer returned by <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated pattern match as a char pointer, does not include matched \0s, this is a constant-time operation. ">text()</a> may change; warning: does not preserve the yytext string pointer when options &ndash;flex and &ndash;bison are used). </p>
<dl class="section return"><dt>Returns</dt><dd>the next wide character (unsigned 0..U+10FFFF) or EOF (-1) </dd></dl>

</div>
</div>
<a class="anchor" id="a95e5d61efacabcb1807922e2d9404a1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring reflex::AbstractMatcher::wline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the line of input (excluding <br />
) as a wide string containing the matched text as a substring. </p>
<dl class="section return"><dt>Returns</dt><dd>matching line as a wide string </dd></dl>

</div>
</div>
<a class="anchor" id="ae51a6d149b4147a1ac7d64b2d6587bd3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;size_t,std::wstring&gt; reflex::AbstractMatcher::wpair </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns std::pair&lt;size_t,std::wstring&gt;(<a class="el" href="classreflex_1_1_abstract_matcher.html#af51252ce359e6106b58c81f70776ccfb" title="Returns a positive integer (true) indicating the capture index of the matched text in the pattern or ...">accept()</a>, <a class="el" href="classreflex_1_1_abstract_matcher.html#a28cef361d991985fc4b28166d91ee15d" title="Returns the pattern match as a wide string, converted from UTF-8 text(), may include pattern-matched ...">wstr()</a>), useful for tokenizing input into containers of pairs. </p>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;size_t,std::wstring&gt;(<a class="el" href="classreflex_1_1_abstract_matcher.html#af51252ce359e6106b58c81f70776ccfb" title="Returns a positive integer (true) indicating the capture index of the matched text in the pattern or ...">accept()</a>, <a class="el" href="classreflex_1_1_abstract_matcher.html#a28cef361d991985fc4b28166d91ee15d" title="Returns the pattern match as a wide string, converted from UTF-8 text(), may include pattern-matched ...">wstr()</a>) </dd></dl>

</div>
</div>
<a class="anchor" id="a046e0696b048d229ea2d77f5010c41e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool reflex::AbstractMatcher::wrap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if wrapping of input after EOF is supported. </p>
<dl class="section return"><dt>Returns</dt><dd>true if input was succesfully wrapped </dd></dl>

</div>
</div>
<a class="anchor" id="af4bcff50974291fa01d4f7f7db4c77f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::AbstractMatcher::wsize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the matched text in number of wide characters. </p>
<dl class="section return"><dt>Returns</dt><dd>the length of the match in number of wide (multibyte UTF-8) characters </dd></dl>

</div>
</div>
<a class="anchor" id="a28cef361d991985fc4b28166d91ee15d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring reflex::AbstractMatcher::wstr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the pattern match as a wide string, converted from UTF-8 <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated pattern match as a char pointer, does not include matched \0s, this is a constant-time operation. ">text()</a>, may include pattern-matched \0s. </p>
<dl class="section return"><dt>Returns</dt><dd>wide string with text matched </dd></dl>

</div>
</div>
<a class="anchor" id="abd671ea3d606cab955cf6353267f62fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::AbstractMatcher::wunput </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put back one (wide) character on the input character sequence for matching, DANGER: invalidates the previous <a class="el" href="classreflex_1_1_abstract_matcher.html#a009bad2d87f9bc2f18a9ae52cc08b9e1" title="Returns 0-terminated pattern match as a char pointer, does not include matched \0s, this is a constant-time operation. ">text()</a> pointer and match info, unput is not honored when matching in-place using buffer(base, size) and nothing has been read yet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>character to put back </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a6e77a5e960482ff2ee1bb89e3c06c5eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::AbstractMatcher::blk_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>block size for block-based input reading, as set by <a class="el" href="classreflex_1_1_abstract_matcher.html#a0fb96965d228951194f0a2b9ee574dcf" title="Set buffer block size for reading: use 0 (or omit argument) to buffer all input in which case returns...">AbstractMatcher::buffer</a> </p>

</div>
</div>
<a class="anchor" id="acd3c54afa437eb1e6b0d9d227632c676"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* reflex::AbstractMatcher::bol_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>begin of line pointer in buffer </p>

</div>
</div>
<a class="anchor" id="a522144cc1e11d86a7a44f3f41acc4ba9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* reflex::AbstractMatcher::buf_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>input character sequence buffer </p>

</div>
</div>
<a class="anchor" id="a7dc1bd57b738b0eb3320a1861312d78e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::AbstractMatcher::cap_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>nonzero capture index of an accepted match or zero </p>

</div>
</div>
<a class="anchor" id="ae712053969ae8fadeee28c1e08421cf5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int reflex::AbstractMatcher::chr_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the character located at <a class="el" href="classreflex_1_1_abstract_matcher.html#a6ce676b26fd73f76186ed5cfb4a9b9dc" title="points to the matched text in buffer AbstractMatcher::buf_ ">AbstractMatcher::txt_</a>[<a class="el" href="classreflex_1_1_abstract_matcher.html#a63c1bbabe9a7e0dd1a8b43b9bce58dfc" title="size of the matched text ">AbstractMatcher::len_</a>] </p>

</div>
</div>
<a class="anchor" id="a355e00f049bb4151a282ce4ba0e91ef7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::AbstractMatcher::cml_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>true when counting matching lines instead of line numbers </p>

</div>
</div>
<a class="anchor" id="a92d20b0cfaa79571f201b52289c3fe2c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::AbstractMatcher::cno_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>column number count (cached) </p>

</div>
</div>
<a class="anchor" id="ac81507da95a6c54b6cc785a5460f0d57"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* reflex::AbstractMatcher::cpb_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>column pointer in buffer, updated when counting column numbers with <a class="el" href="classreflex_1_1_abstract_matcher.html#a51527a637b1964627dd34c722d905b65" title="Updates and returns the starting column number of the matched text, taking tab spacing into account a...">columno()</a> </p>

</div>
</div>
<a class="anchor" id="a19d1bb45408688e9fe41050363a2240c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::AbstractMatcher::cur_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>next position in <a class="el" href="classreflex_1_1_abstract_matcher.html#a522144cc1e11d86a7a44f3f41acc4ba9" title="input character sequence buffer ">AbstractMatcher::buf_</a> to assign to <a class="el" href="classreflex_1_1_abstract_matcher.html#a6ce676b26fd73f76186ed5cfb4a9b9dc" title="points to the matched text in buffer AbstractMatcher::buf_ ">AbstractMatcher::txt_</a> </p>

</div>
</div>
<a class="anchor" id="a5567cb2217e7d76122b4a7332cf12215"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::AbstractMatcher::end_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ending position of the input buffered in <a class="el" href="classreflex_1_1_abstract_matcher.html#a522144cc1e11d86a7a44f3f41acc4ba9" title="input character sequence buffer ">AbstractMatcher::buf_</a> </p>

</div>
</div>
<a class="anchor" id="a2bbc10723ccc884bb90ed85a0dbdaabd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::AbstractMatcher::eof_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>input has reached EOF </p>

</div>
</div>
<a class="anchor" id="a8d4857240b9fc10fae94e23401c345e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structreflex_1_1_abstract_matcher_1_1_handler.html">Handler</a>* reflex::AbstractMatcher::evh_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>event handler functor to invoke when buffer contents are shifted out </p>

</div>
</div>
<a class="anchor" id="a3ec40e4c9070975bcafa94af5db0e514"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_abstract_matcher_1_1_operation.html">Operation</a> reflex::AbstractMatcher::find</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>functor to search input </p>

</div>
</div>
<a class="anchor" id="a15e3fb0e851b132fd1e902de9ab56dba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int reflex::AbstractMatcher::got_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>last unsigned character we looked at (to determine anchors and boundaries) </p>

</div>
</div>
<a class="anchor" id="ae4e1dd16b4c2deca18d9093fc727ee3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_input.html">Input</a> reflex::AbstractMatcher::in</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>input character sequence being matched by this matcher </p>

</div>
</div>
<a class="anchor" id="ab0eb104096b1e02b78420bb02c89896c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::AbstractMatcher::ind_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>current indent position </p>

</div>
</div>
<a class="anchor" id="a63c1bbabe9a7e0dd1a8b43b9bce58dfc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::AbstractMatcher::len_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>size of the matched text </p>

</div>
</div>
<a class="anchor" id="ad237874fc8405e2f701765de41d6cd37"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::AbstractMatcher::lno_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>line number count (cached) </p>

</div>
</div>
<a class="anchor" id="aa1c72db1f90f67885fe585f27dc4eae8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* reflex::AbstractMatcher::lpb_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>line pointer in buffer, updated when counting line numbers with <a class="el" href="classreflex_1_1_abstract_matcher.html#a3bbfcc6386048d9c3613f7de919ba242" title="Updates and returns the starting line number of the match in the input character sequence. ">lineno()</a> </p>

</div>
</div>
<a class="anchor" id="a4fdfd4999a13a782643d33da7bd2b5cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::AbstractMatcher::mat_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>true if <a class="el" href="classreflex_1_1_abstract_matcher.html#ab880e6c8fe0df7c4ee7bb629aab41d0f" title="Returns nonzero capture index (i.e. true) if the entire input matches this matcher&#39;s pattern (and int...">AbstractMatcher::matches()</a> was successful </p>

</div>
</div>
<a class="anchor" id="a8c3372a98e775f5dd2d816d4f8dacf78"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::AbstractMatcher::max_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>total buffer size and max position + 1 to fill </p>

</div>
</div>
<a class="anchor" id="acf059b818f76cda98cfd8ef059d8586e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::AbstractMatcher::num_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>character count of the input till bol_ </p>

</div>
</div>
<a class="anchor" id="a7d944c389bc36abb15ba6c9f0601ab1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structreflex_1_1_abstract_matcher_1_1_option.html">Option</a> reflex::AbstractMatcher::opt_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>options for matcher engines </p>

</div>
</div>
<a class="anchor" id="a62b02b00048ab1b2bbb2b548f8b7aa02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::AbstractMatcher::own_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>true if <a class="el" href="classreflex_1_1_abstract_matcher.html#a522144cc1e11d86a7a44f3f41acc4ba9" title="input character sequence buffer ">AbstractMatcher::buf_</a> was allocated and should be deleted </p>

</div>
</div>
<a class="anchor" id="a028118ceb0a16e9ee12cfb74d7141689"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::AbstractMatcher::pos_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>position in <a class="el" href="classreflex_1_1_abstract_matcher.html#a522144cc1e11d86a7a44f3f41acc4ba9" title="input character sequence buffer ">AbstractMatcher::buf_</a> after <a class="el" href="classreflex_1_1_abstract_matcher.html#a6ce676b26fd73f76186ed5cfb4a9b9dc" title="points to the matched text in buffer AbstractMatcher::buf_ ">AbstractMatcher::txt_</a> </p>

</div>
</div>
<a class="anchor" id="abd02b16f2713de6acc4aa19b459848e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::AbstractMatcher::res_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reserve bytes to keep in the buffer before bol_ when shifting, use only w/o <a class="el" href="classreflex_1_1_abstract_matcher.html#a8d4857240b9fc10fae94e23401c345e1" title="event handler functor to invoke when buffer contents are shifted out ">evh_()</a> set </p>

</div>
</div>
<a class="anchor" id="a489c6327fb6521cc722852ada690f5ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_abstract_matcher_1_1_operation.html">Operation</a> reflex::AbstractMatcher::scan</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>functor to scan input (to tokenize input) </p>

</div>
</div>
<a class="anchor" id="a16d0cb13c2dca93cc556c06c24633b8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_abstract_matcher_1_1_operation.html">Operation</a> reflex::AbstractMatcher::split</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>functor to split input </p>

</div>
</div>
<a class="anchor" id="a6ce676b26fd73f76186ed5cfb4a9b9dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* reflex::AbstractMatcher::txt_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>points to the matched text in buffer <a class="el" href="classreflex_1_1_abstract_matcher.html#a522144cc1e11d86a7a44f3f41acc4ba9" title="input character sequence buffer ">AbstractMatcher::buf_</a> </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="absmatcher_8h.html">absmatcher.h</a></li>
</ul>
</div><!-- contents -->
<hr class="footer">
<address class="footer"><small>
Converted on Fri Jan 24 2025 10:30:13 by <a target="_blank" href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.11</small></address>
<br>
<div style="height: 246px; background: #DBDBDB;">
</body>
</html>
