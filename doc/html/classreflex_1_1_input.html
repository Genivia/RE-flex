<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta http-equiv="cache-control" content="no-cache">
<title>reflex::Input Class Reference</title>
<link href="doxygen_tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="doxygen_content.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top">
 <div id="titlearea">
  <table height="72px" width="100%" cellspacing="0" cellpadding="0">
   <tbody>
    <tr>
     <td width="10%">&nbsp;</td>
     <td><a href="https://github.com/Genivia/RE-flex"><img src="reflex-logo.png"/></a></td>
     <td>
      <div style="float: right; font-size: 18px; font-weight: bold;">reflex::Input Class Reference</div>
      <br>
      <div style="float: right; font-size: 10px;">updated Wed Jul 6 2022 by Robert van Engelen</div>
     </td>
     <td width="10%">&nbsp;</td>
    </tr>
   </tbody>
  </table>
 </div>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacereflex.html">reflex</a></li><li class="navelem"><a class="el" href="classreflex_1_1_input.html">Input</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classreflex_1_1_input-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">reflex::Input Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> character sequence class for unified access to sources of input text.  
 <a href="classreflex_1_1_input.html#details">More...</a></p>

<p><code>#include &lt;input.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for reflex::Input:</div>
<div class="dyncontent">
<div class="center"><img src="classreflex_1_1_input__inherit__graph.png" border="0" usemap="#reflex_1_1_input_inherit__map" alt="Inheritance graph"/></div>
<map name="reflex_1_1_input_inherit__map" id="reflex_1_1_input_inherit__map">
<area shape="rect" id="node2" href="classreflex_1_1_buffered_input.html" title="Buffered input. " alt="" coords="5,80,148,107"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for reflex::Input:</div>
<div class="dyncontent">
<div class="center"><img src="classreflex_1_1_input__coll__graph.png" border="0" usemap="#reflex_1_1_input_coll__map" alt="Collaboration graph"/></div>
<map name="reflex_1_1_input_coll__map" id="reflex_1_1_input_coll__map">
<area shape="rect" id="node2" href="structreflex_1_1_input_1_1_handler.html" title="FILE* handler functor base class to handle FILE* errors and non&#45;blocking FILE* reads. " alt="" coords="5,248,151,275"/>
<area shape="rect" id="node3" title="STL class. " alt="" coords="175,248,266,275"/>
<area shape="rect" id="node4" title="STL class. " alt="" coords="156,157,285,199"/>
<area shape="rect" id="node5" title="STL class. " alt="" coords="143,81,298,108"/>
<area shape="rect" id="node6" title="STL class. " alt="" coords="171,5,271,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input_1_1dos__streambuf.html">dos_streambuf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream buffer for <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a> to read DOS files, replaces CRLF by LF, derived from std::streambuf.  <a href="classreflex_1_1_input_1_1dos__streambuf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreflex_1_1_input_1_1file__encoding.html">file_encoding</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common <a class="el" href="structreflex_1_1_input_1_1file__encoding.html" title="Common file_encoding constants. ">file_encoding</a> constants.  <a href="structreflex_1_1_input_1_1file__encoding.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreflex_1_1_input_1_1_handler.html">Handler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">FILE* handler functor base class to handle FILE* errors and non-blocking FILE* reads.  <a href="structreflex_1_1_input_1_1_handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input_1_1streambuf.html">streambuf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream buffer for <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a>, derived from std::streambuf.  <a href="classreflex_1_1_input_1_1streambuf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a70e8550b0b1649b2cd49b1b872949cc8"><td class="memItemLeft" align="right" valign="top">typedef unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a70e8550b0b1649b2cd49b1b872949cc8">file_encoding_type</a></td></tr>
<tr class="memdesc:a70e8550b0b1649b2cd49b1b872949cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common <a class="el" href="structreflex_1_1_input_1_1file__encoding.html" title="Common file_encoding constants. ">file_encoding</a> constants type.  <a href="#a70e8550b0b1649b2cd49b1b872949cc8">More...</a><br /></td></tr>
<tr class="separator:a70e8550b0b1649b2cd49b1b872949cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8b27ba4af25d4add45d0e09bc2420e22"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a8b27ba4af25d4add45d0e09bc2420e22">Input</a> ()</td></tr>
<tr class="memdesc:a8b27ba4af25d4add45d0e09bc2420e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct empty input character sequence.  <a href="#a8b27ba4af25d4add45d0e09bc2420e22">More...</a><br /></td></tr>
<tr class="separator:a8b27ba4af25d4add45d0e09bc2420e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6455e576c90b478789928db6066267"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a7c6455e576c90b478789928db6066267">Input</a> (const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;input)</td></tr>
<tr class="memdesc:a7c6455e576c90b478789928db6066267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor (with intended "move semantics" as internal state is shared, should not rely on using the rhs after copying).  <a href="#a7c6455e576c90b478789928db6066267">More...</a><br /></td></tr>
<tr class="separator:a7c6455e576c90b478789928db6066267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578996e4f28eed9c8ee2a7997d51a3c6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a578996e4f28eed9c8ee2a7997d51a3c6">Input</a> (const char *<a class="el" href="classreflex_1_1_input.html#aa3638edd734832d054f3939b8665a77e">cstring</a>, size_t <a class="el" href="classreflex_1_1_input.html#a4d1e21f3356426598bc6dc139812de31">size</a>)</td></tr>
<tr class="memdesc:a578996e4f28eed9c8ee2a7997d51a3c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct input character sequence from a char* string.  <a href="#a578996e4f28eed9c8ee2a7997d51a3c6">More...</a><br /></td></tr>
<tr class="separator:a578996e4f28eed9c8ee2a7997d51a3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09465211ad37559885e2e85e9fc18791"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a09465211ad37559885e2e85e9fc18791">Input</a> (const char *<a class="el" href="classreflex_1_1_input.html#aa3638edd734832d054f3939b8665a77e">cstring</a>)</td></tr>
<tr class="memdesc:a09465211ad37559885e2e85e9fc18791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct input character sequence from a NUL-terminated string.  <a href="#a09465211ad37559885e2e85e9fc18791">More...</a><br /></td></tr>
<tr class="separator:a09465211ad37559885e2e85e9fc18791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4d78f4c05c7e5ffdaa723bf58ffaea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#aec4d78f4c05c7e5ffdaa723bf58ffaea">Input</a> (const std::string &amp;string)</td></tr>
<tr class="memdesc:aec4d78f4c05c7e5ffdaa723bf58ffaea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct input character sequence from a std::string.  <a href="#aec4d78f4c05c7e5ffdaa723bf58ffaea">More...</a><br /></td></tr>
<tr class="separator:aec4d78f4c05c7e5ffdaa723bf58ffaea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa309946c0340260b7213ff803544542b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#aa309946c0340260b7213ff803544542b">Input</a> (const std::string *string)</td></tr>
<tr class="memdesc:aa309946c0340260b7213ff803544542b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct input character sequence from a pointer to a std::string.  <a href="#aa309946c0340260b7213ff803544542b">More...</a><br /></td></tr>
<tr class="separator:aa309946c0340260b7213ff803544542b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057e2908a65efbb3ba0c445b724fe100"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a057e2908a65efbb3ba0c445b724fe100">Input</a> (const wchar_t *<a class="el" href="classreflex_1_1_input.html#aab0fd4f66d1a00060245ba2d6e427473">wstring</a>)</td></tr>
<tr class="memdesc:a057e2908a65efbb3ba0c445b724fe100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct input character sequence from a NUL-terminated wide character string.  <a href="#a057e2908a65efbb3ba0c445b724fe100">More...</a><br /></td></tr>
<tr class="separator:a057e2908a65efbb3ba0c445b724fe100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0d90a9095c8af1a09e6baa04710bc4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a4c0d90a9095c8af1a09e6baa04710bc4">Input</a> (const std::wstring &amp;<a class="el" href="classreflex_1_1_input.html#aab0fd4f66d1a00060245ba2d6e427473">wstring</a>)</td></tr>
<tr class="memdesc:a4c0d90a9095c8af1a09e6baa04710bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct input character sequence from a std::wstring (may contain UTF-16 surrogate pairs).  <a href="#a4c0d90a9095c8af1a09e6baa04710bc4">More...</a><br /></td></tr>
<tr class="separator:a4c0d90a9095c8af1a09e6baa04710bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c30dabe3972582d662517d42cf75a4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a02c30dabe3972582d662517d42cf75a4">Input</a> (const std::wstring *<a class="el" href="classreflex_1_1_input.html#aab0fd4f66d1a00060245ba2d6e427473">wstring</a>)</td></tr>
<tr class="memdesc:a02c30dabe3972582d662517d42cf75a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct input character sequence from a pointer to a std::wstring (may contain UTF-16 surrogate pairs).  <a href="#a02c30dabe3972582d662517d42cf75a4">More...</a><br /></td></tr>
<tr class="separator:a02c30dabe3972582d662517d42cf75a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13135ec6cf70ed5d16396ad2db5b0c7b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a13135ec6cf70ed5d16396ad2db5b0c7b">Input</a> (FILE *<a class="el" href="classreflex_1_1_input.html#a9f64e5c813a08fd7a65819074ffcd20a">file</a>)</td></tr>
<tr class="memdesc:a13135ec6cf70ed5d16396ad2db5b0c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct input character sequence from an open FILE* file descriptor, supports UTF-8 conversion from UTF-16 and UTF-32.  <a href="#a13135ec6cf70ed5d16396ad2db5b0c7b">More...</a><br /></td></tr>
<tr class="separator:a13135ec6cf70ed5d16396ad2db5b0c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609f0e4676584113831ea9bff651dada"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a609f0e4676584113831ea9bff651dada">Input</a> (FILE *<a class="el" href="classreflex_1_1_input.html#a9f64e5c813a08fd7a65819074ffcd20a">file</a>, <a class="el" href="classreflex_1_1_input.html#a70e8550b0b1649b2cd49b1b872949cc8">file_encoding_type</a> enc, const unsigned short *page=NULL)</td></tr>
<tr class="memdesc:a609f0e4676584113831ea9bff651dada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct input character sequence from an open FILE* file descriptor, using the specified file encoding.  <a href="#a609f0e4676584113831ea9bff651dada">More...</a><br /></td></tr>
<tr class="separator:a609f0e4676584113831ea9bff651dada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a25a1b7ebdda31f175e0139713212f1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a2a25a1b7ebdda31f175e0139713212f1">Input</a> (std::istream &amp;<a class="el" href="classreflex_1_1_input.html#a42f00a3d62dd4627413a9f8180f2860b">istream</a>)</td></tr>
<tr class="memdesc:a2a25a1b7ebdda31f175e0139713212f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct input character sequence from a std::istream.  <a href="#a2a25a1b7ebdda31f175e0139713212f1">More...</a><br /></td></tr>
<tr class="separator:a2a25a1b7ebdda31f175e0139713212f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a96b263a02333550b1d7d6cd21d776"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#af5a96b263a02333550b1d7d6cd21d776">Input</a> (std::istream *<a class="el" href="classreflex_1_1_input.html#a42f00a3d62dd4627413a9f8180f2860b">istream</a>)</td></tr>
<tr class="memdesc:af5a96b263a02333550b1d7d6cd21d776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct input character sequence from a pointer to a std::istream.  <a href="#af5a96b263a02333550b1d7d6cd21d776">More...</a><br /></td></tr>
<tr class="separator:af5a96b263a02333550b1d7d6cd21d776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822489aba32803c08ed6db9f50f2caf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_input.html">Input</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a822489aba32803c08ed6db9f50f2caf5">operator=</a> (const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;input)</td></tr>
<tr class="memdesc:a822489aba32803c08ed6db9f50f2caf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#a822489aba32803c08ed6db9f50f2caf5">More...</a><br /></td></tr>
<tr class="separator:a822489aba32803c08ed6db9f50f2caf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3031e26bf48ef36126f7d789793b4a3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#ab3031e26bf48ef36126f7d789793b4a3">operator const char *</a> () const </td></tr>
<tr class="memdesc:ab3031e26bf48ef36126f7d789793b4a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object to a string, returns NULL when this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> is not a string.  <a href="#ab3031e26bf48ef36126f7d789793b4a3">More...</a><br /></td></tr>
<tr class="separator:ab3031e26bf48ef36126f7d789793b4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77a9713fc879a2b9338893769e8f617"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#ae77a9713fc879a2b9338893769e8f617">operator const wchar_t *</a> () const </td></tr>
<tr class="memdesc:ae77a9713fc879a2b9338893769e8f617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object to a wide character string, returns NULL when this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> is not a wide string.  <a href="#ae77a9713fc879a2b9338893769e8f617">More...</a><br /></td></tr>
<tr class="separator:ae77a9713fc879a2b9338893769e8f617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7432231f90678cb115ee3dfa82a2a53b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a7432231f90678cb115ee3dfa82a2a53b">operator FILE *</a> () const </td></tr>
<tr class="memdesc:a7432231f90678cb115ee3dfa82a2a53b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object to a file descriptor FILE*, returns NULL when this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> is not a FILE*.  <a href="#a7432231f90678cb115ee3dfa82a2a53b">More...</a><br /></td></tr>
<tr class="separator:a7432231f90678cb115ee3dfa82a2a53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4931b283c79df0c3541e4000ef065b53"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a4931b283c79df0c3541e4000ef065b53">operator std::istream *</a> () const </td></tr>
<tr class="memdesc:a4931b283c79df0c3541e4000ef065b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object to a std::istream*, returns NULL when this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> is not a std::istream.  <a href="#a4931b283c79df0c3541e4000ef065b53">More...</a><br /></td></tr>
<tr class="separator:a4931b283c79df0c3541e4000ef065b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab728a9612c2ddd8e30f97bf094dfbe6c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#ab728a9612c2ddd8e30f97bf094dfbe6c">operator bool</a> () const </td></tr>
<tr class="separator:ab728a9612c2ddd8e30f97bf094dfbe6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3638edd734832d054f3939b8665a77e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#aa3638edd734832d054f3939b8665a77e">cstring</a> () const </td></tr>
<tr class="memdesc:aa3638edd734832d054f3939b8665a77e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the remaining string of this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object, returns NULL when this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> is not a string.  <a href="#aa3638edd734832d054f3939b8665a77e">More...</a><br /></td></tr>
<tr class="separator:aa3638edd734832d054f3939b8665a77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0fd4f66d1a00060245ba2d6e427473"><td class="memItemLeft" align="right" valign="top">const wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#aab0fd4f66d1a00060245ba2d6e427473">wstring</a> () const </td></tr>
<tr class="memdesc:aab0fd4f66d1a00060245ba2d6e427473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the remaining wide character string of this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object, returns NULL when this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> is not a wide string.  <a href="#aab0fd4f66d1a00060245ba2d6e427473">More...</a><br /></td></tr>
<tr class="separator:aab0fd4f66d1a00060245ba2d6e427473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f64e5c813a08fd7a65819074ffcd20a"><td class="memItemLeft" align="right" valign="top">FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a9f64e5c813a08fd7a65819074ffcd20a">file</a> () const </td></tr>
<tr class="memdesc:a9f64e5c813a08fd7a65819074ffcd20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the FILE* of this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object, returns NULL when this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> is not a FILE*.  <a href="#a9f64e5c813a08fd7a65819074ffcd20a">More...</a><br /></td></tr>
<tr class="separator:a9f64e5c813a08fd7a65819074ffcd20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f00a3d62dd4627413a9f8180f2860b"><td class="memItemLeft" align="right" valign="top">std::istream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a42f00a3d62dd4627413a9f8180f2860b">istream</a> () const </td></tr>
<tr class="memdesc:a42f00a3d62dd4627413a9f8180f2860b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the std::istream of this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object, returns NULL when this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> is not a std::istream.  <a href="#a42f00a3d62dd4627413a9f8180f2860b">More...</a><br /></td></tr>
<tr class="separator:a42f00a3d62dd4627413a9f8180f2860b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1e21f3356426598bc6dc139812de31"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a4d1e21f3356426598bc6dc139812de31">size</a> ()</td></tr>
<tr class="memdesc:a4d1e21f3356426598bc6dc139812de31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the input character sequence in number of ASCII/UTF-8 bytes (zero if size is not determinable from a <code>FILE*</code> or <code>std::istream</code> source).  <a href="#a4d1e21f3356426598bc6dc139812de31">More...</a><br /></td></tr>
<tr class="separator:a4d1e21f3356426598bc6dc139812de31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e2de67c899897d38e39eedb2c8ce3a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a21e2de67c899897d38e39eedb2c8ce3a">assigned</a> () const </td></tr>
<tr class="memdesc:a21e2de67c899897d38e39eedb2c8ce3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object was assigned a character sequence.  <a href="#a21e2de67c899897d38e39eedb2c8ce3a">More...</a><br /></td></tr>
<tr class="separator:a21e2de67c899897d38e39eedb2c8ce3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8062373d7ce9522e1962af7fd9a49a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a2d8062373d7ce9522e1962af7fd9a49a">clear</a> ()</td></tr>
<tr class="memdesc:a2d8062373d7ce9522e1962af7fd9a49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> by unassigning it.  <a href="#a2d8062373d7ce9522e1962af7fd9a49a">More...</a><br /></td></tr>
<tr class="separator:a2d8062373d7ce9522e1962af7fd9a49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad889f01290e7a5cdfd14b4c662635ff8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#ad889f01290e7a5cdfd14b4c662635ff8">good</a> () const </td></tr>
<tr class="memdesc:ad889f01290e7a5cdfd14b4c662635ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if input is available.  <a href="#ad889f01290e7a5cdfd14b4c662635ff8">More...</a><br /></td></tr>
<tr class="separator:ad889f01290e7a5cdfd14b4c662635ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66cbeb78ac9c238f08ce5aa570b1fb7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#ae66cbeb78ac9c238f08ce5aa570b1fb7">eof</a> () const </td></tr>
<tr class="memdesc:ae66cbeb78ac9c238f08ce5aa570b1fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if input reached EOF.  <a href="#ae66cbeb78ac9c238f08ce5aa570b1fb7">More...</a><br /></td></tr>
<tr class="separator:ae66cbeb78ac9c238f08ce5aa570b1fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e95f4f8c324d1249ee45b41648f114"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a48e95f4f8c324d1249ee45b41648f114">get</a> ()</td></tr>
<tr class="memdesc:a48e95f4f8c324d1249ee45b41648f114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a single character (unsigned char 0..255) or EOF (-1) when end-of-input is reached.  <a href="#a48e95f4f8c324d1249ee45b41648f114">More...</a><br /></td></tr>
<tr class="separator:a48e95f4f8c324d1249ee45b41648f114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3830a022486d78670f01003b56d5e5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a3a3830a022486d78670f01003b56d5e5">get</a> (char *s, size_t n)</td></tr>
<tr class="memdesc:a3a3830a022486d78670f01003b56d5e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy character sequence data into buffer.  <a href="#a3a3830a022486d78670f01003b56d5e5">More...</a><br /></td></tr>
<tr class="separator:a3a3830a022486d78670f01003b56d5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25682c7ebc7df115ade370d9d21ed888"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a25682c7ebc7df115ade370d9d21ed888">file_encoding</a> (<a class="el" href="classreflex_1_1_input.html#a70e8550b0b1649b2cd49b1b872949cc8">file_encoding_type</a> enc, const unsigned short *page=NULL)</td></tr>
<tr class="memdesc:a25682c7ebc7df115ade370d9d21ed888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set encoding for <code>FILE*</code> input.  <a href="#a25682c7ebc7df115ade370d9d21ed888">More...</a><br /></td></tr>
<tr class="separator:a25682c7ebc7df115ade370d9d21ed888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae553aa63a3a04e836b8aed8ef524a92e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_input.html#a70e8550b0b1649b2cd49b1b872949cc8">file_encoding_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#ae553aa63a3a04e836b8aed8ef524a92e">file_encoding</a> () const </td></tr>
<tr class="memdesc:ae553aa63a3a04e836b8aed8ef524a92e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get encoding of the current <code>FILE*</code> input.  <a href="#ae553aa63a3a04e836b8aed8ef524a92e">More...</a><br /></td></tr>
<tr class="separator:ae553aa63a3a04e836b8aed8ef524a92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b77d701d8ad80bd4e235e397c180bd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a3b77d701d8ad80bd4e235e397c180bd5">init</a> ()</td></tr>
<tr class="memdesc:a3b77d701d8ad80bd4e235e397c180bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the state after (re)setting the input source, auto-detects UTF BOM in FILE* input if the file size is known.  <a href="#a3b77d701d8ad80bd4e235e397c180bd5">More...</a><br /></td></tr>
<tr class="separator:a3b77d701d8ad80bd4e235e397c180bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2504b809d5be558d426618737c3e168d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a2504b809d5be558d426618737c3e168d">file_init</a> ()</td></tr>
<tr class="memdesc:a2504b809d5be558d426618737c3e168d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by <a class="el" href="classreflex_1_1_input.html#a3b77d701d8ad80bd4e235e397c180bd5" title="Initialize the state after (re)setting the input source, auto-detects UTF BOM in FILE* input if the f...">init()</a> for a FILE*.  <a href="#a2504b809d5be558d426618737c3e168d">More...</a><br /></td></tr>
<tr class="separator:a2504b809d5be558d426618737c3e168d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba3f1e2d412fafce6245f38b4381fcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a7ba3f1e2d412fafce6245f38b4381fcb">wstring_size</a> ()</td></tr>
<tr class="memdesc:a7ba3f1e2d412fafce6245f38b4381fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by <a class="el" href="classreflex_1_1_input.html#a4d1e21f3356426598bc6dc139812de31" title="Get the size of the input character sequence in number of ASCII/UTF-8 bytes (zero if size is not dete...">size()</a> for a wstring.  <a href="#a7ba3f1e2d412fafce6245f38b4381fcb">More...</a><br /></td></tr>
<tr class="separator:a7ba3f1e2d412fafce6245f38b4381fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d09f141e2ced0bc27129809cdbfc4f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a7d09f141e2ced0bc27129809cdbfc4f1">file_size</a> ()</td></tr>
<tr class="memdesc:a7d09f141e2ced0bc27129809cdbfc4f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by <a class="el" href="classreflex_1_1_input.html#a4d1e21f3356426598bc6dc139812de31" title="Get the size of the input character sequence in number of ASCII/UTF-8 bytes (zero if size is not dete...">size()</a> for a FILE*.  <a href="#a7d09f141e2ced0bc27129809cdbfc4f1">More...</a><br /></td></tr>
<tr class="separator:a7d09f141e2ced0bc27129809cdbfc4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603cfde978e8ff1153073540ff39aae8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a603cfde978e8ff1153073540ff39aae8">istream_size</a> ()</td></tr>
<tr class="memdesc:a603cfde978e8ff1153073540ff39aae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by <a class="el" href="classreflex_1_1_input.html#a4d1e21f3356426598bc6dc139812de31" title="Get the size of the input character sequence in number of ASCII/UTF-8 bytes (zero if size is not dete...">size()</a> for a std::istream.  <a href="#a603cfde978e8ff1153073540ff39aae8">More...</a><br /></td></tr>
<tr class="separator:a603cfde978e8ff1153073540ff39aae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37dd7c46da3413a52866bee4bb060cc5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a37dd7c46da3413a52866bee4bb060cc5">file_get</a> (char *s, size_t n)</td></tr>
<tr class="memdesc:a37dd7c46da3413a52866bee4bb060cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classreflex_1_1_input.html#a48e95f4f8c324d1249ee45b41648f114" title="Get a single character (unsigned char 0..255) or EOF (-1) when end-of-input is reached. ">get()</a> on a FILE*.  <a href="#a37dd7c46da3413a52866bee4bb060cc5">More...</a><br /></td></tr>
<tr class="separator:a37dd7c46da3413a52866bee4bb060cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3476671e945e7fb14e1aa800b8db15bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a3476671e945e7fb14e1aa800b8db15bc">set_handler</a> (<a class="el" href="structreflex_1_1_input_1_1_handler.html">Handler</a> *handler)</td></tr>
<tr class="memdesc:a3476671e945e7fb14e1aa800b8db15bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set FILE* handler.  <a href="#a3476671e945e7fb14e1aa800b8db15bc">More...</a><br /></td></tr>
<tr class="separator:a3476671e945e7fb14e1aa800b8db15bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ac621d556b409c90464780ea44b8d6570"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#ac621d556b409c90464780ea44b8d6570">cstring_</a></td></tr>
<tr class="memdesc:ac621d556b409c90464780ea44b8d6570"><td class="mdescLeft">&#160;</td><td class="mdescRight">char string input (when non-null) of length <a class="el" href="classreflex_1_1_input.html#a4ca4ea90ef6f28c106a6811ff21bcc2b" title="size of the remaining input in bytes (size_ == 0 may indicate size is not set) ">reflex::Input::size_</a>  <a href="#ac621d556b409c90464780ea44b8d6570">More...</a><br /></td></tr>
<tr class="separator:ac621d556b409c90464780ea44b8d6570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6107c7aabf9c28a777c3942442c3b22f"><td class="memItemLeft" align="right" valign="top">const wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a6107c7aabf9c28a777c3942442c3b22f">wstring_</a></td></tr>
<tr class="memdesc:a6107c7aabf9c28a777c3942442c3b22f"><td class="mdescLeft">&#160;</td><td class="mdescRight">NUL-terminated wide string input (when non-null)  <a href="#a6107c7aabf9c28a777c3942442c3b22f">More...</a><br /></td></tr>
<tr class="separator:a6107c7aabf9c28a777c3942442c3b22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9eac97d0e608b436ab2c10620e68fb5"><td class="memItemLeft" align="right" valign="top">FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#ae9eac97d0e608b436ab2c10620e68fb5">file_</a></td></tr>
<tr class="memdesc:ae9eac97d0e608b436ab2c10620e68fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">FILE* input (when non-null)  <a href="#ae9eac97d0e608b436ab2c10620e68fb5">More...</a><br /></td></tr>
<tr class="separator:ae9eac97d0e608b436ab2c10620e68fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5293a8f00869af77ce8036312d78591c"><td class="memItemLeft" align="right" valign="top">std::istream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a5293a8f00869af77ce8036312d78591c">istream_</a></td></tr>
<tr class="memdesc:a5293a8f00869af77ce8036312d78591c"><td class="mdescLeft">&#160;</td><td class="mdescRight">stream input (when non-null)  <a href="#a5293a8f00869af77ce8036312d78591c">More...</a><br /></td></tr>
<tr class="separator:a5293a8f00869af77ce8036312d78591c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca4ea90ef6f28c106a6811ff21bcc2b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a4ca4ea90ef6f28c106a6811ff21bcc2b">size_</a></td></tr>
<tr class="memdesc:a4ca4ea90ef6f28c106a6811ff21bcc2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">size of the remaining input in bytes (size_ == 0 may indicate size is not set)  <a href="#a4ca4ea90ef6f28c106a6811ff21bcc2b">More...</a><br /></td></tr>
<tr class="separator:a4ca4ea90ef6f28c106a6811ff21bcc2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb61be8907f3204e7b3583aaa5b72da"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a2fb61be8907f3204e7b3583aaa5b72da">utf8_</a> [8]</td></tr>
<tr class="memdesc:a2fb61be8907f3204e7b3583aaa5b72da"><td class="mdescLeft">&#160;</td><td class="mdescRight">UTF-8 normalization buffer, &gt;=8 bytes.  <a href="#a2fb61be8907f3204e7b3583aaa5b72da">More...</a><br /></td></tr>
<tr class="separator:a2fb61be8907f3204e7b3583aaa5b72da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371264ce1908a198cc11a7d6990ccbcc"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a371264ce1908a198cc11a7d6990ccbcc">uidx_</a></td></tr>
<tr class="memdesc:a371264ce1908a198cc11a7d6990ccbcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">index in utf8_[]  <a href="#a371264ce1908a198cc11a7d6990ccbcc">More...</a><br /></td></tr>
<tr class="separator:a371264ce1908a198cc11a7d6990ccbcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373a13951b67f53d44f923eff79ff563"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a373a13951b67f53d44f923eff79ff563">ulen_</a></td></tr>
<tr class="memdesc:a373a13951b67f53d44f923eff79ff563"><td class="mdescLeft">&#160;</td><td class="mdescRight">length of data (remaining after uidx_) in utf8_[] or 0 if no data  <a href="#a373a13951b67f53d44f923eff79ff563">More...</a><br /></td></tr>
<tr class="separator:a373a13951b67f53d44f923eff79ff563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8877e55c75a97a09e3e9e2fb564b1774"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_input.html#a70e8550b0b1649b2cd49b1b872949cc8">file_encoding_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a8877e55c75a97a09e3e9e2fb564b1774">utfx_</a></td></tr>
<tr class="memdesc:a8877e55c75a97a09e3e9e2fb564b1774"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_input_1_1file__encoding.html" title="Common file_encoding constants. ">file_encoding</a>  <a href="#a8877e55c75a97a09e3e9e2fb564b1774">More...</a><br /></td></tr>
<tr class="separator:a8877e55c75a97a09e3e9e2fb564b1774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc6c55cd219a6717e536bd6c9f0606d"><td class="memItemLeft" align="right" valign="top">const unsigned short *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#accc6c55cd219a6717e536bd6c9f0606d">page_</a></td></tr>
<tr class="memdesc:accc6c55cd219a6717e536bd6c9f0606d"><td class="mdescLeft">&#160;</td><td class="mdescRight">custom code page  <a href="#accc6c55cd219a6717e536bd6c9f0606d">More...</a><br /></td></tr>
<tr class="separator:accc6c55cd219a6717e536bd6c9f0606d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6497a192b830e0976282720243a10a52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structreflex_1_1_input_1_1_handler.html">Handler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a6497a192b830e0976282720243a10a52">handler_</a></td></tr>
<tr class="memdesc:a6497a192b830e0976282720243a10a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">to handle FILE* errors and non-blocking FILE* reads  <a href="#a6497a192b830e0976282720243a10a52">More...</a><br /></td></tr>
<tr class="separator:a6497a192b830e0976282720243a10a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> character sequence class for unified access to sources of input text. </p>
<h2>Description </h2>
<p>The <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> class unifies access to a source of input text that constitutes a sequence of characters:</p>
<ul>
<li>An <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object is instantiated and (re)assigned a (new) source input: either a <code>char*</code> string, a <code>wchar_t*</code> wide string, a <code>std::string</code>, a <code>std::wstring</code>, a <code>FILE*</code> descriptor, or a <code>std::istream</code> object.</li>
<li>Strings specified as input must be persistent and cannot be temporary. The input string contents are incrementally extracted and converted as necessary, when specified with an encoding format <code><a class="el" href="structreflex_1_1_input_1_1file__encoding.html" title="Common file_encoding constants. ">reflex::Input::file_encoding</a></code>.</li>
<li>When assigned a wide string source as input, the wide character content is automatically converted to an UTF-8 character sequence when reading with <a class="el" href="classreflex_1_1_input.html#a48e95f4f8c324d1249ee45b41648f114" title="Get a single character (unsigned char 0..255) or EOF (-1) when end-of-input is reached. ">get()</a>. Wide strings are UCS-2/UCS-4 and may contain UTF-16 surrogate pairs.</li>
<li>When assigned a <code>FILE*</code> source as input, the file is checked for the presence of a UTF-8 or a UTF-16 BOM (Byte Order Mark). A UTF-8 BOM is ignored and will not appear on the input character stream (and size is adjusted by 3 bytes). A UTF-16 BOM is intepreted, resulting in the conversion of the file content automatically to an UTF-8 character sequence when reading the file with <a class="el" href="classreflex_1_1_input.html#a48e95f4f8c324d1249ee45b41648f114" title="Get a single character (unsigned char 0..255) or EOF (-1) when end-of-input is reached. ">get()</a>. Also, <a class="el" href="classreflex_1_1_input.html#a4d1e21f3356426598bc6dc139812de31" title="Get the size of the input character sequence in number of ASCII/UTF-8 bytes (zero if size is not dete...">size()</a> gives the content size in the number of UTF-8 bytes.</li>
<li>An input object can be reassigned a new source of input for reading at any time.</li>
<li>An input object obeys move semantics. That is, after assigning an input object to another, the former can no longer be used to read input. This prevents adding the overhead and complexity of file and stream duplication.</li>
<li><code>size_t <a class="el" href="classreflex_1_1_input.html#a3a3830a022486d78670f01003b56d5e5" title="Copy character sequence data into buffer. ">Input::get(char *buf, size_t len)</a>;</code> reads source input and fills <code>buf</code> with up to <code>len</code> bytes, returning the number of bytes read or zero when a stream or file is bad or when EOF is reached.</li>
<li><code>size_t <a class="el" href="classreflex_1_1_input.html#a4d1e21f3356426598bc6dc139812de31" title="Get the size of the input character sequence in number of ASCII/UTF-8 bytes (zero if size is not dete...">Input::size()</a>;</code> returns the number of ASCII/UTF-8 bytes available to read from the source input or zero (zero is also returned when the size is not determinable). Use this function only before reading input with <a class="el" href="classreflex_1_1_input.html#a48e95f4f8c324d1249ee45b41648f114" title="Get a single character (unsigned char 0..255) or EOF (-1) when end-of-input is reached. ">get()</a>. Wide character strings and UTF-16 <code>FILE*</code> content is counted as the total number of UTF-8 bytes that will be produced by <a class="el" href="classreflex_1_1_input.html#a48e95f4f8c324d1249ee45b41648f114" title="Get a single character (unsigned char 0..255) or EOF (-1) when end-of-input is reached. ">get()</a>. The size of a <code>std::istream</code> cannot be determined.</li>
<li><code>bool <a class="el" href="classreflex_1_1_input.html#ad889f01290e7a5cdfd14b4c662635ff8" title="Check if input is available. ">Input::good()</a>;</code> returns true if the input is readable and has no EOF or error state. Returns false on EOF or if an error condition is present.</li>
<li><code>bool <a class="el" href="classreflex_1_1_input.html#ae66cbeb78ac9c238f08ce5aa570b1fb7" title="Check if input reached EOF. ">Input::eof()</a>;</code> returns true if the input reached EOF. Note that <a class="el" href="classreflex_1_1_input.html#ad889f01290e7a5cdfd14b4c662635ff8" title="Check if input is available. ">good()</a> == ! <a class="el" href="classreflex_1_1_input.html#ae66cbeb78ac9c238f08ce5aa570b1fb7" title="Check if input reached EOF. ">eof()</a> for string source input only, since files and streams may have error conditions that prevent reading. That is, for files and streams <a class="el" href="classreflex_1_1_input.html#ae66cbeb78ac9c238f08ce5aa570b1fb7" title="Check if input reached EOF. ">eof()</a> implies <a class="el" href="classreflex_1_1_input.html#ad889f01290e7a5cdfd14b4c662635ff8" title="Check if input is available. ">good()</a> == false, but not vice versa. Thus, an error is diagnosed when the condition <a class="el" href="classreflex_1_1_input.html#ad889f01290e7a5cdfd14b4c662635ff8" title="Check if input is available. ">good()</a> == false &amp;&amp; <a class="el" href="classreflex_1_1_input.html#ae66cbeb78ac9c238f08ce5aa570b1fb7" title="Check if input reached EOF. ">eof()</a> == false holds. Note that get(buf, len) == 0 &amp;&amp; len &gt; 0 implies <a class="el" href="classreflex_1_1_input.html#ad889f01290e7a5cdfd14b4c662635ff8" title="Check if input is available. ">good()</a> == false.</li>
<li><code>class Input::streambbuf(const Input&amp;)</code> creates a <code>std::istream</code> for the given <code><a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a></code> object.</li>
<li>Compile with <code>WITH_UTF8_UNRESTRICTED</code> to enable unrestricted UTF-8 beyond U+10FFFF, permitting lossless UTF-8 encoding of 32 bit words without limits.</li>
</ul>
<h2>Example </h2>
<p>The following example shows how to use the <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> class to read a character sequence in blocks from a <code>std::ifstream</code> to copy to stdout:</p>
<div class="fragment"><div class="line">std::ifstream ifs;</div><div class="line">ifs.open(<span class="stringliteral">&quot;input.h&quot;</span>, std::ifstream::in);</div><div class="line"><a class="code" href="classreflex_1_1_input.html">reflex::Input</a> input(ifs);</div><div class="line"><span class="keywordtype">char</span> buf[1024];</div><div class="line"><span class="keywordtype">size_t</span> len;</div><div class="line"><span class="keywordflow">while</span> ((len = input.get(buf, <span class="keyword">sizeof</span>(buf))) &gt; 0)</div><div class="line">  fwrite(buf, 1, len, stdout);</div><div class="line"><span class="keywordflow">if</span> (!input.eof())</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;An IO error occurred&quot;</span> &lt;&lt; std::endl;</div><div class="line">ifs.close();</div></div><!-- fragment --><h2>Example </h2>
<p>The following example shows how to use the <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> class to store the entire content of a file in a temporary buffer:</p>
<div class="fragment"><div class="line"><a class="code" href="classreflex_1_1_input.html">reflex::Input</a> input(fopen(<span class="stringliteral">&quot;input.h&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>));</div><div class="line"><span class="keywordflow">if</span> (input.file() == NULL)</div><div class="line">  abort();</div><div class="line"><span class="keywordtype">size_t</span> len = input.size(); <span class="comment">// file size (minus any leading UTF BOM)</span></div><div class="line"><span class="keywordtype">char</span> *buf = <span class="keyword">new</span> <span class="keywordtype">char</span>[len];</div><div class="line">input.get(buf, len);</div><div class="line"><span class="keywordflow">if</span> (!input.eof())</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;An IO error occurred&quot;</span> &lt;&lt; std::endl;</div><div class="line">fwrite(buf, 1, len, stdout);</div><div class="line"><span class="keyword">delete</span>[] buf;</div><div class="line">fclose(input.file());</div></div><!-- fragment --><p>In the above, files with UTF-16 and UTF-32 content are converted to UTF-8 by <code>get(buf, len)</code>. Also, <code><a class="el" href="classreflex_1_1_input.html#a4d1e21f3356426598bc6dc139812de31" title="Get the size of the input character sequence in number of ASCII/UTF-8 bytes (zero if size is not dete...">size()</a></code> returns the total number of UTF-8 bytes to copy in the buffer by <code>get(buf, len)</code>. The size is computed depending on the UTF-8/16/32 file content encoding, i.e. given a leading UTF BOM in the file. This means that UTF-16/32 files are read twice, first internally with <code><a class="el" href="classreflex_1_1_input.html#a4d1e21f3356426598bc6dc139812de31" title="Get the size of the input character sequence in number of ASCII/UTF-8 bytes (zero if size is not dete...">size()</a></code> and then again with get(buf, len)`.</p>
<h2>Example </h2>
<p>The following example shows how to use the <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> class to read a character sequence in blocks from a file:</p>
<div class="fragment"><div class="line"><a class="code" href="classreflex_1_1_input.html">reflex::Input</a> input(fopen(<span class="stringliteral">&quot;input.h&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>));</div><div class="line"><span class="keywordtype">char</span> buf[1024];</div><div class="line"><span class="keywordtype">size_t</span> len;</div><div class="line"><span class="keywordflow">while</span> ((len = input.get(buf, <span class="keyword">sizeof</span>(buf))) &gt; 0)</div><div class="line">  fwrite(buf, 1, len, stdout);</div><div class="line">fclose(input);</div></div><!-- fragment --><h2>Example </h2>
<p>The following example shows how to use the <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> class to echo characters one by one from stdin, e.g. reading input from a tty:</p>
<div class="fragment"><div class="line"><a class="code" href="classreflex_1_1_input.html">reflex::Input</a> input(stdin);</div><div class="line"><span class="keywordtype">char</span> c;</div><div class="line"><span class="keywordflow">while</span> (input.get(&amp;c, 1))</div><div class="line">  fputc(c, stdout);</div></div><!-- fragment --><p>Or if you prefer to use an int character and check for EOF explicitly:</p>
<div class="fragment"><div class="line"><a class="code" href="classreflex_1_1_input.html">reflex::Input</a> input(stdin);</div><div class="line"><span class="keywordtype">int</span> c;</div><div class="line"><span class="keywordflow">while</span> ((c = input.get()) != EOF)</div><div class="line">  fputc(c, stdout);</div></div><!-- fragment --><h2>Example </h2>
<p>The following example shows how to use the <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> class to read a character sequence in blocks from a wide character string, converting it to UTF-8 to copy to stdout:</p>
<div class="fragment"><div class="line"><a class="code" href="classreflex_1_1_input.html">reflex::Input</a> input(L<span class="stringliteral">&quot;Copyright &quot;</span>); <span class="comment">//  is unicode U+00A9 and UTF-8 C2 A9</span></div><div class="line"><span class="keywordtype">char</span> buf[8];</div><div class="line"><span class="keywordtype">size_t</span> len;</div><div class="line"><span class="keywordflow">while</span> ((len = input.get(buf, <span class="keyword">sizeof</span>(buf))) &gt; 0)</div><div class="line">  fwrite(buf, 1, len, stdout);</div></div><!-- fragment --><h2>Example </h2>
<p>The following example shows how to use the <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> class to convert a wide character string to UTF-8:</p>
<div class="fragment"><div class="line"><a class="code" href="classreflex_1_1_input.html">reflex::Input</a> input(L<span class="stringliteral">&quot;Copyright &quot;</span>); <span class="comment">//  is unicode U+00A9 and UTF-8 C2 A9</span></div><div class="line"><span class="keywordtype">size_t</span> len = input.size(); <span class="comment">// size of UTF-8 string</span></div><div class="line"><span class="keywordtype">char</span> *buf = <span class="keyword">new</span> <span class="keywordtype">char</span>[len + 1];</div><div class="line">input.get(buf, len);</div><div class="line">buf[len] = <span class="charliteral">&#39;\0&#39;</span>; <span class="comment">// make \0-terminated</span></div></div><!-- fragment --><h2>Example </h2>
<p>The following example shows how to switch source inputs while reading input byte by byte (use a buffer as shown in other examples to improve efficiency):</p>
<div class="fragment"><div class="line"><a class="code" href="classreflex_1_1_input.html">reflex::Input</a> input = <span class="stringliteral">&quot;Hello&quot;</span>;</div><div class="line">std::string message;</div><div class="line"><span class="keywordtype">char</span> c;</div><div class="line"><span class="keywordflow">while</span> (input.<a class="code" href="classreflex_1_1_input.html#a48e95f4f8c324d1249ee45b41648f114">get</a>(&amp;c, 1))</div><div class="line">  message.append(c);</div><div class="line">input = L<span class="stringliteral">&quot; world! To  and beyond.&quot;</span>; <span class="comment">// switch input to a wide string</span></div><div class="line"><span class="keywordflow">while</span> (input.<a class="code" href="classreflex_1_1_input.html#a48e95f4f8c324d1249ee45b41648f114">get</a>(&amp;c, 1))</div><div class="line">  message.append(c);</div></div><!-- fragment --><h2>Example </h2>
<p>The following examples shows how to use <a class="el" href="classreflex_1_1_input_1_1streambuf.html" title="Stream buffer for reflex::Input, derived from std::streambuf. ">reflex::Input::streambuf</a> to create an unbuffered std::istream:</p>
<div class="fragment"><div class="line"><a class="code" href="classreflex_1_1_input.html">reflex::Input</a> input(fopen(<span class="stringliteral">&quot;legacy.txt&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>), <a class="code" href="structreflex_1_1_input_1_1file__encoding.html#ad80ba65b2eb9e237939b29a4758d8dda">reflex::Input::file_encoding::ebcdic</a>);</div><div class="line"><span class="keywordflow">if</span> (input.<a class="code" href="classreflex_1_1_input.html#a9f64e5c813a08fd7a65819074ffcd20a">file</a>() == NULL)</div><div class="line">  abort();</div><div class="line"><a class="code" href="classreflex_1_1_input_1_1streambuf.html">reflex::Input::streambuf</a> streambuf(input);</div><div class="line">std::istream stream(&amp;streambuf);</div><div class="line">std::string data;</div><div class="line"><span class="keywordtype">int</span> c;</div><div class="line"><span class="keywordflow">while</span> ((c = stream.get()) != EOF)</div><div class="line">  data.append(c);</div><div class="line">fclose(input.<a class="code" href="classreflex_1_1_input.html#a9f64e5c813a08fd7a65819074ffcd20a">file</a>());</div></div><!-- fragment --><p>With <a class="el" href="classreflex_1_1_buffered_input_1_1streambuf.html" title="Buffered stream buffer for reflex::Input, derived from std::streambuf. ">reflex::BufferedInput::streambuf</a> to create a buffered std::istream:</p>
<div class="fragment"><div class="line"><a class="code" href="classreflex_1_1_input.html">reflex::Input</a> input(fopen(<span class="stringliteral">&quot;legacy.txt&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>), <a class="code" href="structreflex_1_1_input_1_1file__encoding.html#ad80ba65b2eb9e237939b29a4758d8dda">reflex::Input::file_encoding::ebcdic</a>);</div><div class="line"><span class="keywordflow">if</span> (input.<a class="code" href="classreflex_1_1_input.html#a9f64e5c813a08fd7a65819074ffcd20a">file</a>() == NULL)</div><div class="line">  abort();</div><div class="line"><a class="code" href="classreflex_1_1_buffered_input_1_1streambuf.html">reflex::BufferedInput::streambuf</a> streambuf(input);</div><div class="line">std::istream stream(&amp;streambuf);</div><div class="line">std::string data;</div><div class="line"><span class="keywordtype">int</span> c;</div><div class="line"><span class="keywordflow">while</span> ((c = stream.get()) != EOF)</div><div class="line">  data.append(c);</div><div class="line">fclose(input.<a class="code" href="classreflex_1_1_input.html#a9f64e5c813a08fd7a65819074ffcd20a">file</a>());</div></div><!-- fragment --> </div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a70e8550b0b1649b2cd49b1b872949cc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned short <a class="el" href="classreflex_1_1_input.html#a70e8550b0b1649b2cd49b1b872949cc8">reflex::Input::file_encoding_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Common <a class="el" href="structreflex_1_1_input_1_1file__encoding.html" title="Common file_encoding constants. ">file_encoding</a> constants type. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8b27ba4af25d4add45d0e09bc2420e22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::Input </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct empty input character sequence. </p>

</div>
</div>
<a class="anchor" id="a7c6455e576c90b478789928db6066267"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::Input </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor (with intended "move semantics" as internal state is shared, should not rely on using the rhs after copying). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>an <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object to share state with (undefined behavior results from using both objects) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a578996e4f28eed9c8ee2a7997d51a3c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::Input </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cstring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct input character sequence from a char* string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cstring</td><td>char string </td></tr>
    <tr><td class="paramname">size</td><td>length of the string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a09465211ad37559885e2e85e9fc18791"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::Input </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cstring</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct input character sequence from a NUL-terminated string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cstring</td><td>NUL-terminated char* string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aec4d78f4c05c7e5ffdaa723bf58ffaea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::Input </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct input character sequence from a std::string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>input string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa309946c0340260b7213ff803544542b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::Input </td>
          <td>(</td>
          <td class="paramtype">const std::string *&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct input character sequence from a pointer to a std::string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>input string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a057e2908a65efbb3ba0c445b724fe100"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::Input </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>wstring</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct input character sequence from a NUL-terminated wide character string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wstring</td><td>NUL-terminated wchar_t* input string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4c0d90a9095c8af1a09e6baa04710bc4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::Input </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>wstring</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct input character sequence from a std::wstring (may contain UTF-16 surrogate pairs). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wstring</td><td>input wide string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a02c30dabe3972582d662517d42cf75a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::Input </td>
          <td>(</td>
          <td class="paramtype">const std::wstring *&#160;</td>
          <td class="paramname"><em>wstring</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct input character sequence from a pointer to a std::wstring (may contain UTF-16 surrogate pairs). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wstring</td><td>input wide string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a13135ec6cf70ed5d16396ad2db5b0c7b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::Input </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct input character sequence from an open FILE* file descriptor, supports UTF-8 conversion from UTF-16 and UTF-32. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>input file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a609f0e4676584113831ea9bff651dada"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::Input </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classreflex_1_1_input.html#a70e8550b0b1649b2cd49b1b872949cc8">file_encoding_type</a>&#160;</td>
          <td class="paramname"><em>enc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short *&#160;</td>
          <td class="paramname"><em>page</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct input character sequence from an open FILE* file descriptor, using the specified file encoding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>input file </td></tr>
    <tr><td class="paramname">enc</td><td><a class="el" href="structreflex_1_1_input_1_1file__encoding.html" title="Common file_encoding constants. ">file_encoding</a> (when UTF BOM is not present) </td></tr>
    <tr><td class="paramname">page</td><td>code page for <a class="el" href="structreflex_1_1_input_1_1file__encoding.html#a76935cbd4a24d36af7e3ebdd5772aeb9" title="custom code page ">file_encoding::custom</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a25a1b7ebdda31f175e0139713212f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::Input </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>istream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct input character sequence from a std::istream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istream</td><td>input stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af5a96b263a02333550b1d7d6cd21d776"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::Input </td>
          <td>(</td>
          <td class="paramtype">std::istream *&#160;</td>
          <td class="paramname"><em>istream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct input character sequence from a pointer to a std::istream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istream</td><td>input stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a21e2de67c899897d38e39eedb2c8ce3a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Input::assigned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object was assigned a character sequence. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object was assigned (not default constructed or cleared) </dd></dl>

</div>
</div>
<a class="anchor" id="a2d8062373d7ce9522e1962af7fd9a49a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Input::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> by unassigning it. </p>

</div>
</div>
<a class="anchor" id="aa3638edd734832d054f3939b8665a77e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* reflex::Input::cstring </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the remaining string of this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object, returns NULL when this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> is not a string. </p>
<dl class="section return"><dt>Returns</dt><dd>remaining unbuffered part of the NUL-terminated string or NULL </dd></dl>

</div>
</div>
<a class="anchor" id="ae66cbeb78ac9c238f08ce5aa570b1fb7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Input::eof </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if input reached EOF. </p>
<dl class="section return"><dt>Returns</dt><dd>true if input is at EOF and no characters are available </dd></dl>

</div>
</div>
<a class="anchor" id="a9f64e5c813a08fd7a65819074ffcd20a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FILE* reflex::Input::file </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the FILE* of this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object, returns NULL when this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> is not a FILE*. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to current file descriptor or NULL </dd></dl>

</div>
</div>
<a class="anchor" id="a25682c7ebc7df115ade370d9d21ed888"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structreflex_1_1_input_1_1file__encoding.html">reflex::Input::file_encoding</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classreflex_1_1_input.html#a70e8550b0b1649b2cd49b1b872949cc8">file_encoding_type</a>&#160;</td>
          <td class="paramname"><em>enc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short *&#160;</td>
          <td class="paramname"><em>page</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set encoding for <code>FILE*</code> input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enc</td><td><a class="el" href="structreflex_1_1_input_1_1file__encoding.html" title="Common file_encoding constants. ">file_encoding</a> </td></tr>
    <tr><td class="paramname">page</td><td>custom code page for <a class="el" href="structreflex_1_1_input_1_1file__encoding.html#a76935cbd4a24d36af7e3ebdd5772aeb9" title="custom code page ">file_encoding::custom</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae553aa63a3a04e836b8aed8ef524a92e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_input.html#a70e8550b0b1649b2cd49b1b872949cc8">file_encoding_type</a> <a class="el" href="structreflex_1_1_input_1_1file__encoding.html">reflex::Input::file_encoding</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get encoding of the current <code>FILE*</code> input. </p>
<dl class="section return"><dt>Returns</dt><dd>current <a class="el" href="structreflex_1_1_input_1_1file__encoding.html" title="Common file_encoding constants. ">file_encoding</a> constant </dd></dl>

</div>
</div>
<a class="anchor" id="a37dd7c46da3413a52866bee4bb060cc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::Input::file_get </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classreflex_1_1_input.html#a48e95f4f8c324d1249ee45b41648f114" title="Get a single character (unsigned char 0..255) or EOF (-1) when end-of-input is reached. ">get()</a> on a FILE*. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>points to the string buffer to fill with input </td></tr>
    <tr><td class="paramname">n</td><td>size of buffer pointed to by s </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2504b809d5be558d426618737c3e168d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Input::file_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called by <a class="el" href="classreflex_1_1_input.html#a3b77d701d8ad80bd4e235e397c180bd5" title="Initialize the state after (re)setting the input source, auto-detects UTF BOM in FILE* input if the f...">init()</a> for a FILE*. </p>

</div>
</div>
<a class="anchor" id="a7d09f141e2ced0bc27129809cdbfc4f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Input::file_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called by <a class="el" href="classreflex_1_1_input.html#a4d1e21f3356426598bc6dc139812de31" title="Get the size of the input character sequence in number of ASCII/UTF-8 bytes (zero if size is not dete...">size()</a> for a FILE*. </p>

</div>
</div>
<a class="anchor" id="a48e95f4f8c324d1249ee45b41648f114"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int reflex::Input::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a single character (unsigned char 0..255) or EOF (-1) when end-of-input is reached. </p>

</div>
</div>
<a class="anchor" id="a3a3830a022486d78670f01003b56d5e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::Input::get </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy character sequence data into buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>the nonzero number of (less or equal to n) 8-bit characters added to buffer s from the current input, or zero when EOF </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>points to the string buffer to fill with input </td></tr>
    <tr><td class="paramname">n</td><td>size of buffer pointed to by s </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad889f01290e7a5cdfd14b4c662635ff8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Input::good </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if input is available. </p>
<dl class="section return"><dt>Returns</dt><dd>true if a non-empty sequence of characters is available to get </dd></dl>

</div>
</div>
<a class="anchor" id="a3b77d701d8ad80bd4e235e397c180bd5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Input::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the state after (re)setting the input source, auto-detects UTF BOM in FILE* input if the file size is known. </p>

</div>
</div>
<a class="anchor" id="a42f00a3d62dd4627413a9f8180f2860b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream* reflex::Input::istream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the std::istream of this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object, returns NULL when this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> is not a std::istream. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to current std::istream or NULL </dd></dl>

</div>
</div>
<a class="anchor" id="a603cfde978e8ff1153073540ff39aae8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Input::istream_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called by <a class="el" href="classreflex_1_1_input.html#a4d1e21f3356426598bc6dc139812de31" title="Get the size of the input character sequence in number of ASCII/UTF-8 bytes (zero if size is not dete...">size()</a> for a std::istream. </p>

</div>
</div>
<a class="anchor" id="ab728a9612c2ddd8e30f97bf094dfbe6c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if a non-empty sequence of characters is available to get </dd></dl>

</div>
</div>
<a class="anchor" id="ab3031e26bf48ef36126f7d789793b4a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::operator const char * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object to a string, returns NULL when this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> is not a string. </p>
<dl class="section return"><dt>Returns</dt><dd>remaining unbuffered part of a NUL-terminated string or NULL </dd></dl>

</div>
</div>
<a class="anchor" id="ae77a9713fc879a2b9338893769e8f617"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::operator const wchar_t * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object to a wide character string, returns NULL when this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> is not a wide string. </p>
<dl class="section return"><dt>Returns</dt><dd>remaining unbuffered part of the NUL-terminated wide character string or NULL </dd></dl>

</div>
</div>
<a class="anchor" id="a7432231f90678cb115ee3dfa82a2a53b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::operator FILE * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object to a file descriptor FILE*, returns NULL when this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> is not a FILE*. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to current file descriptor or NULL </dd></dl>

</div>
</div>
<a class="anchor" id="a4931b283c79df0c3541e4000ef065b53"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::operator std::istream * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object to a std::istream*, returns NULL when this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> is not a std::istream. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to current std::istream or NULL </dd></dl>

</div>
</div>
<a class="anchor" id="a822489aba32803c08ed6db9f50f2caf5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_input.html">Input</a>&amp; reflex::Input::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>

</div>
</div>
<a class="anchor" id="a3476671e945e7fb14e1aa800b8db15bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Input::set_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structreflex_1_1_input_1_1_handler.html">Handler</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set FILE* handler. </p>

</div>
</div>
<a class="anchor" id="a4d1e21f3356426598bc6dc139812de31"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::Input::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the input character sequence in number of ASCII/UTF-8 bytes (zero if size is not determinable from a <code>FILE*</code> or <code>std::istream</code> source). </p>
<dl class="section return"><dt>Returns</dt><dd>the nonzero number of ASCII/UTF-8 bytes available to read, or zero when source is empty or if size is not determinable e.g. when reading from standard input </dd></dl>

</div>
</div>
<a class="anchor" id="aab0fd4f66d1a00060245ba2d6e427473"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const wchar_t* reflex::Input::wstring </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the remaining wide character string of this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object, returns NULL when this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> is not a wide string. </p>
<dl class="section return"><dt>Returns</dt><dd>remaining unbuffered part of the NUL-terminated wide character string or NULL </dd></dl>

</div>
</div>
<a class="anchor" id="a7ba3f1e2d412fafce6245f38b4381fcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Input::wstring_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called by <a class="el" href="classreflex_1_1_input.html#a4d1e21f3356426598bc6dc139812de31" title="Get the size of the input character sequence in number of ASCII/UTF-8 bytes (zero if size is not dete...">size()</a> for a wstring. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ac621d556b409c90464780ea44b8d6570"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* reflex::Input::cstring_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>char string input (when non-null) of length <a class="el" href="classreflex_1_1_input.html#a4ca4ea90ef6f28c106a6811ff21bcc2b" title="size of the remaining input in bytes (size_ == 0 may indicate size is not set) ">reflex::Input::size_</a> </p>

</div>
</div>
<a class="anchor" id="ae9eac97d0e608b436ab2c10620e68fb5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FILE* reflex::Input::file_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>FILE* input (when non-null) </p>

</div>
</div>
<a class="anchor" id="a6497a192b830e0976282720243a10a52"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structreflex_1_1_input_1_1_handler.html">Handler</a>* reflex::Input::handler_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>to handle FILE* errors and non-blocking FILE* reads </p>

</div>
</div>
<a class="anchor" id="a5293a8f00869af77ce8036312d78591c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream* reflex::Input::istream_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>stream input (when non-null) </p>

</div>
</div>
<a class="anchor" id="accc6c55cd219a6717e536bd6c9f0606d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned short* reflex::Input::page_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>custom code page </p>

</div>
</div>
<a class="anchor" id="a4ca4ea90ef6f28c106a6811ff21bcc2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::Input::size_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>size of the remaining input in bytes (size_ == 0 may indicate size is not set) </p>

</div>
</div>
<a class="anchor" id="a371264ce1908a198cc11a7d6990ccbcc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short reflex::Input::uidx_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>index in utf8_[] </p>

</div>
</div>
<a class="anchor" id="a373a13951b67f53d44f923eff79ff563"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short reflex::Input::ulen_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>length of data (remaining after uidx_) in utf8_[] or 0 if no data </p>

</div>
</div>
<a class="anchor" id="a2fb61be8907f3204e7b3583aaa5b72da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char reflex::Input::utf8_[8]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>UTF-8 normalization buffer, &gt;=8 bytes. </p>

</div>
</div>
<a class="anchor" id="a8877e55c75a97a09e3e9e2fb564b1774"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_input.html#a70e8550b0b1649b2cd49b1b872949cc8">file_encoding_type</a> reflex::Input::utfx_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_input_1_1file__encoding.html" title="Common file_encoding constants. ">file_encoding</a> </p>

</div>
</div>
<a class="anchor" id="a6107c7aabf9c28a777c3942442c3b22f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const wchar_t* reflex::Input::wstring_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>NUL-terminated wide string input (when non-null) </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="input_8h.html">input.h</a></li>
</ul>
</div><!-- contents -->
<hr class="footer">
<address class="footer"><small>
Converted on Wed Jul 6 2022 10:30:15 by <a target="_blank" href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.11</small></address>
<br>
<div style="height: 246px; background: #DBDBDB;">
</body>
</html>
