<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta http-equiv="cache-control" content="no-cache">
<title>reflex::Input Class Reference</title>
<link href="doxygen_tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="doxygen_content.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top">
 <div id="titlearea">
  <table height="72px" width="100%" cellspacing="0" cellpadding="0">
   <tbody>
    <tr>
     <td width="10%">&nbsp;</td>
     <td><a href="https://github.com/Genivia/RE-flex"><img src="reflex-logo.png"/></a></td>
     <td>
      <div style="float: right; font-size: 18px; font-weight: bold;">reflex::Input Class Reference</div>
      <br>
      <div style="float: right; font-size: 10px;">updated Tue Nov 15 2016</div>
     </td>
     <td width="10%">&nbsp;</td>
    </tr>
   </tbody>
  </table>
 </div>
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacereflex.html">reflex</a></li><li class="navelem"><a class="el" href="classreflex_1_1_input.html">Input</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classreflex_1_1_input-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">reflex::Input Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;input.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreflex_1_1_input_1_1_const.html">Const</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common constants.  <a href="structreflex_1_1_input_1_1_const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7c6455e576c90b478789928db6066267"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a7c6455e576c90b478789928db6066267">Input</a> (const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;input)</td></tr>
<tr class="memdesc:a7c6455e576c90b478789928db6066267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor (with intended "move semantics" as internal state is shared, should not rely on using the rhs after copying).  <a href="#a7c6455e576c90b478789928db6066267">More...</a><br /></td></tr>
<tr class="separator:a7c6455e576c90b478789928db6066267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa61821e129865a4f58086529486815d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#aaa61821e129865a4f58086529486815d">Input</a> (void)</td></tr>
<tr class="memdesc:aaa61821e129865a4f58086529486815d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct empty input character sequence.  <a href="#aaa61821e129865a4f58086529486815d">More...</a><br /></td></tr>
<tr class="separator:aaa61821e129865a4f58086529486815d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09465211ad37559885e2e85e9fc18791"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a09465211ad37559885e2e85e9fc18791">Input</a> (const char *<a class="el" href="classreflex_1_1_input.html#a35426a06bf4b8928c8ee10b30de93c8b">cstring</a>)</td></tr>
<tr class="memdesc:a09465211ad37559885e2e85e9fc18791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct input character sequence from a NUL-terminated string.  <a href="#a09465211ad37559885e2e85e9fc18791">More...</a><br /></td></tr>
<tr class="separator:a09465211ad37559885e2e85e9fc18791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4d78f4c05c7e5ffdaa723bf58ffaea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#aec4d78f4c05c7e5ffdaa723bf58ffaea">Input</a> (const std::string &amp;string)</td></tr>
<tr class="memdesc:aec4d78f4c05c7e5ffdaa723bf58ffaea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct input character sequence from a std::string.  <a href="#aec4d78f4c05c7e5ffdaa723bf58ffaea">More...</a><br /></td></tr>
<tr class="separator:aec4d78f4c05c7e5ffdaa723bf58ffaea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa309946c0340260b7213ff803544542b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#aa309946c0340260b7213ff803544542b">Input</a> (const std::string *string)</td></tr>
<tr class="memdesc:aa309946c0340260b7213ff803544542b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct input character sequence from a pointer to a std::string.  <a href="#aa309946c0340260b7213ff803544542b">More...</a><br /></td></tr>
<tr class="separator:aa309946c0340260b7213ff803544542b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057e2908a65efbb3ba0c445b724fe100"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a057e2908a65efbb3ba0c445b724fe100">Input</a> (const wchar_t *<a class="el" href="classreflex_1_1_input.html#a0b1890722873d83bc651590c65fa87e3">wstring</a>)</td></tr>
<tr class="memdesc:a057e2908a65efbb3ba0c445b724fe100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct input character sequence from a NUL-terminated wide character string.  <a href="#a057e2908a65efbb3ba0c445b724fe100">More...</a><br /></td></tr>
<tr class="separator:a057e2908a65efbb3ba0c445b724fe100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0d90a9095c8af1a09e6baa04710bc4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a4c0d90a9095c8af1a09e6baa04710bc4">Input</a> (const std::wstring &amp;<a class="el" href="classreflex_1_1_input.html#a0b1890722873d83bc651590c65fa87e3">wstring</a>)</td></tr>
<tr class="memdesc:a4c0d90a9095c8af1a09e6baa04710bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct input character sequence from a std::wstring.  <a href="#a4c0d90a9095c8af1a09e6baa04710bc4">More...</a><br /></td></tr>
<tr class="separator:a4c0d90a9095c8af1a09e6baa04710bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c30dabe3972582d662517d42cf75a4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a02c30dabe3972582d662517d42cf75a4">Input</a> (const std::wstring *<a class="el" href="classreflex_1_1_input.html#a0b1890722873d83bc651590c65fa87e3">wstring</a>)</td></tr>
<tr class="memdesc:a02c30dabe3972582d662517d42cf75a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct input character sequence from a pointer to a std::wstring.  <a href="#a02c30dabe3972582d662517d42cf75a4">More...</a><br /></td></tr>
<tr class="separator:a02c30dabe3972582d662517d42cf75a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13135ec6cf70ed5d16396ad2db5b0c7b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a13135ec6cf70ed5d16396ad2db5b0c7b">Input</a> (FILE *<a class="el" href="classreflex_1_1_input.html#ad96de320b73063857a6d8b84f300eaba">file</a>)</td></tr>
<tr class="memdesc:a13135ec6cf70ed5d16396ad2db5b0c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct input character sequence from an open FILE* file descriptor, supports UTF-8 conversion from UTF-16 and UTF-32, use stdin if file == NULL.  <a href="#a13135ec6cf70ed5d16396ad2db5b0c7b">More...</a><br /></td></tr>
<tr class="separator:a13135ec6cf70ed5d16396ad2db5b0c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a25a1b7ebdda31f175e0139713212f1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a2a25a1b7ebdda31f175e0139713212f1">Input</a> (std::istream &amp;<a class="el" href="classreflex_1_1_input.html#add3aa2ba7a605bf45c5bdc3661f7cb55">istream</a>)</td></tr>
<tr class="memdesc:a2a25a1b7ebdda31f175e0139713212f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct input character sequence from a std::istream.  <a href="#a2a25a1b7ebdda31f175e0139713212f1">More...</a><br /></td></tr>
<tr class="separator:a2a25a1b7ebdda31f175e0139713212f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a96b263a02333550b1d7d6cd21d776"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#af5a96b263a02333550b1d7d6cd21d776">Input</a> (std::istream *<a class="el" href="classreflex_1_1_input.html#add3aa2ba7a605bf45c5bdc3661f7cb55">istream</a>)</td></tr>
<tr class="memdesc:af5a96b263a02333550b1d7d6cd21d776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct input character sequence from a pointer to a std::istream, use stdin if istream == NULL.  <a href="#af5a96b263a02333550b1d7d6cd21d776">More...</a><br /></td></tr>
<tr class="separator:af5a96b263a02333550b1d7d6cd21d776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b104b28d7b9be8f7c43c7e79ffabb5e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a0b104b28d7b9be8f7c43c7e79ffabb5e">operator const char *</a> ()</td></tr>
<tr class="separator:a0b104b28d7b9be8f7c43c7e79ffabb5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032935b6b8f2a5f44036971bda9a1cbd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a032935b6b8f2a5f44036971bda9a1cbd">operator const wchar_t *</a> ()</td></tr>
<tr class="separator:a032935b6b8f2a5f44036971bda9a1cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f2c1835f263ded23d2f262fbdf85c1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a28f2c1835f263ded23d2f262fbdf85c1">operator FILE *</a> ()</td></tr>
<tr class="separator:a28f2c1835f263ded23d2f262fbdf85c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d8c4d8c5105aa81138d3ea6a60c11d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a88d8c4d8c5105aa81138d3ea6a60c11d">operator std::istream *</a> ()</td></tr>
<tr class="separator:a88d8c4d8c5105aa81138d3ea6a60c11d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35426a06bf4b8928c8ee10b30de93c8b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a35426a06bf4b8928c8ee10b30de93c8b">cstring</a> (void)</td></tr>
<tr class="separator:a35426a06bf4b8928c8ee10b30de93c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1890722873d83bc651590c65fa87e3"><td class="memItemLeft" align="right" valign="top">const wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a0b1890722873d83bc651590c65fa87e3">wstring</a> (void)</td></tr>
<tr class="separator:a0b1890722873d83bc651590c65fa87e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96de320b73063857a6d8b84f300eaba"><td class="memItemLeft" align="right" valign="top">FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#ad96de320b73063857a6d8b84f300eaba">file</a> (void)</td></tr>
<tr class="separator:ad96de320b73063857a6d8b84f300eaba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3aa2ba7a605bf45c5bdc3661f7cb55"><td class="memItemLeft" align="right" valign="top">std::istream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#add3aa2ba7a605bf45c5bdc3661f7cb55">istream</a> (void)</td></tr>
<tr class="separator:add3aa2ba7a605bf45c5bdc3661f7cb55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7adcaddc90acd4be7e521f5362d230d3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a7adcaddc90acd4be7e521f5362d230d3">size</a> (void)</td></tr>
<tr class="separator:a7adcaddc90acd4be7e521f5362d230d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbed78324e9deccb7c22df0559602864"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#adbed78324e9deccb7c22df0559602864">good</a> (void)</td></tr>
<tr class="separator:adbed78324e9deccb7c22df0559602864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9bc1fa36ca6f4df73d724aa4892ad3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#adc9bc1fa36ca6f4df73d724aa4892ad3">eof</a> (void)</td></tr>
<tr class="separator:adc9bc1fa36ca6f4df73d724aa4892ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3830a022486d78670f01003b56d5e5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a3a3830a022486d78670f01003b56d5e5">get</a> (char *s, size_t n)</td></tr>
<tr class="separator:a3a3830a022486d78670f01003b56d5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac522bcd8f822f9191f890ba6543b5f71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#ac522bcd8f822f9191f890ba6543b5f71">file_encoding</a> (short enc)</td></tr>
<tr class="memdesc:ac522bcd8f822f9191f890ba6543b5f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set encoding for <code>FILE*</code> input to <a class="el" href="structreflex_1_1_input_1_1_const.html#a2a327de7ecbe34c421ebcb5f09058c49" title="plain ASCII/UTF-8 file_encoding ">Const::plain</a>, <a class="el" href="structreflex_1_1_input_1_1_const.html#a9b6f173e4e331684ef3202bf4d50cd00" title="UTF-16 big endian file_encoding. ">Const::utf16be</a>, <a class="el" href="structreflex_1_1_input_1_1_const.html#a8d02b5c499209ed24ec80bece8d73c3b" title="UTF-16 little endian file_encoding. ">Const::utf16le</a>, <a class="el" href="structreflex_1_1_input_1_1_const.html#a7ef046acca7113d23ff77dbfa1ded607" title="UTF-32 big endian file_encoding. ">Const::utf32be</a>, or <a class="el" href="structreflex_1_1_input_1_1_const.html#aad4ebc8336540986901531df517c619a" title="UTF-32 little endian file_encoding. ">Const::utf32le</a>. File encodings are automatically detected by the presence of a UTF BOM in the file. This function may be used when a BOM is not present and file encoding is known or to override the BOM.  <a href="#ac522bcd8f822f9191f890ba6543b5f71">More...</a><br /></td></tr>
<tr class="separator:ac522bcd8f822f9191f890ba6543b5f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea80c0af7f4a0442a49a5ec9a58f40f"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a0ea80c0af7f4a0442a49a5ec9a58f40f">file_encoding</a> (void) const </td></tr>
<tr class="separator:a0ea80c0af7f4a0442a49a5ec9a58f40f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5349be78e278fc166fa74dfd726c7d4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a5349be78e278fc166fa74dfd726c7d4a">init</a> (void)</td></tr>
<tr class="memdesc:a5349be78e278fc166fa74dfd726c7d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the state after (re)setting the input source.  <a href="#a5349be78e278fc166fa74dfd726c7d4a">More...</a><br /></td></tr>
<tr class="separator:a5349be78e278fc166fa74dfd726c7d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0681f7b13d04de6ab9ed8050529147b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a0681f7b13d04de6ab9ed8050529147b2">file_init</a> (void)</td></tr>
<tr class="memdesc:a0681f7b13d04de6ab9ed8050529147b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classreflex_1_1_input.html#a5349be78e278fc166fa74dfd726c7d4a" title="Initialize the state after (re)setting the input source. ">init()</a> on a FILE*.  <a href="#a0681f7b13d04de6ab9ed8050529147b2">More...</a><br /></td></tr>
<tr class="separator:a0681f7b13d04de6ab9ed8050529147b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37dd7c46da3413a52866bee4bb060cc5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a37dd7c46da3413a52866bee4bb060cc5">file_get</a> (char *s, size_t n)</td></tr>
<tr class="memdesc:a37dd7c46da3413a52866bee4bb060cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classreflex_1_1_input.html#a3a3830a022486d78670f01003b56d5e5">get()</a> on a FILE*.  <a href="#a37dd7c46da3413a52866bee4bb060cc5">More...</a><br /></td></tr>
<tr class="separator:a37dd7c46da3413a52866bee4bb060cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e52b0c33bcfd629d441867152e028c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a2e52b0c33bcfd629d441867152e028c6">file_size</a> (void)</td></tr>
<tr class="memdesc:a2e52b0c33bcfd629d441867152e028c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classreflex_1_1_input.html#a7adcaddc90acd4be7e521f5362d230d3">size()</a> on a FILE*.  <a href="#a2e52b0c33bcfd629d441867152e028c6">More...</a><br /></td></tr>
<tr class="separator:a2e52b0c33bcfd629d441867152e028c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888c01c45af9d069ab3a59e36dcd9c50"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a888c01c45af9d069ab3a59e36dcd9c50">file_good</a> (void)</td></tr>
<tr class="memdesc:a888c01c45af9d069ab3a59e36dcd9c50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classreflex_1_1_input.html#adbed78324e9deccb7c22df0559602864">good()</a>operation on a FILE*.  <a href="#a888c01c45af9d069ab3a59e36dcd9c50">More...</a><br /></td></tr>
<tr class="separator:a888c01c45af9d069ab3a59e36dcd9c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3671ad8d99495f403d4f18f311712679"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a3671ad8d99495f403d4f18f311712679">file_eof</a> (void)</td></tr>
<tr class="memdesc:a3671ad8d99495f403d4f18f311712679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classreflex_1_1_input.html#adc9bc1fa36ca6f4df73d724aa4892ad3">eof()</a> on a FILE*.  <a href="#a3671ad8d99495f403d4f18f311712679">More...</a><br /></td></tr>
<tr class="separator:a3671ad8d99495f403d4f18f311712679"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ac621d556b409c90464780ea44b8d6570"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#ac621d556b409c90464780ea44b8d6570">cstring_</a></td></tr>
<tr class="memdesc:ac621d556b409c90464780ea44b8d6570"><td class="mdescLeft">&#160;</td><td class="mdescRight">NUL-terminated char string input (when non-null)  <a href="#ac621d556b409c90464780ea44b8d6570">More...</a><br /></td></tr>
<tr class="separator:ac621d556b409c90464780ea44b8d6570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6107c7aabf9c28a777c3942442c3b22f"><td class="memItemLeft" align="right" valign="top">const wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a6107c7aabf9c28a777c3942442c3b22f">wstring_</a></td></tr>
<tr class="memdesc:a6107c7aabf9c28a777c3942442c3b22f"><td class="mdescLeft">&#160;</td><td class="mdescRight">NUL-terminated wide string input (when non-null)  <a href="#a6107c7aabf9c28a777c3942442c3b22f">More...</a><br /></td></tr>
<tr class="separator:a6107c7aabf9c28a777c3942442c3b22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9eac97d0e608b436ab2c10620e68fb5"><td class="memItemLeft" align="right" valign="top">FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#ae9eac97d0e608b436ab2c10620e68fb5">file_</a></td></tr>
<tr class="memdesc:ae9eac97d0e608b436ab2c10620e68fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">FILE* input (when non-null)  <a href="#ae9eac97d0e608b436ab2c10620e68fb5">More...</a><br /></td></tr>
<tr class="separator:ae9eac97d0e608b436ab2c10620e68fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5293a8f00869af77ce8036312d78591c"><td class="memItemLeft" align="right" valign="top">std::istream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a5293a8f00869af77ce8036312d78591c">istream_</a></td></tr>
<tr class="memdesc:a5293a8f00869af77ce8036312d78591c"><td class="mdescLeft">&#160;</td><td class="mdescRight">stream input (when non-null)  <a href="#a5293a8f00869af77ce8036312d78591c">More...</a><br /></td></tr>
<tr class="separator:a5293a8f00869af77ce8036312d78591c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca4ea90ef6f28c106a6811ff21bcc2b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a4ca4ea90ef6f28c106a6811ff21bcc2b">size_</a></td></tr>
<tr class="memdesc:a4ca4ea90ef6f28c106a6811ff21bcc2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">size of the input in bytes, when known  <a href="#a4ca4ea90ef6f28c106a6811ff21bcc2b">More...</a><br /></td></tr>
<tr class="separator:a4ca4ea90ef6f28c106a6811ff21bcc2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb61be8907f3204e7b3583aaa5b72da"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a2fb61be8907f3204e7b3583aaa5b72da">utf8_</a> [8]</td></tr>
<tr class="memdesc:a2fb61be8907f3204e7b3583aaa5b72da"><td class="mdescLeft">&#160;</td><td class="mdescRight">UTF-8 conversion buffer.  <a href="#a2fb61be8907f3204e7b3583aaa5b72da">More...</a><br /></td></tr>
<tr class="separator:a2fb61be8907f3204e7b3583aaa5b72da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371264ce1908a198cc11a7d6990ccbcc"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a371264ce1908a198cc11a7d6990ccbcc">uidx_</a></td></tr>
<tr class="memdesc:a371264ce1908a198cc11a7d6990ccbcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">index in utf8_[] or &gt;= 8 when unused  <a href="#a371264ce1908a198cc11a7d6990ccbcc">More...</a><br /></td></tr>
<tr class="separator:a371264ce1908a198cc11a7d6990ccbcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e560a30d77f8c4bf277e60998e3c7db"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a2e560a30d77f8c4bf277e60998e3c7db">utfx_</a></td></tr>
<tr class="memdesc:a2e560a30d77f8c4bf277e60998e3c7db"><td class="mdescLeft">&#160;</td><td class="mdescRight">0 = ASCII/UTF-8, 1 = UTF-16 BE, 2 = UTF-16 LE, 3 = UTF-32 BE, 4 = UTF-32 LE  <a href="#a2e560a30d77f8c4bf277e60998e3c7db">More...</a><br /></td></tr>
<tr class="separator:a2e560a30d77f8c4bf277e60998e3c7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>ReFlex input character sequence class for unified access to sources of input of character sequences.</p>
<h2>Description </h2>
<p>The <a class="el" href="classreflex_1_1_input.html">Input</a> class unifies access to a source of input of a character sequence as follows:</p>
<ul>
<li>An <a class="el" href="classreflex_1_1_input.html">Input</a> object is instantiated and (re)assigned a (new) source input: either a <code>char*</code> string, a <code>wchar_t*</code> wide string, a <code>std::string</code>, a <code>std::wstring</code>, a <code>FILE*</code> descriptor, or a <code>std::istream</code> object.</li>
<li>When assigned a wide string source as input, the wide character content is automatically converted to an UTF-8 character sequence when reading with <a class="el" href="classreflex_1_1_input.html#a3a3830a022486d78670f01003b56d5e5">get()</a>.</li>
<li>When assigned a <code>FILE*</code> source as input, the file is checked for the presence of a UTF-8 or a UTF-16 BOM (Byte Order Mark). A UTF-8 BOM is ignored and will not appear on the input character stream (and size is adjusted by 3 bytes). A UTF-16 BOM is intepreted, resulting in the conversion of the file content automatically to an UTF-8 character sequence when reading the file with <a class="el" href="classreflex_1_1_input.html#a3a3830a022486d78670f01003b56d5e5">get()</a>. Also, <a class="el" href="classreflex_1_1_input.html#a7adcaddc90acd4be7e521f5362d230d3">size()</a> gives the content size in the number of UTF-8 bytes.</li>
<li>An input object can be reassigned a new source of input for reading at any time.</li>
<li>An input object obeys move semantics. That is, after assigning an input object to another, the former can no longer be used to read input. This prevents adding the overhead and complexity of file and stream duplication.</li>
<li><code>size_t <a class="el" href="classreflex_1_1_input.html#a3a3830a022486d78670f01003b56d5e5">Input::get(char *buf, size_t len)</a>;</code> reads source input and fills <code>buf</code> with up to <code>len</code> bytes, returning the number of bytes read or zero when a stream or file is bad or when EOF is reached.</li>
<li><code>size_t <a class="el" href="classreflex_1_1_input.html#a7adcaddc90acd4be7e521f5362d230d3">Input::size(void)</a>;</code> returns the number of ASCII/UTF-8 bytes available to read from the source input or zero (zero is also returned when the size is not determinable). Use this function only before reading input with <a class="el" href="classreflex_1_1_input.html#a3a3830a022486d78670f01003b56d5e5">get()</a>. Wide character strings and UTF-16 <code>FILE*</code> content is counted as the total number of UTF-8 bytes that will be produced by <a class="el" href="classreflex_1_1_input.html#a3a3830a022486d78670f01003b56d5e5">get()</a>. The size of a <code>std::istream</code> cannot be determined.</li>
<li><code>bool <a class="el" href="classreflex_1_1_input.html#adbed78324e9deccb7c22df0559602864">Input::good(void)</a>;</code> returns true if the input is readable and a non-empty sequence of characters is available to get. Returns false on EOF or if an error condition is present.</li>
<li><code>bool <a class="el" href="classreflex_1_1_input.html#adc9bc1fa36ca6f4df73d724aa4892ad3">Input::eof(void)</a>;</code> returns true if the input reached EOF. Note that <a class="el" href="classreflex_1_1_input.html#adbed78324e9deccb7c22df0559602864">good()</a> == ! <a class="el" href="classreflex_1_1_input.html#adc9bc1fa36ca6f4df73d724aa4892ad3">eof()</a> for string source input only, since files and streams may have error conditions that prevent reading. That is, for files and streams <a class="el" href="classreflex_1_1_input.html#adc9bc1fa36ca6f4df73d724aa4892ad3">eof()</a> implies <a class="el" href="classreflex_1_1_input.html#adbed78324e9deccb7c22df0559602864">good()</a> == false, but not vice versa. Thus, an error is diagnosed when the condition <a class="el" href="classreflex_1_1_input.html#adbed78324e9deccb7c22df0559602864">good()</a> == false &amp;&amp; <a class="el" href="classreflex_1_1_input.html#adc9bc1fa36ca6f4df73d724aa4892ad3">eof()</a> == false holds. Note that get(buf, len) == 0 &amp;&amp; len &gt; 0 implies <a class="el" href="classreflex_1_1_input.html#adbed78324e9deccb7c22df0559602864">good()</a> == false.</li>
</ul>
<h2>Example </h2>
<p>The following example shows how to read a character sequence in blocks from a <code>std::ifstream</code>:</p>
<div class="fragment"><div class="line">std::ifstream ifs;</div>
<div class="line">ifs.open(<span class="stringliteral">&quot;input.h&quot;</span>, std::ifstream::in);</div>
<div class="line"><a class="code" href="classreflex_1_1_input.html">reflex::Input</a> input(ifs);</div>
<div class="line"><span class="keywordtype">char</span> buf[1024];</div>
<div class="line"><span class="keywordtype">size_t</span> len;</div>
<div class="line"><span class="keywordflow">while</span> ((len = input.get(buf, <span class="keyword">sizeof</span>(buf))) &gt; 0)</div>
<div class="line">  fwrite(buf, 1, len, stdout);</div>
<div class="line"><span class="keywordflow">if</span> (!input.eof())</div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;An IO error occurred&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">ifs.close();</div>
</div><!-- fragment --><h2>Example </h2>
<p>The following example shows how to buffer the entire content of a file:</p>
<div class="fragment"><div class="line"><a class="code" href="classreflex_1_1_input.html">reflex::Input</a> input(fopen(<span class="stringliteral">&quot;input.h&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>));</div>
<div class="line"><span class="keywordflow">if</span> (!input.file())</div>
<div class="line">  <a class="code" href="reflex_8cpp.html#aebaa8f5abd10789858e7528e3465742a">abort</a>();</div>
<div class="line"><span class="keywordtype">size_t</span> len = input.size();</div>
<div class="line"><span class="keywordtype">char</span> *buf = <span class="keyword">new</span> <span class="keywordtype">char</span>[len];</div>
<div class="line">input.get(buf, len);</div>
<div class="line"><span class="keywordflow">if</span> (!input.eof())</div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;An IO error occurred&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">fwrite(buf, 1, len, stdout);</div>
<div class="line"><span class="keyword">delete</span>[] buf;</div>
<div class="line">fclose(input.file());</div>
</div><!-- fragment --><p>Files with UTF-16 content are converted to UTF-8 by get(buf, len), where <a class="el" href="classreflex_1_1_input.html#a7adcaddc90acd4be7e521f5362d230d3">size()</a> gives the total number of UTF-8 bytes that will be produced by get(buf, len).</p>
<h2>Example </h2>
<p>The following example shows how to read a character sequence in blocks from a file:</p>
<div class="fragment"><div class="line"><a class="code" href="classreflex_1_1_input.html">reflex::Input</a> input(fopen(<span class="stringliteral">&quot;input.h&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>));</div>
<div class="line"><span class="keywordtype">char</span> buf[1024];</div>
<div class="line"><span class="keywordtype">size_t</span> len;</div>
<div class="line"><span class="keywordflow">while</span> ((len = input.get(buf, <span class="keyword">sizeof</span>(buf))) &gt; 0)</div>
<div class="line">  fwrite(buf, 1, len, stdout);</div>
<div class="line">fclose(input);</div>
</div><!-- fragment --><h2>Example </h2>
<p>The following example shows how to echo characters one by one from stdin (reading input from a tty):</p>
<div class="fragment"><div class="line"><a class="code" href="classreflex_1_1_input.html">reflex::Input</a> input(stdin);</div>
<div class="line"><span class="keywordtype">char</span> c;</div>
<div class="line"><span class="keywordflow">while</span> (input.get(&amp;c, 1))</div>
<div class="line">  fputc(c, stdout);</div>
</div><!-- fragment --><h2>Example </h2>
<p>The following example shows how to read a character sequence in blocks from a wide character string while converting it to UTF-8:</p>
<div class="fragment"><div class="line"><a class="code" href="classreflex_1_1_input.html">reflex::Input</a> input(L<span class="stringliteral">&quot;Copyright ©&quot;</span>); <span class="comment">// © is unicode U+00A9 and UTF-8 C2 A9</span></div>
<div class="line"><span class="keywordtype">char</span> buf[8];</div>
<div class="line"><span class="keywordtype">size_t</span> len;</div>
<div class="line"><span class="keywordflow">while</span> ((len = input.get(buf, <span class="keyword">sizeof</span>(buf))) &gt; 0)</div>
<div class="line">  fwrite(buf, 1, len, stdout);</div>
</div><!-- fragment --><h2>Example </h2>
<p>The following example shows how to convert a wide character string to UTF-8:</p>
<div class="fragment"><div class="line"><a class="code" href="classreflex_1_1_input.html">reflex::Input</a> input(L<span class="stringliteral">&quot;Copyright ©&quot;</span>); <span class="comment">// © is unicode U+00A9 and UTF-8 C2 A9</span></div>
<div class="line"><span class="keywordtype">size_t</span> len = input.size(); <span class="comment">// size of UTF-8 string</span></div>
<div class="line"><span class="keywordtype">char</span> *buf = <span class="keyword">new</span> <span class="keywordtype">char</span>[len];</div>
<div class="line">input.get(buf, len);</div>
<div class="line">fwrite(buf, 1, len, stdout);</div>
</div><!-- fragment --><h2>Example </h2>
<p>The following example shows how to switch source inputs while reading input byte by byte (use a buffer as shown in other examples to improve efficiency):</p>
<div class="fragment"><div class="line"><a class="code" href="classreflex_1_1_input.html">reflex::Input</a> input = <span class="stringliteral">&quot;Hello&quot;</span>;</div>
<div class="line">std::string message;</div>
<div class="line"><span class="keywordtype">char</span> c;</div>
<div class="line"><span class="keywordflow">while</span> (input.<a class="code" href="classreflex_1_1_input.html#a3a3830a022486d78670f01003b56d5e5">get</a>(&amp;c, 1))</div>
<div class="line">  message.append(c);</div>
<div class="line">input = L<span class="stringliteral">&quot; world! To ∞ and beyond.&quot;</span>; <span class="comment">// switch input to a wide string</span></div>
<div class="line"><span class="keywordflow">while</span> (input.<a class="code" href="classreflex_1_1_input.html#a3a3830a022486d78670f01003b56d5e5">get</a>(&amp;c, 1))</div>
<div class="line">  message.append(c);</div>
</div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7c6455e576c90b478789928db6066267"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::Input </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor (with intended "move semantics" as internal state is shared, should not rely on using the rhs after copying). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>an <a class="el" href="classreflex_1_1_input.html">Input</a> object to share state with (undefined behavior results from using both objects at the same time) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa61821e129865a4f58086529486815d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::Input </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct empty input character sequence. </p>

</div>
</div>
<a class="anchor" id="a09465211ad37559885e2e85e9fc18791"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::Input </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cstring</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct input character sequence from a NUL-terminated string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cstring</td><td>NUL-terminated char* string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aec4d78f4c05c7e5ffdaa723bf58ffaea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::Input </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct input character sequence from a std::string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>input string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa309946c0340260b7213ff803544542b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::Input </td>
          <td>(</td>
          <td class="paramtype">const std::string *&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct input character sequence from a pointer to a std::string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>input string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a057e2908a65efbb3ba0c445b724fe100"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::Input </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>wstring</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct input character sequence from a NUL-terminated wide character string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wstring</td><td>NUL-terminated wchar_t* input string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4c0d90a9095c8af1a09e6baa04710bc4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::Input </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>wstring</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct input character sequence from a std::wstring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wstring</td><td>input wide string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a02c30dabe3972582d662517d42cf75a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::Input </td>
          <td>(</td>
          <td class="paramtype">const std::wstring *&#160;</td>
          <td class="paramname"><em>wstring</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct input character sequence from a pointer to a std::wstring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wstring</td><td>input wide string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a13135ec6cf70ed5d16396ad2db5b0c7b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::Input </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct input character sequence from an open FILE* file descriptor, supports UTF-8 conversion from UTF-16 and UTF-32, use stdin if file == NULL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>input file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a25a1b7ebdda31f175e0139713212f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::Input </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>istream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct input character sequence from a std::istream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istream</td><td>input stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af5a96b263a02333550b1d7d6cd21d776"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::Input </td>
          <td>(</td>
          <td class="paramtype">std::istream *&#160;</td>
          <td class="paramname"><em>istream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct input character sequence from a pointer to a std::istream, use stdin if istream == NULL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istream</td><td>input stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a35426a06bf4b8928c8ee10b30de93c8b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* reflex::Input::cstring </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the remaining string of this <a class="el" href="classreflex_1_1_input.html">Input</a> object. </p><dl class="section return"><dt>Returns</dt><dd>remaining unbuffered part of the NUL-terminated string or NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="adc9bc1fa36ca6f4df73d724aa4892ad3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Input::eof </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if input reached EOF. </p><dl class="section return"><dt>Returns</dt><dd>true if input is at EOF and no characters are available. </dd></dl>

</div>
</div>
<a class="anchor" id="ad96de320b73063857a6d8b84f300eaba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FILE* reflex::Input::file </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the FILE* of this <a class="el" href="classreflex_1_1_input.html">Input</a> object. </p><dl class="section return"><dt>Returns</dt><dd>pointer to current file descriptor or NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="ac522bcd8f822f9191f890ba6543b5f71"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Input::file_encoding </td>
          <td>(</td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>enc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set encoding for <code>FILE*</code> input to <a class="el" href="structreflex_1_1_input_1_1_const.html#a2a327de7ecbe34c421ebcb5f09058c49" title="plain ASCII/UTF-8 file_encoding ">Const::plain</a>, <a class="el" href="structreflex_1_1_input_1_1_const.html#a9b6f173e4e331684ef3202bf4d50cd00" title="UTF-16 big endian file_encoding. ">Const::utf16be</a>, <a class="el" href="structreflex_1_1_input_1_1_const.html#a8d02b5c499209ed24ec80bece8d73c3b" title="UTF-16 little endian file_encoding. ">Const::utf16le</a>, <a class="el" href="structreflex_1_1_input_1_1_const.html#a7ef046acca7113d23ff77dbfa1ded607" title="UTF-32 big endian file_encoding. ">Const::utf32be</a>, or <a class="el" href="structreflex_1_1_input_1_1_const.html#aad4ebc8336540986901531df517c619a" title="UTF-32 little endian file_encoding. ">Const::utf32le</a>. File encodings are automatically detected by the presence of a UTF BOM in the file. This function may be used when a BOM is not present and file encoding is known or to override the BOM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enc</td><td><a class="el" href="structreflex_1_1_input_1_1_const.html#a2a327de7ecbe34c421ebcb5f09058c49" title="plain ASCII/UTF-8 file_encoding ">Const::plain</a>, <a class="el" href="structreflex_1_1_input_1_1_const.html#a9b6f173e4e331684ef3202bf4d50cd00" title="UTF-16 big endian file_encoding. ">Const::utf16be</a>, <a class="el" href="structreflex_1_1_input_1_1_const.html#a8d02b5c499209ed24ec80bece8d73c3b" title="UTF-16 little endian file_encoding. ">Const::utf16le</a>, <a class="el" href="structreflex_1_1_input_1_1_const.html#a7ef046acca7113d23ff77dbfa1ded607" title="UTF-32 big endian file_encoding. ">Const::utf32be</a>, or <a class="el" href="structreflex_1_1_input_1_1_const.html#aad4ebc8336540986901531df517c619a" title="UTF-32 little endian file_encoding. ">Const::utf32le</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0ea80c0af7f4a0442a49a5ec9a58f40f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">short reflex::Input::file_encoding </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get encoding of the current <code>FILE*</code> input, <a class="el" href="structreflex_1_1_input_1_1_const.html#a2a327de7ecbe34c421ebcb5f09058c49" title="plain ASCII/UTF-8 file_encoding ">Const::plain</a>, <a class="el" href="structreflex_1_1_input_1_1_const.html#a9b6f173e4e331684ef3202bf4d50cd00" title="UTF-16 big endian file_encoding. ">Const::utf16be</a>, <a class="el" href="structreflex_1_1_input_1_1_const.html#a8d02b5c499209ed24ec80bece8d73c3b" title="UTF-16 little endian file_encoding. ">Const::utf16le</a>, <a class="el" href="structreflex_1_1_input_1_1_const.html#a7ef046acca7113d23ff77dbfa1ded607" title="UTF-32 big endian file_encoding. ">Const::utf32be</a>, or <a class="el" href="structreflex_1_1_input_1_1_const.html#aad4ebc8336540986901531df517c619a" title="UTF-32 little endian file_encoding. ">Const::utf32le</a>. </p><dl class="section return"><dt>Returns</dt><dd><a class="el" href="structreflex_1_1_input_1_1_const.html#a2a327de7ecbe34c421ebcb5f09058c49" title="plain ASCII/UTF-8 file_encoding ">Const::plain</a>, <a class="el" href="structreflex_1_1_input_1_1_const.html#a9b6f173e4e331684ef3202bf4d50cd00" title="UTF-16 big endian file_encoding. ">Const::utf16be</a>, <a class="el" href="structreflex_1_1_input_1_1_const.html#a8d02b5c499209ed24ec80bece8d73c3b" title="UTF-16 little endian file_encoding. ">Const::utf16le</a>, <a class="el" href="structreflex_1_1_input_1_1_const.html#a7ef046acca7113d23ff77dbfa1ded607" title="UTF-32 big endian file_encoding. ">Const::utf32be</a>, or <a class="el" href="structreflex_1_1_input_1_1_const.html#aad4ebc8336540986901531df517c619a" title="UTF-32 little endian file_encoding. ">Const::utf32le</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a3671ad8d99495f403d4f18f311712679"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Input::file_eof </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classreflex_1_1_input.html#adc9bc1fa36ca6f4df73d724aa4892ad3">eof()</a> on a FILE*. </p>

</div>
</div>
<a class="anchor" id="a37dd7c46da3413a52866bee4bb060cc5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::Input::file_get </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classreflex_1_1_input.html#a3a3830a022486d78670f01003b56d5e5">get()</a> on a FILE*. </p>
<p>size of buffer pointed to by s </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>points to the string buffer to fill with input </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a888c01c45af9d069ab3a59e36dcd9c50"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Input::file_good </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classreflex_1_1_input.html#adbed78324e9deccb7c22df0559602864">good()</a>operation on a FILE*. </p>

</div>
</div>
<a class="anchor" id="a0681f7b13d04de6ab9ed8050529147b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Input::file_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classreflex_1_1_input.html#a5349be78e278fc166fa74dfd726c7d4a" title="Initialize the state after (re)setting the input source. ">init()</a> on a FILE*. </p>

</div>
</div>
<a class="anchor" id="a2e52b0c33bcfd629d441867152e028c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Input::file_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classreflex_1_1_input.html#a7adcaddc90acd4be7e521f5362d230d3">size()</a> on a FILE*. </p>

</div>
</div>
<a class="anchor" id="a3a3830a022486d78670f01003b56d5e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::Input::get </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy subsequent character sequence data into buffer. </p><dl class="section return"><dt>Returns</dt><dd>the nonzero number of (less or equal to n) 8-bit characters added to buffer s from the current input, or zero when EOF. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>points to the string buffer to fill with input </td></tr>
    <tr><td class="paramname">n</td><td>size of buffer pointed to by s </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adbed78324e9deccb7c22df0559602864"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Input::good </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if input is available. </p><dl class="section return"><dt>Returns</dt><dd>true if a non-empty sequence of characters is available to get. </dd></dl>

</div>
</div>
<a class="anchor" id="a5349be78e278fc166fa74dfd726c7d4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Input::init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the state after (re)setting the input source. </p>

</div>
</div>
<a class="anchor" id="add3aa2ba7a605bf45c5bdc3661f7cb55"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream* reflex::Input::istream </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the std::istream of this <a class="el" href="classreflex_1_1_input.html">Input</a> object. </p><dl class="section return"><dt>Returns</dt><dd>pointer to current std::istream or NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b104b28d7b9be8f7c43c7e79ffabb5e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::operator const char * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cast this <a class="el" href="classreflex_1_1_input.html">Input</a> object to string. </p><dl class="section return"><dt>Returns</dt><dd>remaining unbuffered part of the NUL-terminated string or NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a032935b6b8f2a5f44036971bda9a1cbd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::operator const wchar_t * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cast this <a class="el" href="classreflex_1_1_input.html">Input</a> object to wide character string. </p><dl class="section return"><dt>Returns</dt><dd>remaining unbuffered part of the NUL-terminated wide character string or NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a28f2c1835f263ded23d2f262fbdf85c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::operator FILE * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cast this <a class="el" href="classreflex_1_1_input.html">Input</a> object to file descriptor FILE*. </p><dl class="section return"><dt>Returns</dt><dd>pointer to current file descriptor or NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a88d8c4d8c5105aa81138d3ea6a60c11d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::operator std::istream * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cast this <a class="el" href="classreflex_1_1_input.html">Input</a> object to std::istream*. </p><dl class="section return"><dt>Returns</dt><dd>pointer to current std::istream or NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a7adcaddc90acd4be7e521f5362d230d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::Input::size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the size of the input character sequence in number of ASCII/UTF-8 bytes (zero if size is not determinable from a <code>FILE*</code> or <code>std::istream</code> source). </p><dl class="section return"><dt>Returns</dt><dd>the nonzero number of ASCII/UTF-8 bytes available to read, or zero when source is empty or if size is not determinable. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function SHOULD NOT be used after <a class="el" href="classreflex_1_1_input.html#a3a3830a022486d78670f01003b56d5e5">get()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b1890722873d83bc651590c65fa87e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const wchar_t* reflex::Input::wstring </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the remaining wide character string of this <a class="el" href="classreflex_1_1_input.html">Input</a> object. </p><dl class="section return"><dt>Returns</dt><dd>remaining unbuffered part of the NUL-terminated wide character string or NULL. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ac621d556b409c90464780ea44b8d6570"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* reflex::Input::cstring_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>NUL-terminated char string input (when non-null) </p>

</div>
</div>
<a class="anchor" id="ae9eac97d0e608b436ab2c10620e68fb5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FILE* reflex::Input::file_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>FILE* input (when non-null) </p>

</div>
</div>
<a class="anchor" id="a5293a8f00869af77ce8036312d78591c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream* reflex::Input::istream_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>stream input (when non-null) </p>

</div>
</div>
<a class="anchor" id="a4ca4ea90ef6f28c106a6811ff21bcc2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::Input::size_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>size of the input in bytes, when known </p>

</div>
</div>
<a class="anchor" id="a371264ce1908a198cc11a7d6990ccbcc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short reflex::Input::uidx_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>index in utf8_[] or &gt;= 8 when unused </p>

</div>
</div>
<a class="anchor" id="a2fb61be8907f3204e7b3583aaa5b72da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char reflex::Input::utf8_[8]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>UTF-8 conversion buffer. </p>

</div>
</div>
<a class="anchor" id="a2e560a30d77f8c4bf277e60998e3c7db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short reflex::Input::utfx_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>0 = ASCII/UTF-8, 1 = UTF-16 BE, 2 = UTF-16 LE, 3 = UTF-32 BE, 4 = UTF-32 LE </p>

</div>
</div>
<a class="anchor" id="a6107c7aabf9c28a777c3942442c3b22f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const wchar_t* reflex::Input::wstring_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>NUL-terminated wide string input (when non-null) </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="input_8h.html">input.h</a></li>
</ul>
</div><!-- contents -->
<hr class="footer">
<address class="footer"><small>
Converted on Tue Nov 15 2016 15:45:35 by <a target="_blank" href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.10</small></address>
<br>
<div style="height: 246px; background: #DBDBDB;">
</body>
</html>
