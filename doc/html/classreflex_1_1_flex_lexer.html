<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta http-equiv="cache-control" content="no-cache">
<title>reflex::FlexLexer&lt; M &gt; Class Template Reference</title>
<link href="doxygen_tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="doxygen_content.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top">
 <div id="titlearea">
  <table height="72px" width="100%" cellspacing="0" cellpadding="0">
   <tbody>
    <tr>
     <td width="10%">&nbsp;</td>
     <td><a href="https://github.com/Genivia/RE-flex"><img src="reflex-logo.png"/></a></td>
     <td>
      <div style="float: right; font-size: 18px; font-weight: bold;">reflex::FlexLexer&lt; M &gt; Class Template Reference</div>
      <br>
      <div style="float: right; font-size: 10px;">updated Wed Jul 6 2022 by Robert van Engelen</div>
     </td>
     <td width="10%">&nbsp;</td>
    </tr>
   </tbody>
  </table>
 </div>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacereflex.html">reflex</a></li><li class="navelem"><a class="el" href="classreflex_1_1_flex_lexer.html">FlexLexer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classreflex_1_1_flex_lexer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">reflex::FlexLexer&lt; M &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Flex-compatible <a class="el" href="classreflex_1_1_flex_lexer.html" title="Flex-compatible FlexLexer abstract base class template derived from reflex::AbstractMatcher for the r...">FlexLexer</a> abstract base class template derived from <a class="el" href="classreflex_1_1_abstract_matcher.html" title="The abstract matcher base class template defines an interface for all pattern matcher engines...">reflex::AbstractMatcher</a> for the reflex-generated yyFlexLexer scanner class.  
 <a href="classreflex_1_1_flex_lexer.html#details">More...</a></p>

<p><code>#include &lt;flexlexer.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for reflex::FlexLexer&lt; M &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classreflex_1_1_flex_lexer__inherit__graph.png" border="0" usemap="#reflex_1_1_flex_lexer_3_01_m_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="reflex_1_1_flex_lexer_3_01_m_01_4_inherit__map" id="reflex_1_1_flex_lexer_3_01_m_01_4_inherit__map">
<area shape="rect" id="node2" href="classreflex_1_1_abstract_lexer.html" title="The abstract lexer class template that is the abstract root class of all reflex&#45;generated scanners..." alt="" coords="5,5,184,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for reflex::FlexLexer&lt; M &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classreflex_1_1_flex_lexer__coll__graph.png" border="0" usemap="#reflex_1_1_flex_lexer_3_01_m_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="reflex_1_1_flex_lexer_3_01_m_01_4_coll__map" id="reflex_1_1_flex_lexer_3_01_m_01_4_coll__map">
<area shape="rect" id="node2" href="classreflex_1_1_abstract_lexer.html" title="The abstract lexer class template that is the abstract root class of all reflex&#45;generated scanners..." alt="" coords="1036,107,1215,133"/>
<area shape="rect" id="node4" href="classreflex_1_1_abstract_lexer_1_1_matcher.html" title="Extend matcher class M with a member pointing to the instantiating lexer class. " alt="" coords="1328,49,1472,90"/>
<area shape="rect" id="node6" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. " alt="" coords="843,107,935,133"/>
<area shape="rect" id="node7" href="structreflex_1_1_input_1_1_handler.html" title="FILE* handler functor base class to handle FILE* errors and non&#45;blocking FILE* reads. " alt="" coords="541,56,687,83"/>
<area shape="rect" id="node8" title="STL class. " alt="" coords="569,107,659,133"/>
<area shape="rect" id="node9" title="STL class. " alt="" coords="361,98,490,139"/>
<area shape="rect" id="node10" title="STL class. " alt="" coords="155,139,309,165"/>
<area shape="rect" id="node14" title="STL class. " alt="" coords="359,163,492,205"/>
<area shape="rect" id="node11" title="STL class. " alt="" coords="5,139,105,165"/>
<area shape="rect" id="node13" title="STL class. " alt="" coords="711,161,807,188"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer_1_1_matcher.html">Matcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends reflex::AbstractLexer&lt;M&gt;::Matcher for Flex-compatibility.  <a href="classreflex_1_1_flex_lexer_1_1_matcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ade0789c2a7b1a9415ea72b64070727ae"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a>&lt; M &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#ade0789c2a7b1a9415ea72b64070727ae">AbstractBaseLexer</a></td></tr>
<tr class="memdesc:ade0789c2a7b1a9415ea72b64070727ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for the abstract base class.  <a href="#ade0789c2a7b1a9415ea72b64070727ae">More...</a><br /></td></tr>
<tr class="separator:ade0789c2a7b1a9415ea72b64070727ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acebcecc4b60532da9fa73a76593f1d9f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#acebcecc4b60532da9fa73a76593f1d9f">FlexLexer</a> (const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;<a class="el" href="classreflex_1_1_flex_lexer.html#a67838a57266bc8d0e9d0b0b1e5b8d618">input</a>, std::ostream *<a class="el" href="classreflex_1_1_abstract_lexer.html#a520efbcc7a4007bcbdb702b118e1b5ea">os</a>)</td></tr>
<tr class="memdesc:acebcecc4b60532da9fa73a76593f1d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct Flex-compatible lexer to read from a std::istream (and echo the text matches to a std::ostream).  <a href="#acebcecc4b60532da9fa73a76593f1d9f">More...</a><br /></td></tr>
<tr class="separator:acebcecc4b60532da9fa73a76593f1d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac146d992e14d4e7a201e0e9cc4e8b5a4"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#ac146d992e14d4e7a201e0e9cc4e8b5a4">YYText</a> () const </td></tr>
<tr class="memdesc:ac146d992e14d4e7a201e0e9cc4e8b5a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matched text.  <a href="#ac146d992e14d4e7a201e0e9cc4e8b5a4">More...</a><br /></td></tr>
<tr class="separator:ac146d992e14d4e7a201e0e9cc4e8b5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65c6c66b47e833e6cea91ca394d39e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#ae65c6c66b47e833e6cea91ca394d39e3">YYLeng</a> () const </td></tr>
<tr class="memdesc:ae65c6c66b47e833e6cea91ca394d39e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matched text length.  <a href="#ae65c6c66b47e833e6cea91ca394d39e3">More...</a><br /></td></tr>
<tr class="separator:ae65c6c66b47e833e6cea91ca394d39e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67838a57266bc8d0e9d0b0b1e5b8d618"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#a67838a57266bc8d0e9d0b0b1e5b8d618">input</a> ()</td></tr>
<tr class="memdesc:a67838a57266bc8d0e9d0b0b1e5b8d618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read one 8-bit character, returns zero when EOF.  <a href="#a67838a57266bc8d0e9d0b0b1e5b8d618">More...</a><br /></td></tr>
<tr class="separator:a67838a57266bc8d0e9d0b0b1e5b8d618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af074486866aa94fac34d67024ae1cc78"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#af074486866aa94fac34d67024ae1cc78">winput</a> ()</td></tr>
<tr class="memdesc:af074486866aa94fac34d67024ae1cc78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read one wide character, returns zero when EOF.  <a href="#af074486866aa94fac34d67024ae1cc78">More...</a><br /></td></tr>
<tr class="separator:af074486866aa94fac34d67024ae1cc78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57000b46a829b37ba94caf87ac252c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#ad57000b46a829b37ba94caf87ac252c9">unput</a> (char c)</td></tr>
<tr class="memdesc:ad57000b46a829b37ba94caf87ac252c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put back one character on the input character sequence for matching, invalidating the current match info and text.  <a href="#ad57000b46a829b37ba94caf87ac252c9">More...</a><br /></td></tr>
<tr class="separator:ad57000b46a829b37ba94caf87ac252c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2b4aafe590f8a62201904403e392f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#abf2b4aafe590f8a62201904403e392f5">unput</a> (int c)</td></tr>
<tr class="memdesc:abf2b4aafe590f8a62201904403e392f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put back one wide character on the input character sequence for matching, invalidating the current match info and text.  <a href="#abf2b4aafe590f8a62201904403e392f5">More...</a><br /></td></tr>
<tr class="separator:abf2b4aafe590f8a62201904403e392f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70353b2ef20bec00e1e3ca724fef4652"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#a70353b2ef20bec00e1e3ca724fef4652">output</a> (char c)</td></tr>
<tr class="memdesc:a70353b2ef20bec00e1e3ca724fef4652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output one character.  <a href="#a70353b2ef20bec00e1e3ca724fef4652">More...</a><br /></td></tr>
<tr class="separator:a70353b2ef20bec00e1e3ca724fef4652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20722dcc93ce2da529b0cf8f630dd05e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#a20722dcc93ce2da529b0cf8f630dd05e">woutput</a> (int c)</td></tr>
<tr class="memdesc:a20722dcc93ce2da529b0cf8f630dd05e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output one wide character.  <a href="#a20722dcc93ce2da529b0cf8f630dd05e">More...</a><br /></td></tr>
<tr class="separator:a20722dcc93ce2da529b0cf8f630dd05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa778a6d468296c19fa6ab571dea3c54c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#aa778a6d468296c19fa6ab571dea3c54c">switch_streams</a> (const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;<a class="el" href="classreflex_1_1_flex_lexer.html#a67838a57266bc8d0e9d0b0b1e5b8d618">input</a>=<a class="el" href="classreflex_1_1_input.html">Input</a>(), std::ostream *<a class="el" href="classreflex_1_1_abstract_lexer.html#a520efbcc7a4007bcbdb702b118e1b5ea">os</a>=NULL)</td></tr>
<tr class="memdesc:aa778a6d468296c19fa6ab571dea3c54c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch input and output streams.  <a href="#aa778a6d468296c19fa6ab571dea3c54c">More...</a><br /></td></tr>
<tr class="separator:aa778a6d468296c19fa6ab571dea3c54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f16202eb1ef5b9199ad824d7f3ba7bc"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#a9f16202eb1ef5b9199ad824d7f3ba7bc">yywrap</a> ()</td></tr>
<tr class="memdesc:a9f16202eb1ef5b9199ad824d7f3ba7bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default yywrap operation at EOF: do not wrap input.  <a href="#a9f16202eb1ef5b9199ad824d7f3ba7bc">More...</a><br /></td></tr>
<tr class="separator:a9f16202eb1ef5b9199ad824d7f3ba7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a165d09ccde4ddafd64c2b888d7bb7e88"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#a165d09ccde4ddafd64c2b888d7bb7e88">yylex</a> ()=0</td></tr>
<tr class="memdesc:a165d09ccde4ddafd64c2b888d7bb7e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pure virtual lexer (implemented by a reflex-generated yyFlexLexer).  <a href="#a165d09ccde4ddafd64c2b888d7bb7e88">More...</a><br /></td></tr>
<tr class="separator:a165d09ccde4ddafd64c2b888d7bb7e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2600310dd893711df5b357b4c79d9e"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#a2b2600310dd893711df5b357b4c79d9e">LexerInput</a> (char *s, size_t n)</td></tr>
<tr class="memdesc:a2b2600310dd893711df5b357b4c79d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked by <a class="el" href="classreflex_1_1_flex_lexer_1_1_matcher.html" title="Extends reflex::AbstractLexer&lt;M&gt;::Matcher for Flex-compatibility. ">FlexLexer::Matcher</a> to read input character sequence.  <a href="#a2b2600310dd893711df5b357b4c79d9e">More...</a><br /></td></tr>
<tr class="separator:a2b2600310dd893711df5b357b4c79d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7240a5020fb06c2548e26017e77dfed"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#ab7240a5020fb06c2548e26017e77dfed">LexerOutput</a> (const char *s, size_t n)</td></tr>
<tr class="memdesc:ab7240a5020fb06c2548e26017e77dfed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked by ECHO and <a class="el" href="classreflex_1_1_flex_lexer.html#a70353b2ef20bec00e1e3ca724fef4652" title="Output one character. ">FlexLexer::output</a>.  <a href="#ab7240a5020fb06c2548e26017e77dfed">More...</a><br /></td></tr>
<tr class="separator:ab7240a5020fb06c2548e26017e77dfed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8feb64a8dd9afd88fb80fd539a81b74f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#a8feb64a8dd9afd88fb80fd539a81b74f">LexerError</a> (const char *s)</td></tr>
<tr class="memdesc:a8feb64a8dd9afd88fb80fd539a81b74f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked by reflex-generated yyFlexLexer when an error occurs.  <a href="#a8feb64a8dd9afd88fb80fd539a81b74f">More...</a><br /></td></tr>
<tr class="separator:a8feb64a8dd9afd88fb80fd539a81b74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classreflex_1_1_abstract_lexer"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classreflex_1_1_abstract_lexer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer&lt; M &gt;</a></td></tr>
<tr class="memitem:a536b9af11d41ac2441dd8739c64901ae inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a536b9af11d41ac2441dd8739c64901ae">AbstractLexer</a> (const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;input, std::ostream &amp;<a class="el" href="classreflex_1_1_abstract_lexer.html#a520efbcc7a4007bcbdb702b118e1b5ea">os</a>)</td></tr>
<tr class="memdesc:a536b9af11d41ac2441dd8739c64901ae inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct abstract lexer to scan an input character sequence and echo the text matches to output.  <a href="#a536b9af11d41ac2441dd8739c64901ae">More...</a><br /></td></tr>
<tr class="separator:a536b9af11d41ac2441dd8739c64901ae inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3dd2c00e0c5a5a478a02cacaf57bd96 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#ad3dd2c00e0c5a5a478a02cacaf57bd96">~AbstractLexer</a> ()</td></tr>
<tr class="memdesc:ad3dd2c00e0c5a5a478a02cacaf57bd96 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete lexer and its current matcher with its associated input.  <a href="#ad3dd2c00e0c5a5a478a02cacaf57bd96">More...</a><br /></td></tr>
<tr class="separator:ad3dd2c00e0c5a5a478a02cacaf57bd96 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a070058e52c93918d41b1f37901f01b inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a3a070058e52c93918d41b1f37901f01b">set_debug</a> (int flag)</td></tr>
<tr class="memdesc:a3a070058e52c93918d41b1f37901f01b inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set debug flag value.  <a href="#a3a070058e52c93918d41b1f37901f01b">More...</a><br /></td></tr>
<tr class="separator:a3a070058e52c93918d41b1f37901f01b inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bdc642fbcb9b37c124c44f11b335bd inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#ac4bdc642fbcb9b37c124c44f11b335bd">debug</a> () const </td></tr>
<tr class="memdesc:ac4bdc642fbcb9b37c124c44f11b335bd inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get debug flag value.  <a href="#ac4bdc642fbcb9b37c124c44f11b335bd">More...</a><br /></td></tr>
<tr class="separator:ac4bdc642fbcb9b37c124c44f11b335bd inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeedf0d263073b3447b26877c2ef03101 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#aeedf0d263073b3447b26877c2ef03101">perf_report</a> ()</td></tr>
<tr class="memdesc:aeedf0d263073b3447b26877c2ef03101 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy performance reporter, to prevent link errors when reflex option -p is omitted.  <a href="#aeedf0d263073b3447b26877c2ef03101">More...</a><br /></td></tr>
<tr class="separator:aeedf0d263073b3447b26877c2ef03101 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca2e0dcb03e92d26478145004d077b6 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#aeca2e0dcb03e92d26478145004d077b6">wrap</a> ()</td></tr>
<tr class="memdesc:aeca2e0dcb03e92d26478145004d077b6 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default wrap operation at EOF: do not wrap input.  <a href="#aeca2e0dcb03e92d26478145004d077b6">More...</a><br /></td></tr>
<tr class="separator:aeca2e0dcb03e92d26478145004d077b6 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e93c71d6cc835ad29e39d5663bd026 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:a86e93c71d6cc835ad29e39d5663bd026 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a86e93c71d6cc835ad29e39d5663bd026">in</a> (const I &amp;input)</td></tr>
<tr class="memdesc:a86e93c71d6cc835ad29e39d5663bd026 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the matcher and start scanning from the given input character sequence I.  <a href="#a86e93c71d6cc835ad29e39d5663bd026">More...</a><br /></td></tr>
<tr class="separator:a86e93c71d6cc835ad29e39d5663bd026 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50727a74a6e9afe88ab7694047cadbe8 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a50727a74a6e9afe88ab7694047cadbe8">in</a> (const char *b, size_t n)</td></tr>
<tr class="memdesc:a50727a74a6e9afe88ab7694047cadbe8 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the matcher and start scanning from the given byte sequence.  <a href="#a50727a74a6e9afe88ab7694047cadbe8">More...</a><br /></td></tr>
<tr class="separator:a50727a74a6e9afe88ab7694047cadbe8 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90af4baa6d064decf87f54aeb95806d8 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_input.html">Input</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a90af4baa6d064decf87f54aeb95806d8">in</a> ()</td></tr>
<tr class="memdesc:a90af4baa6d064decf87f54aeb95806d8 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current input character sequence that is being scanned.  <a href="#a90af4baa6d064decf87f54aeb95806d8">More...</a><br /></td></tr>
<tr class="separator:a90af4baa6d064decf87f54aeb95806d8 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b88719f4d035a4aefc2f67fd09f8d2 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_input.html">Input</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#aa5b88719f4d035a4aefc2f67fd09f8d2">stdinit</a> ()</td></tr>
<tr class="memdesc:aa5b88719f4d035a4aefc2f67fd09f8d2 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current input character sequence that is being scanned, if none assign stdin.  <a href="#aa5b88719f4d035a4aefc2f67fd09f8d2">More...</a><br /></td></tr>
<tr class="separator:aa5b88719f4d035a4aefc2f67fd09f8d2 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da401412f85849c7b7e744ad4824731 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_input.html">Input</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a7da401412f85849c7b7e744ad4824731">nostdinit</a> ()</td></tr>
<tr class="memdesc:a7da401412f85849c7b7e744ad4824731 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current input character sequence that is being scanned, if none assign std::cin.  <a href="#a7da401412f85849c7b7e744ad4824731">More...</a><br /></td></tr>
<tr class="separator:a7da401412f85849c7b7e744ad4824731 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862b4bd60ae3a2fb7a77825c5f759e41 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a862b4bd60ae3a2fb7a77825c5f759e41">buffer</a> (char *base, size_t <a class="el" href="classreflex_1_1_abstract_lexer.html#a4adf95aef287ae60d22c7bbdf513570f">size</a>)</td></tr>
<tr class="memdesc:a862b4bd60ae3a2fb7a77825c5f759e41 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the matcher and start scanning the given buffer containing 0-terminated character data (data may be modified).  <a href="#a862b4bd60ae3a2fb7a77825c5f759e41">More...</a><br /></td></tr>
<tr class="separator:a862b4bd60ae3a2fb7a77825c5f759e41 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5611c94c961a216fc733244c9b688f8f inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a5611c94c961a216fc733244c9b688f8f">out</a> (std::ostream &amp;<a class="el" href="classreflex_1_1_abstract_lexer.html#a520efbcc7a4007bcbdb702b118e1b5ea">os</a>)</td></tr>
<tr class="memdesc:a5611c94c961a216fc733244c9b688f8f inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current output to the given output stream to echo text matches to.  <a href="#a5611c94c961a216fc733244c9b688f8f">More...</a><br /></td></tr>
<tr class="separator:a5611c94c961a216fc733244c9b688f8f inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4c3de6df3eb45dfd4c3ed86be405e5 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a5f4c3de6df3eb45dfd4c3ed86be405e5">out</a> () const </td></tr>
<tr class="memdesc:a5f4c3de6df3eb45dfd4c3ed86be405e5 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current output stream used to echo text matches to.  <a href="#a5f4c3de6df3eb45dfd4c3ed86be405e5">More...</a><br /></td></tr>
<tr class="separator:a5f4c3de6df3eb45dfd4c3ed86be405e5 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520efbcc7a4007bcbdb702b118e1b5ea inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">std::ostream *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a520efbcc7a4007bcbdb702b118e1b5ea">os</a> ()</td></tr>
<tr class="memdesc:a520efbcc7a4007bcbdb702b118e1b5ea inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the current output stream used to echo text matches to.  <a href="#a520efbcc7a4007bcbdb702b118e1b5ea">More...</a><br /></td></tr>
<tr class="separator:a520efbcc7a4007bcbdb702b118e1b5ea inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac54e52193bb1a175f82b35c9ddfecf inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#abac54e52193bb1a175f82b35c9ddfecf">has_matcher</a> () const </td></tr>
<tr class="memdesc:abac54e52193bb1a175f82b35c9ddfecf inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a matcher was assigned to this lexer for scanning.  <a href="#abac54e52193bb1a175f82b35c9ddfecf">More...</a><br /></td></tr>
<tr class="separator:abac54e52193bb1a175f82b35c9ddfecf inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ee52cef2c37c2ca47a686eea75a5db inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a70ee52cef2c37c2ca47a686eea75a5db">matcher</a> (<a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a> *matcher)</td></tr>
<tr class="memdesc:a70ee52cef2c37c2ca47a686eea75a5db inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the matcher (and its current state) for scanning.  <a href="#a70ee52cef2c37c2ca47a686eea75a5db">More...</a><br /></td></tr>
<tr class="separator:a70ee52cef2c37c2ca47a686eea75a5db inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0be24643126521aeac9cc4cfcaf206a inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#aa0be24643126521aeac9cc4cfcaf206a">matcher</a> () const </td></tr>
<tr class="memdesc:aa0be24643126521aeac9cc4cfcaf206a inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the current matcher.  <a href="#aa0be24643126521aeac9cc4cfcaf206a">More...</a><br /></td></tr>
<tr class="separator:aa0be24643126521aeac9cc4cfcaf206a inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d33059076b03430591e369b5ef96eb inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a85d33059076b03430591e369b5ef96eb">ptr_matcher</a> () const </td></tr>
<tr class="memdesc:a85d33059076b03430591e369b5ef96eb inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the current matcher, NULL if none was set.  <a href="#a85d33059076b03430591e369b5ef96eb">More...</a><br /></td></tr>
<tr class="separator:a85d33059076b03430591e369b5ef96eb inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91254a55027878842695841c8caffdb3 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a91254a55027878842695841c8caffdb3">new_matcher</a> (const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;input=<a class="el" href="classreflex_1_1_input.html">Input</a>(), const char *opt=NULL)</td></tr>
<tr class="memdesc:a91254a55027878842695841c8caffdb3 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new copy of the matcher for the given input.  <a href="#a91254a55027878842695841c8caffdb3">More...</a><br /></td></tr>
<tr class="separator:a91254a55027878842695841c8caffdb3 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d00ce513ed727dc4fdde304fcb8d97 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a45d00ce513ed727dc4fdde304fcb8d97">del_matcher</a> (<a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a> *<a class="el" href="classreflex_1_1_abstract_lexer.html#a70ee52cef2c37c2ca47a686eea75a5db">matcher</a>)</td></tr>
<tr class="memdesc:a45d00ce513ed727dc4fdde304fcb8d97 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a matcher.  <a href="#a45d00ce513ed727dc4fdde304fcb8d97">More...</a><br /></td></tr>
<tr class="separator:a45d00ce513ed727dc4fdde304fcb8d97 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7da8596b9eeb820214e2630a331e43d inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#aa7da8596b9eeb820214e2630a331e43d">push_matcher</a> (<a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a> *<a class="el" href="classreflex_1_1_abstract_lexer.html#a70ee52cef2c37c2ca47a686eea75a5db">matcher</a>)</td></tr>
<tr class="memdesc:aa7da8596b9eeb820214e2630a331e43d inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push the current matcher on the stack and use the given matcher for scanning.  <a href="#aa7da8596b9eeb820214e2630a331e43d">More...</a><br /></td></tr>
<tr class="separator:aa7da8596b9eeb820214e2630a331e43d inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fed855c7271786b505f6a68fb475db inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a83fed855c7271786b505f6a68fb475db">pop_matcher</a> ()</td></tr>
<tr class="memdesc:a83fed855c7271786b505f6a68fb475db inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop matcher from the stack and continue scanning where it left off, delete the current matcher.  <a href="#a83fed855c7271786b505f6a68fb475db">More...</a><br /></td></tr>
<tr class="separator:a83fed855c7271786b505f6a68fb475db inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad708880eff5601208180600758773a1f inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#ad708880eff5601208180600758773a1f">echo</a> () const </td></tr>
<tr class="memdesc:ad708880eff5601208180600758773a1f inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Echo the matched text to the current output.  <a href="#ad708880eff5601208180600758773a1f">More...</a><br /></td></tr>
<tr class="separator:ad708880eff5601208180600758773a1f inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1696b73ebd927f1093985f866d73bf6 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#ac1696b73ebd927f1093985f866d73bf6">text</a> () const </td></tr>
<tr class="memdesc:ac1696b73ebd927f1093985f866d73bf6 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns string with the text matched.  <a href="#ac1696b73ebd927f1093985f866d73bf6">More...</a><br /></td></tr>
<tr class="separator:ac1696b73ebd927f1093985f866d73bf6 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b43d3eabdf73eaf8106c33af71fb57 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a25b43d3eabdf73eaf8106c33af71fb57">str</a> () const </td></tr>
<tr class="memdesc:a25b43d3eabdf73eaf8106c33af71fb57 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns string with a copy of the text matched.  <a href="#a25b43d3eabdf73eaf8106c33af71fb57">More...</a><br /></td></tr>
<tr class="separator:a25b43d3eabdf73eaf8106c33af71fb57 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cefad78219d2fe0b10e49a4f74204cc inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a9cefad78219d2fe0b10e49a4f74204cc">wstr</a> () const </td></tr>
<tr class="memdesc:a9cefad78219d2fe0b10e49a4f74204cc inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns wide string with a copy of the text matched.  <a href="#a9cefad78219d2fe0b10e49a4f74204cc">More...</a><br /></td></tr>
<tr class="separator:a9cefad78219d2fe0b10e49a4f74204cc inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08720e165486e2db19cdcd99ee80fb1 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#aa08720e165486e2db19cdcd99ee80fb1">chr</a> () const </td></tr>
<tr class="memdesc:aa08720e165486e2db19cdcd99ee80fb1 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first 8-bit character of the text matched.  <a href="#aa08720e165486e2db19cdcd99ee80fb1">More...</a><br /></td></tr>
<tr class="separator:aa08720e165486e2db19cdcd99ee80fb1 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160da2c0f59e43836cacad171badd45f inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a160da2c0f59e43836cacad171badd45f">wchr</a> () const </td></tr>
<tr class="memdesc:a160da2c0f59e43836cacad171badd45f inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first wide character of the text matched.  <a href="#a160da2c0f59e43836cacad171badd45f">More...</a><br /></td></tr>
<tr class="separator:a160da2c0f59e43836cacad171badd45f inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4adf95aef287ae60d22c7bbdf513570f inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a4adf95aef287ae60d22c7bbdf513570f">size</a> () const </td></tr>
<tr class="memdesc:a4adf95aef287ae60d22c7bbdf513570f inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the matched text size in number of bytes.  <a href="#a4adf95aef287ae60d22c7bbdf513570f">More...</a><br /></td></tr>
<tr class="separator:a4adf95aef287ae60d22c7bbdf513570f inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c209d1965c6917dace3631cbd4fc82 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a57c209d1965c6917dace3631cbd4fc82">wsize</a> () const </td></tr>
<tr class="memdesc:a57c209d1965c6917dace3631cbd4fc82 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the matched text size in number of (wide) characters.  <a href="#a57c209d1965c6917dace3631cbd4fc82">More...</a><br /></td></tr>
<tr class="separator:a57c209d1965c6917dace3631cbd4fc82 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec39f17dabf8019919ab2b515a660e82 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#aec39f17dabf8019919ab2b515a660e82">lineno</a> () const </td></tr>
<tr class="memdesc:aec39f17dabf8019919ab2b515a660e82 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the line number of matched text.  <a href="#aec39f17dabf8019919ab2b515a660e82">More...</a><br /></td></tr>
<tr class="separator:aec39f17dabf8019919ab2b515a660e82 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c0351bb149281f0a0014ec271a349a inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a20c0351bb149281f0a0014ec271a349a">lineno</a> (size_t n)</td></tr>
<tr class="memdesc:a20c0351bb149281f0a0014ec271a349a inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set or change the starting line number of the last match.  <a href="#a20c0351bb149281f0a0014ec271a349a">More...</a><br /></td></tr>
<tr class="separator:a20c0351bb149281f0a0014ec271a349a inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4cf455c03298f1ca49f118b412d111 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a0f4cf455c03298f1ca49f118b412d111">lines</a> () const </td></tr>
<tr class="memdesc:a0f4cf455c03298f1ca49f118b412d111 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of lines that the match spans.  <a href="#a0f4cf455c03298f1ca49f118b412d111">More...</a><br /></td></tr>
<tr class="separator:a0f4cf455c03298f1ca49f118b412d111 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a338a21634404913bd5f38efedf2a109a inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a338a21634404913bd5f38efedf2a109a">lineno_end</a> () const </td></tr>
<tr class="memdesc:a338a21634404913bd5f38efedf2a109a inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ending line number of matched text.  <a href="#a338a21634404913bd5f38efedf2a109a">More...</a><br /></td></tr>
<tr class="separator:a338a21634404913bd5f38efedf2a109a inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7991f7785e86d29c9f64d9991ce47f9e inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a7991f7785e86d29c9f64d9991ce47f9e">columno</a> () const </td></tr>
<tr class="memdesc:a7991f7785e86d29c9f64d9991ce47f9e inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the starting column number of matched text, taking tab spacing into account and counting wide characters as one character each.  <a href="#a7991f7785e86d29c9f64d9991ce47f9e">More...</a><br /></td></tr>
<tr class="separator:a7991f7785e86d29c9f64d9991ce47f9e inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cdf0a400fd515dc2141b993a887cfbe inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a8cdf0a400fd515dc2141b993a887cfbe">columns</a> () const </td></tr>
<tr class="memdesc:a8cdf0a400fd515dc2141b993a887cfbe inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of columns of the last line (or the single line of matched text) in the matched text, taking tab spacing into account and counting wide characters as one character each.  <a href="#a8cdf0a400fd515dc2141b993a887cfbe">More...</a><br /></td></tr>
<tr class="separator:a8cdf0a400fd515dc2141b993a887cfbe inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834e21c4d177c26956dfe0d90beb677a inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a834e21c4d177c26956dfe0d90beb677a">columno_end</a> () const </td></tr>
<tr class="memdesc:a834e21c4d177c26956dfe0d90beb677a inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ending column number of matched text, taking tab spacing into account and counting wide characters as one character each.  <a href="#a834e21c4d177c26956dfe0d90beb677a">More...</a><br /></td></tr>
<tr class="separator:a834e21c4d177c26956dfe0d90beb677a inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905c83f6978b3599c43167ae3c7f5b30 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a905c83f6978b3599c43167ae3c7f5b30">start</a> (int state)</td></tr>
<tr class="memdesc:a905c83f6978b3599c43167ae3c7f5b30 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transition to the given start condition state.  <a href="#a905c83f6978b3599c43167ae3c7f5b30">More...</a><br /></td></tr>
<tr class="separator:a905c83f6978b3599c43167ae3c7f5b30 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac003645fb8e8d8ddb1c268af6ab3b258 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#ac003645fb8e8d8ddb1c268af6ab3b258">start</a> () const </td></tr>
<tr class="memdesc:ac003645fb8e8d8ddb1c268af6ab3b258 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current start condition state.  <a href="#ac003645fb8e8d8ddb1c268af6ab3b258">More...</a><br /></td></tr>
<tr class="separator:ac003645fb8e8d8ddb1c268af6ab3b258 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996791039f153c27947dab23db026f41 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a996791039f153c27947dab23db026f41">push_state</a> (int state)</td></tr>
<tr class="memdesc:a996791039f153c27947dab23db026f41 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push the current start condition state on the stack and transition to the given start condition state.  <a href="#a996791039f153c27947dab23db026f41">More...</a><br /></td></tr>
<tr class="separator:a996791039f153c27947dab23db026f41 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc3e098fc89e5bdc1f6d44af0d85c8f inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a2bc3e098fc89e5bdc1f6d44af0d85c8f">pop_state</a> ()</td></tr>
<tr class="memdesc:a2bc3e098fc89e5bdc1f6d44af0d85c8f inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the stack start condition state and transition to that state.  <a href="#a2bc3e098fc89e5bdc1f6d44af0d85c8f">More...</a><br /></td></tr>
<tr class="separator:a2bc3e098fc89e5bdc1f6d44af0d85c8f inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ccbfb254360056a679cef8702228f6 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#ae5ccbfb254360056a679cef8702228f6">top_state</a> () const </td></tr>
<tr class="memdesc:ae5ccbfb254360056a679cef8702228f6 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stack top start condition state or 0 (INITIAL) if the stack is empty.  <a href="#ae5ccbfb254360056a679cef8702228f6">More...</a><br /></td></tr>
<tr class="separator:ae5ccbfb254360056a679cef8702228f6 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef7b75dfc67ee897a77e70ed7ca46d2 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a4ef7b75dfc67ee897a77e70ed7ca46d2">states_empty</a> () const </td></tr>
<tr class="memdesc:a4ef7b75dfc67ee897a77e70ed7ca46d2 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the condition state stack is empty.  <a href="#a4ef7b75dfc67ee897a77e70ed7ca46d2">More...</a><br /></td></tr>
<tr class="separator:a4ef7b75dfc67ee897a77e70ed7ca46d2 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48da3dea969abc450e9f050600fd43d9 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a48da3dea969abc450e9f050600fd43d9">lexer_error</a> (const char *message=NULL)</td></tr>
<tr class="memdesc:a48da3dea969abc450e9f050600fd43d9 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexer exceptions.  <a href="#a48da3dea969abc450e9f050600fd43d9">More...</a><br /></td></tr>
<tr class="separator:a48da3dea969abc450e9f050600fd43d9 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classreflex_1_1_abstract_lexer"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classreflex_1_1_abstract_lexer')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer&lt; M &gt;</a></td></tr>
<tr class="memitem:a5476b6d021bcbb48aa1623f3a8338b5d inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_input.html">Input</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a5476b6d021bcbb48aa1623f3a8338b5d">in_</a></td></tr>
<tr class="memdesc:a5476b6d021bcbb48aa1623f3a8338b5d inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">the input character sequence to scan  <a href="#a5476b6d021bcbb48aa1623f3a8338b5d">More...</a><br /></td></tr>
<tr class="separator:a5476b6d021bcbb48aa1623f3a8338b5d inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25646f2503ea4a20f5b73bc7da28545e inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">std::ostream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a25646f2503ea4a20f5b73bc7da28545e">os_</a></td></tr>
<tr class="memdesc:a25646f2503ea4a20f5b73bc7da28545e inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">the output stream to echo text matches to  <a href="#a25646f2503ea4a20f5b73bc7da28545e">More...</a><br /></td></tr>
<tr class="separator:a25646f2503ea4a20f5b73bc7da28545e inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76c28c5d0ffec8e603f671b1317c404 inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#ac76c28c5d0ffec8e603f671b1317c404">base_</a></td></tr>
<tr class="memdesc:ac76c28c5d0ffec8e603f671b1317c404 inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">the buffer to scan in place, if non-NULL  <a href="#ac76c28c5d0ffec8e603f671b1317c404">More...</a><br /></td></tr>
<tr class="separator:ac76c28c5d0ffec8e603f671b1317c404 inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d026a0d2f0aefa1177753707a17aa48 inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a7d026a0d2f0aefa1177753707a17aa48">size_</a></td></tr>
<tr class="memdesc:a7d026a0d2f0aefa1177753707a17aa48 inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">the size of the buffer to scan in place, if nonzero  <a href="#a7d026a0d2f0aefa1177753707a17aa48">More...</a><br /></td></tr>
<tr class="separator:a7d026a0d2f0aefa1177753707a17aa48 inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31804738641329190e2ab79c0429d805 inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a31804738641329190e2ab79c0429d805">matcher_</a></td></tr>
<tr class="memdesc:a31804738641329190e2ab79c0429d805 inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">the matcher used for scanning  <a href="#a31804738641329190e2ab79c0429d805">More...</a><br /></td></tr>
<tr class="separator:a31804738641329190e2ab79c0429d805 inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588470b3af8d9c64437ea48f21f9e5fd inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a588470b3af8d9c64437ea48f21f9e5fd">start_</a></td></tr>
<tr class="memdesc:a588470b3af8d9c64437ea48f21f9e5fd inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">the current start condition state  <a href="#a588470b3af8d9c64437ea48f21f9e5fd">More...</a><br /></td></tr>
<tr class="separator:a588470b3af8d9c64437ea48f21f9e5fd inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278b6ed6fdf565b2ef4592ac7372660e inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a278b6ed6fdf565b2ef4592ac7372660e">debug_</a></td></tr>
<tr class="memdesc:a278b6ed6fdf565b2ef4592ac7372660e inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if -d (&ndash;debug) 0 otherwise:  <a href="#a278b6ed6fdf565b2ef4592ac7372660e">More...</a><br /></td></tr>
<tr class="separator:a278b6ed6fdf565b2ef4592ac7372660e inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0b0705752b17d78302e4dae7d2b643 inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">std::stack&lt; <a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a5c0b0705752b17d78302e4dae7d2b643">stack_</a></td></tr>
<tr class="memdesc:a5c0b0705752b17d78302e4dae7d2b643 inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">a stack of pointers to matchers  <a href="#a5c0b0705752b17d78302e4dae7d2b643">More...</a><br /></td></tr>
<tr class="separator:a5c0b0705752b17d78302e4dae7d2b643 inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbffb98e8f214ace1a1c5a2c2b66243a inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">std::stack&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#acbffb98e8f214ace1a1c5a2c2b66243a">state_</a></td></tr>
<tr class="memdesc:acbffb98e8f214ace1a1c5a2c2b66243a inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">a stack of start condition states  <a href="#acbffb98e8f214ace1a1c5a2c2b66243a">More...</a><br /></td></tr>
<tr class="separator:acbffb98e8f214ace1a1c5a2c2b66243a inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename M&gt;<br />
class reflex::FlexLexer&lt; M &gt;</h3>

<p>Flex-compatible <a class="el" href="classreflex_1_1_flex_lexer.html" title="Flex-compatible FlexLexer abstract base class template derived from reflex::AbstractMatcher for the r...">FlexLexer</a> abstract base class template derived from <a class="el" href="classreflex_1_1_abstract_matcher.html" title="The abstract matcher base class template defines an interface for all pattern matcher engines...">reflex::AbstractMatcher</a> for the reflex-generated yyFlexLexer scanner class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">&lt;M&gt;</td><td>matcher class derived from <a class="el" href="classreflex_1_1_abstract_matcher.html" title="The abstract matcher base class template defines an interface for all pattern matcher engines...">reflex::AbstractMatcher</a> </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ade0789c2a7b1a9415ea72b64070727ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a>&lt;M&gt; <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::<a class="el" href="classreflex_1_1_flex_lexer.html#ade0789c2a7b1a9415ea72b64070727ae">AbstractBaseLexer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for the abstract base class. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="acebcecc4b60532da9fa73a76593f1d9f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::<a class="el" href="classreflex_1_1_flex_lexer.html">FlexLexer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct Flex-compatible lexer to read from a std::istream (and echo the text matches to a std::ostream). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>input to read from </td></tr>
    <tr><td class="paramname">os</td><td>echo the text matches to this std::ostream (std::cout by default) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a67838a57266bc8d0e9d0b0b1e5b8d618"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::input </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read one 8-bit character, returns zero when EOF. </p>
<dl class="section return"><dt>Returns</dt><dd>the character read. </dd></dl>

</div>
</div>
<a class="anchor" id="a8feb64a8dd9afd88fb80fd539a81b74f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::LexerError </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoked by reflex-generated yyFlexLexer when an error occurs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>error message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2b2600310dd893711df5b357b4c79d9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::LexerInput </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoked by <a class="el" href="classreflex_1_1_flex_lexer_1_1_matcher.html" title="Extends reflex::AbstractLexer&lt;M&gt;::Matcher for Flex-compatibility. ">FlexLexer::Matcher</a> to read input character sequence. </p>
<dl class="section return"><dt>Returns</dt><dd>the nonzero number of (less or equal to n) 8-bit characters added to buffer s from the current input, or zero when EOF. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>points to the string buffer to fill with input </td></tr>
    <tr><td class="paramname">n</td><td>size of buffer pointed to by s </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab7240a5020fb06c2548e26017e77dfed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::LexerOutput </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoked by ECHO and <a class="el" href="classreflex_1_1_flex_lexer.html#a70353b2ef20bec00e1e3ca724fef4652" title="Output one character. ">FlexLexer::output</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>points to text to output </td></tr>
    <tr><td class="paramname">n</td><td>length of text to output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a70353b2ef20bec00e1e3ca724fef4652"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::output </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output one character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>8-bit char to output via LexerOutput </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa778a6d468296c19fa6ab571dea3c54c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::switch_streams </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em> = <code><a class="el" href="classreflex_1_1_input.html">Input</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>os</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Switch input and output streams. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>new input to read from </td></tr>
    <tr><td class="paramname">os</td><td>echo the text matches to this std::ostream or std::cout by default </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad57000b46a829b37ba94caf87ac252c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::unput </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put back one character on the input character sequence for matching, invalidating the current match info and text. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>8-bit character to put back </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abf2b4aafe590f8a62201904403e392f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::unput </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put back one wide character on the input character sequence for matching, invalidating the current match info and text. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>wide character to put back </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af074486866aa94fac34d67024ae1cc78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::winput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read one wide character, returns zero when EOF. </p>
<dl class="section return"><dt>Returns</dt><dd>the character read. </dd></dl>

</div>
</div>
<a class="anchor" id="a20722dcc93ce2da529b0cf8f630dd05e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::woutput </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output one wide character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>wide char to output via LexerOutput </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae65c6c66b47e833e6cea91ca394d39e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::YYLeng </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The matched text length. </p>
<dl class="section return"><dt>Returns</dt><dd>matched text length. </dd></dl>

</div>
</div>
<a class="anchor" id="a165d09ccde4ddafd64c2b888d7bb7e88"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::yylex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pure virtual lexer (implemented by a reflex-generated yyFlexLexer). </p>

</div>
</div>
<a class="anchor" id="ac146d992e14d4e7a201e0e9cc4e8b5a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::YYText </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The matched text. </p>
<dl class="section return"><dt>Returns</dt><dd>NUL-terminated string. </dd></dl>

</div>
</div>
<a class="anchor" id="a9f16202eb1ef5b9199ad824d7f3ba7bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::yywrap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default yywrap operation at EOF: do not wrap input. </p>
<dl class="section return"><dt>Returns</dt><dd>1 (0 indicates that new input was set and wrap after EOF is OK). </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="flexlexer_8h.html">flexlexer.h</a></li>
</ul>
</div><!-- contents -->
<hr class="footer">
<address class="footer"><small>
Converted on Wed Jul 6 2022 10:30:15 by <a target="_blank" href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.11</small></address>
<br>
<div style="height: 246px; background: #DBDBDB;">
</body>
</html>
