<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta http-equiv="cache-control" content="no-cache">
<title>reflex::FlexLexer&lt; M &gt; Class Template Reference</title>
<link href="doxygen_tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="doxygen_content.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top">
 <div id="titlearea">
  <table height="72px" width="100%" cellspacing="0" cellpadding="0">
   <tbody>
    <tr>
     <td width="10%">&nbsp;</td>
     <td><a href="https://github.com/Genivia/RE-flex"><img src="reflex-logo.png"/></a></td>
     <td>
      <div style="float: right; font-size: 18px; font-weight: bold;">reflex::FlexLexer&lt; M &gt; Class Template Reference</div>
      <br>
      <div style="float: right; font-size: 10px;">updated Tue Nov 15 2016</div>
     </td>
     <td width="10%">&nbsp;</td>
    </tr>
   </tbody>
  </table>
 </div>
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacereflex.html">reflex</a></li><li class="navelem"><a class="el" href="classreflex_1_1_flex_lexer.html">FlexLexer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classreflex_1_1_flex_lexer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">reflex::FlexLexer&lt; M &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>&lt;  
 <a href="classreflex_1_1_flex_lexer.html#details">More...</a></p>

<p><code>#include &lt;flexlexer.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for reflex::FlexLexer&lt; M &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classreflex_1_1_flex_lexer__inherit__graph.png" border="0" usemap="#reflex_1_1_flex_lexer_3_01_m_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="reflex_1_1_flex_lexer_3_01_m_01_4_inherit__map" id="reflex_1_1_flex_lexer_3_01_m_01_4_inherit__map">
<area shape="rect" id="node2" href="classreflex_1_1_abstract_lexer.html" title="&lt; " alt="" coords="4,6,181,34"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for reflex::FlexLexer&lt; M &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classreflex_1_1_flex_lexer__coll__graph.png" border="0" usemap="#reflex_1_1_flex_lexer_3_01_m_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="reflex_1_1_flex_lexer_3_01_m_01_4_coll__map" id="reflex_1_1_flex_lexer_3_01_m_01_4_coll__map">
<area shape="rect" id="node2" href="classreflex_1_1_abstract_lexer.html" title="&lt; " alt="" coords="78,99,255,127"/>
<area shape="rect" id="node4" href="classreflex_1_1_abstract_lexer_1_1_matcher.html" title="Extend matcher class M with a member pointing to the instantiating lexer class. " alt="" coords="4,193,147,237"/>
<area shape="rect" id="node9" href="classreflex_1_1_input.html" title="reflex::Input" alt="" coords="121,6,212,34"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer_1_1_matcher.html">Matcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends <a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html" title="Extend matcher class M with a member pointing to the instantiating lexer class. ">reflex::AbstractLexer::Matcher</a> for Flex-compatibility.  <a href="classreflex_1_1_flex_lexer_1_1_matcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a823a6c12df298eef586dcad894d9132f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#a823a6c12df298eef586dcad894d9132f">FlexLexer</a> (const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;<a class="el" href="classreflex_1_1_flex_lexer.html#af07591a8f965daa9f40844675b94f67e">input</a>=stdin, std::ostream *os=NULL)</td></tr>
<tr class="memdesc:a823a6c12df298eef586dcad894d9132f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct Flex-compatible lexer to read from a std::istream (and echo the text matches to a std::ostream).  <a href="#a823a6c12df298eef586dcad894d9132f">More...</a><br /></td></tr>
<tr class="separator:a823a6c12df298eef586dcad894d9132f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa90e226549b3e7686a88365d29dc8a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#a0fa90e226549b3e7686a88365d29dc8a">YYText</a> (void) const </td></tr>
<tr class="separator:a0fa90e226549b3e7686a88365d29dc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b207bcf406a4f33a369d50c978bb459"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#a3b207bcf406a4f33a369d50c978bb459">YYLeng</a> (void) const </td></tr>
<tr class="separator:a3b207bcf406a4f33a369d50c978bb459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f699221df0470369b1795848afdf497"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#a2f699221df0470369b1795848afdf497">yy_switch_to_buffer</a> (<a class="el" href="classreflex_1_1_flex_lexer_1_1_matcher.html">Matcher</a> *m)</td></tr>
<tr class="memdesc:a2f699221df0470369b1795848afdf497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch to another matcher (and use its buffer).  <a href="#a2f699221df0470369b1795848afdf497">More...</a><br /></td></tr>
<tr class="separator:a2f699221df0470369b1795848afdf497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d556677ed3e7318ee888f0b1c50d76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_flex_lexer_1_1_matcher.html">Matcher</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#a70d556677ed3e7318ee888f0b1c50d76">yy_create_buffer</a> (const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;<a class="el" href="classreflex_1_1_flex_lexer.html#af07591a8f965daa9f40844675b94f67e">input</a>, int)</td></tr>
<tr class="separator:a70d556677ed3e7318ee888f0b1c50d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc88111b874e23118a5df506bcff7a32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#abc88111b874e23118a5df506bcff7a32">yy_delete_buffer</a> (<a class="el" href="classreflex_1_1_flex_lexer_1_1_matcher.html">Matcher</a> *m)</td></tr>
<tr class="memdesc:abc88111b874e23118a5df506bcff7a32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a matcher.  <a href="#abc88111b874e23118a5df506bcff7a32">More...</a><br /></td></tr>
<tr class="separator:abc88111b874e23118a5df506bcff7a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805071ff3872a3125bc4e2b00bd5900e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#a805071ff3872a3125bc4e2b00bd5900e">yyrestart</a> (const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;<a class="el" href="classreflex_1_1_flex_lexer.html#af07591a8f965daa9f40844675b94f67e">input</a>)</td></tr>
<tr class="memdesc:a805071ff3872a3125bc4e2b00bd5900e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restart reading from a stream.  <a href="#a805071ff3872a3125bc4e2b00bd5900e">More...</a><br /></td></tr>
<tr class="separator:a805071ff3872a3125bc4e2b00bd5900e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb472fd47b15feb0b7a6b92ab838ab7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#a3cb472fd47b15feb0b7a6b92ab838ab7">yypush_buffer_state</a> (<a class="el" href="classreflex_1_1_flex_lexer_1_1_matcher.html">Matcher</a> *m)</td></tr>
<tr class="memdesc:a3cb472fd47b15feb0b7a6b92ab838ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push the current matcher on the stack and use a new matcher for scanning.  <a href="#a3cb472fd47b15feb0b7a6b92ab838ab7">More...</a><br /></td></tr>
<tr class="separator:a3cb472fd47b15feb0b7a6b92ab838ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba46b4e22223903847b5578993bb43c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#aba46b4e22223903847b5578993bb43c7">yypop_buffer_state</a> (void)</td></tr>
<tr class="memdesc:aba46b4e22223903847b5578993bb43c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop matcher from the stack and delete the current matcher.  <a href="#aba46b4e22223903847b5578993bb43c7">More...</a><br /></td></tr>
<tr class="separator:aba46b4e22223903847b5578993bb43c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa935aad1c7a62649fa07d282c04fd95b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#aa935aad1c7a62649fa07d282c04fd95b">switch_streams</a> (const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;<a class="el" href="classreflex_1_1_flex_lexer.html#af07591a8f965daa9f40844675b94f67e">input</a>=stdin, std::ostream *os=&amp;std::cout)</td></tr>
<tr class="memdesc:aa935aad1c7a62649fa07d282c04fd95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch input and output streams.  <a href="#aa935aad1c7a62649fa07d282c04fd95b">More...</a><br /></td></tr>
<tr class="separator:aa935aad1c7a62649fa07d282c04fd95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eff9117a4141109af82e5120475851b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#a3eff9117a4141109af82e5120475851b">lineno</a> (void) const </td></tr>
<tr class="memdesc:a3eff9117a4141109af82e5120475851b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Line number of matched text.  <a href="#a3eff9117a4141109af82e5120475851b">More...</a><br /></td></tr>
<tr class="separator:a3eff9117a4141109af82e5120475851b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d58a65212d371fe5f0881d23f41c63"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#a26d58a65212d371fe5f0881d23f41c63">yywrap</a> (void)</td></tr>
<tr class="separator:a26d58a65212d371fe5f0881d23f41c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1183b74ec1e006cdad3e35166bb1d183"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#a1183b74ec1e006cdad3e35166bb1d183">yylex</a> (void)=0</td></tr>
<tr class="memdesc:a1183b74ec1e006cdad3e35166bb1d183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pure virtual lexer (implemented by a reflex-generated yyFlexLexer).  <a href="#a1183b74ec1e006cdad3e35166bb1d183">More...</a><br /></td></tr>
<tr class="separator:a1183b74ec1e006cdad3e35166bb1d183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classreflex_1_1_abstract_lexer"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classreflex_1_1_abstract_lexer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer&lt; M &gt;</a></td></tr>
<tr class="memitem:a536b9af11d41ac2441dd8739c64901ae inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a536b9af11d41ac2441dd8739c64901ae">AbstractLexer</a> (const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;input, std::ostream &amp;os)</td></tr>
<tr class="memdesc:a536b9af11d41ac2441dd8739c64901ae inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct abstract lexer to scan an input character sequence and echo the text matches to output.  <a href="#a536b9af11d41ac2441dd8739c64901ae">More...</a><br /></td></tr>
<tr class="separator:a536b9af11d41ac2441dd8739c64901ae inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63559bee1fc440966ea12c9d5a14b586 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a63559bee1fc440966ea12c9d5a14b586">~AbstractLexer</a> (void)</td></tr>
<tr class="memdesc:a63559bee1fc440966ea12c9d5a14b586 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete lexer and its current matcher and input.  <a href="#a63559bee1fc440966ea12c9d5a14b586">More...</a><br /></td></tr>
<tr class="separator:a63559bee1fc440966ea12c9d5a14b586 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a070058e52c93918d41b1f37901f01b inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a3a070058e52c93918d41b1f37901f01b">set_debug</a> (int flag)</td></tr>
<tr class="memdesc:a3a070058e52c93918d41b1f37901f01b inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set debug flag value.  <a href="#a3a070058e52c93918d41b1f37901f01b">More...</a><br /></td></tr>
<tr class="separator:a3a070058e52c93918d41b1f37901f01b inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d6e805887811d8c2c061ab908eca79f inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a8d6e805887811d8c2c061ab908eca79f">debug</a> (void) const </td></tr>
<tr class="separator:a8d6e805887811d8c2c061ab908eca79f inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77e2fac36ed991f62b1308557bfd146 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#ae77e2fac36ed991f62b1308557bfd146">wrap</a> (void)</td></tr>
<tr class="separator:ae77e2fac36ed991f62b1308557bfd146 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affea8a2b877c58c7c85f750b57f18df8 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#affea8a2b877c58c7c85f750b57f18df8">in</a> (const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;input)</td></tr>
<tr class="separator:affea8a2b877c58c7c85f750b57f18df8 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66bec00e18d3e47c4ca395a54efcdc59 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_input.html">Input</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a66bec00e18d3e47c4ca395a54efcdc59">in</a> (void)</td></tr>
<tr class="separator:a66bec00e18d3e47c4ca395a54efcdc59 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5611c94c961a216fc733244c9b688f8f inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a5611c94c961a216fc733244c9b688f8f">out</a> (std::ostream &amp;os)</td></tr>
<tr class="separator:a5611c94c961a216fc733244c9b688f8f inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e6542bb8ef8e767f0237d1d85eb5bb6 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a3e6542bb8ef8e767f0237d1d85eb5bb6">out</a> (void) const </td></tr>
<tr class="separator:a3e6542bb8ef8e767f0237d1d85eb5bb6 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3171a284ccd3e97985ec1d909f7eaf6 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#ab3171a284ccd3e97985ec1d909f7eaf6">has_matcher</a> (void) const </td></tr>
<tr class="separator:ab3171a284ccd3e97985ec1d909f7eaf6 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ee52cef2c37c2ca47a686eea75a5db inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a70ee52cef2c37c2ca47a686eea75a5db">matcher</a> (<a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a> *matcher)</td></tr>
<tr class="separator:a70ee52cef2c37c2ca47a686eea75a5db inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e93b0111f4946f8b16690bd60bfbd37 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a0e93b0111f4946f8b16690bd60bfbd37">matcher</a> (void) const </td></tr>
<tr class="separator:a0e93b0111f4946f8b16690bd60bfbd37 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab259fa3a2881fc2eb5580967f769b4 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a5ab259fa3a2881fc2eb5580967f769b4">new_matcher</a> (const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;input)</td></tr>
<tr class="separator:a5ab259fa3a2881fc2eb5580967f769b4 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1e5064cc9a248871c7b3b3f3dc61b3 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a2c1e5064cc9a248871c7b3b3f3dc61b3">del_matcher</a> (<a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a> *<a class="el" href="classreflex_1_1_abstract_lexer.html#a70ee52cef2c37c2ca47a686eea75a5db">matcher</a>) const </td></tr>
<tr class="memdesc:a2c1e5064cc9a248871c7b3b3f3dc61b3 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a matcher.  <a href="#a2c1e5064cc9a248871c7b3b3f3dc61b3">More...</a><br /></td></tr>
<tr class="separator:a2c1e5064cc9a248871c7b3b3f3dc61b3 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7da8596b9eeb820214e2630a331e43d inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#aa7da8596b9eeb820214e2630a331e43d">push_matcher</a> (<a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a> *<a class="el" href="classreflex_1_1_abstract_lexer.html#a70ee52cef2c37c2ca47a686eea75a5db">matcher</a>)</td></tr>
<tr class="memdesc:aa7da8596b9eeb820214e2630a331e43d inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push the current matcher on the stack and use the given matcher for scanning.  <a href="#aa7da8596b9eeb820214e2630a331e43d">More...</a><br /></td></tr>
<tr class="separator:aa7da8596b9eeb820214e2630a331e43d inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9621be1057537eb490a9ae63169af6 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a1d9621be1057537eb490a9ae63169af6">pop_matcher</a> (void)</td></tr>
<tr class="memdesc:a1d9621be1057537eb490a9ae63169af6 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop matcher from the stack and continue scanning where it left off, delete the current matcher.  <a href="#a1d9621be1057537eb490a9ae63169af6">More...</a><br /></td></tr>
<tr class="separator:a1d9621be1057537eb490a9ae63169af6 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a433d80dd674a3ac1b9929acbf9d78 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a07a433d80dd674a3ac1b9929acbf9d78">echo</a> (void) const </td></tr>
<tr class="memdesc:a07a433d80dd674a3ac1b9929acbf9d78 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Echo the matched text to the current output.  <a href="#a07a433d80dd674a3ac1b9929acbf9d78">More...</a><br /></td></tr>
<tr class="separator:a07a433d80dd674a3ac1b9929acbf9d78 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4adc8cccffbc846e0f8408ddadfed22f inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a4adc8cccffbc846e0f8408ddadfed22f">text</a> (void) const </td></tr>
<tr class="separator:a4adc8cccffbc846e0f8408ddadfed22f inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a981d20f5395a9d278cc7be9f8c8a50 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a8a981d20f5395a9d278cc7be9f8c8a50">size</a> (void) const </td></tr>
<tr class="separator:a8a981d20f5395a9d278cc7be9f8c8a50 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d6d30a2f3c8add23d379a1afa54e69 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a36d6d30a2f3c8add23d379a1afa54e69">lineno</a> (void) const </td></tr>
<tr class="separator:a36d6d30a2f3c8add23d379a1afa54e69 inherit pub_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a2b2600310dd893711df5b357b4c79d9e"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#a2b2600310dd893711df5b357b4c79d9e">LexerInput</a> (char *s, size_t n)</td></tr>
<tr class="separator:a2b2600310dd893711df5b357b4c79d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7240a5020fb06c2548e26017e77dfed"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#ab7240a5020fb06c2548e26017e77dfed">LexerOutput</a> (const char *s, size_t n)</td></tr>
<tr class="memdesc:ab7240a5020fb06c2548e26017e77dfed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked by ECHO and <a class="el" href="classreflex_1_1_flex_lexer.html#a70353b2ef20bec00e1e3ca724fef4652" title="Output one character. ">FlexLexer::output</a>.  <a href="#ab7240a5020fb06c2548e26017e77dfed">More...</a><br /></td></tr>
<tr class="separator:ab7240a5020fb06c2548e26017e77dfed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8feb64a8dd9afd88fb80fd539a81b74f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#a8feb64a8dd9afd88fb80fd539a81b74f">LexerError</a> (const char *s)</td></tr>
<tr class="memdesc:a8feb64a8dd9afd88fb80fd539a81b74f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked by reflex-generated yyFlexLexer when an error occurs.  <a href="#a8feb64a8dd9afd88fb80fd539a81b74f">More...</a><br /></td></tr>
<tr class="separator:a8feb64a8dd9afd88fb80fd539a81b74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ecebbd18526fbb541bbfb674f56c880"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#a2ecebbd18526fbb541bbfb674f56c880">yyinput</a> (void)</td></tr>
<tr class="separator:a2ecebbd18526fbb541bbfb674f56c880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07591a8f965daa9f40844675b94f67e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#af07591a8f965daa9f40844675b94f67e">input</a> (void)</td></tr>
<tr class="separator:af07591a8f965daa9f40844675b94f67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57000b46a829b37ba94caf87ac252c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#ad57000b46a829b37ba94caf87ac252c9">unput</a> (char c)</td></tr>
<tr class="memdesc:ad57000b46a829b37ba94caf87ac252c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put one character back onto the input stream to be read again.  <a href="#ad57000b46a829b37ba94caf87ac252c9">More...</a><br /></td></tr>
<tr class="separator:ad57000b46a829b37ba94caf87ac252c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70353b2ef20bec00e1e3ca724fef4652"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#a70353b2ef20bec00e1e3ca724fef4652">output</a> (char c)</td></tr>
<tr class="memdesc:a70353b2ef20bec00e1e3ca724fef4652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output one character.  <a href="#a70353b2ef20bec00e1e3ca724fef4652">More...</a><br /></td></tr>
<tr class="separator:a70353b2ef20bec00e1e3ca724fef4652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9c5ef8f8df188aa1fd24f750d690d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#a1d9c5ef8f8df188aa1fd24f750d690d4">yymore</a> (void)</td></tr>
<tr class="memdesc:a1d9c5ef8f8df188aa1fd24f750d690d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the next matched text to the currently matched text.  <a href="#a1d9c5ef8f8df188aa1fd24f750d690d4">More...</a><br /></td></tr>
<tr class="separator:a1d9c5ef8f8df188aa1fd24f750d690d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9d7f330a5addd3dd7bf1ac6c6630bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#aad9d7f330a5addd3dd7bf1ac6c6630bd">yyless</a> (int n)</td></tr>
<tr class="memdesc:aad9d7f330a5addd3dd7bf1ac6c6630bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate the yytext length of the match to n characters in length and reposition for next match.  <a href="#aad9d7f330a5addd3dd7bf1ac6c6630bd">More...</a><br /></td></tr>
<tr class="separator:aad9d7f330a5addd3dd7bf1ac6c6630bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb63d84f3823f151b85dc6a559d9e9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#adfb63d84f3823f151b85dc6a559d9e9e">yy_push_state</a> (int state, void *self=NULL)</td></tr>
<tr class="memdesc:adfb63d84f3823f151b85dc6a559d9e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push the current start condition state on the stack and transition to the given start condition state.  <a href="#adfb63d84f3823f151b85dc6a559d9e9e">More...</a><br /></td></tr>
<tr class="separator:adfb63d84f3823f151b85dc6a559d9e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b3f4b4bf32198a114ddf544310063c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#ad8b3f4b4bf32198a114ddf544310063c">yy_pop_state</a> (void *self=NULL)</td></tr>
<tr class="memdesc:ad8b3f4b4bf32198a114ddf544310063c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the stack start condition state and transition to that state.  <a href="#ad8b3f4b4bf32198a114ddf544310063c">More...</a><br /></td></tr>
<tr class="separator:ad8b3f4b4bf32198a114ddf544310063c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a5b9eba28f4b57be94920bcd019107"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#a31a5b9eba28f4b57be94920bcd019107">yy_top_state</a> (void)</td></tr>
<tr class="separator:a31a5b9eba28f4b57be94920bcd019107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classreflex_1_1_abstract_lexer"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classreflex_1_1_abstract_lexer')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer&lt; M &gt;</a></td></tr>
<tr class="memitem:a905c83f6978b3599c43167ae3c7f5b30 inherit pro_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a905c83f6978b3599c43167ae3c7f5b30">start</a> (int state)</td></tr>
<tr class="separator:a905c83f6978b3599c43167ae3c7f5b30 inherit pro_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9230120566cda8006cb8549daa53f61f inherit pro_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a9230120566cda8006cb8549daa53f61f">start</a> (void) const </td></tr>
<tr class="separator:a9230120566cda8006cb8549daa53f61f inherit pro_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996791039f153c27947dab23db026f41 inherit pro_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a996791039f153c27947dab23db026f41">push_state</a> (int state)</td></tr>
<tr class="memdesc:a996791039f153c27947dab23db026f41 inherit pro_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push the current start condition state on the stack and transition to the given start condition state.  <a href="#a996791039f153c27947dab23db026f41">More...</a><br /></td></tr>
<tr class="separator:a996791039f153c27947dab23db026f41 inherit pro_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329ce0260ce6b49ec00472ddaa7b3783 inherit pro_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a329ce0260ce6b49ec00472ddaa7b3783">pop_state</a> (void)</td></tr>
<tr class="memdesc:a329ce0260ce6b49ec00472ddaa7b3783 inherit pro_methods_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the stack start condition state and transition to that state.  <a href="#a329ce0260ce6b49ec00472ddaa7b3783">More...</a><br /></td></tr>
<tr class="separator:a329ce0260ce6b49ec00472ddaa7b3783 inherit pro_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3469ff468c7a2472af990876110b227 inherit pro_methods_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#ab3469ff468c7a2472af990876110b227">top_state</a> (void) const </td></tr>
<tr class="separator:ab3469ff468c7a2472af990876110b227 inherit pro_methods_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ac98e322a100ad3faf2a1bb5efabd6c4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="flexlexer_8h.html#a26938d921de835f6183c02e54cf08828">YY_EXTRA_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_flex_lexer.html#ac98e322a100ad3faf2a1bb5efabd6c4d">yyextra</a></td></tr>
<tr class="memdesc:ac98e322a100ad3faf2a1bb5efabd6c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flex-compatible reentrant YY_EXTRA_TYPE yyextra.  <a href="#ac98e322a100ad3faf2a1bb5efabd6c4d">More...</a><br /></td></tr>
<tr class="separator:ac98e322a100ad3faf2a1bb5efabd6c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classreflex_1_1_abstract_lexer"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classreflex_1_1_abstract_lexer')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer&lt; M &gt;</a></td></tr>
<tr class="memitem:a31804738641329190e2ab79c0429d805 inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a31804738641329190e2ab79c0429d805">matcher_</a></td></tr>
<tr class="memdesc:a31804738641329190e2ab79c0429d805 inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">the matcher used for scanning  <a href="#a31804738641329190e2ab79c0429d805">More...</a><br /></td></tr>
<tr class="separator:a31804738641329190e2ab79c0429d805 inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5476b6d021bcbb48aa1623f3a8338b5d inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_input.html">Input</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a5476b6d021bcbb48aa1623f3a8338b5d">in_</a></td></tr>
<tr class="memdesc:a5476b6d021bcbb48aa1623f3a8338b5d inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">the input character sequence to scan  <a href="#a5476b6d021bcbb48aa1623f3a8338b5d">More...</a><br /></td></tr>
<tr class="separator:a5476b6d021bcbb48aa1623f3a8338b5d inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25646f2503ea4a20f5b73bc7da28545e inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">std::ostream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a25646f2503ea4a20f5b73bc7da28545e">os_</a></td></tr>
<tr class="memdesc:a25646f2503ea4a20f5b73bc7da28545e inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">the output stream to echo text matches to  <a href="#a25646f2503ea4a20f5b73bc7da28545e">More...</a><br /></td></tr>
<tr class="separator:a25646f2503ea4a20f5b73bc7da28545e inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588470b3af8d9c64437ea48f21f9e5fd inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a588470b3af8d9c64437ea48f21f9e5fd">start_</a></td></tr>
<tr class="memdesc:a588470b3af8d9c64437ea48f21f9e5fd inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">the current start condition state  <a href="#a588470b3af8d9c64437ea48f21f9e5fd">More...</a><br /></td></tr>
<tr class="separator:a588470b3af8d9c64437ea48f21f9e5fd inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278b6ed6fdf565b2ef4592ac7372660e inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a278b6ed6fdf565b2ef4592ac7372660e">debug_</a></td></tr>
<tr class="memdesc:a278b6ed6fdf565b2ef4592ac7372660e inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if -d (&ndash;debug) 0 otherwise:  <a href="#a278b6ed6fdf565b2ef4592ac7372660e">More...</a><br /></td></tr>
<tr class="separator:a278b6ed6fdf565b2ef4592ac7372660e inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0b0705752b17d78302e4dae7d2b643 inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">std::stack&lt; <a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a5c0b0705752b17d78302e4dae7d2b643">stack_</a></td></tr>
<tr class="memdesc:a5c0b0705752b17d78302e4dae7d2b643 inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">a stack of pointers to matchers  <a href="#a5c0b0705752b17d78302e4dae7d2b643">More...</a><br /></td></tr>
<tr class="separator:a5c0b0705752b17d78302e4dae7d2b643 inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbffb98e8f214ace1a1c5a2c2b66243a inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="memItemLeft" align="right" valign="top">std::stack&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#acbffb98e8f214ace1a1c5a2c2b66243a">state_</a></td></tr>
<tr class="memdesc:acbffb98e8f214ace1a1c5a2c2b66243a inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="mdescLeft">&#160;</td><td class="mdescRight">a stack of start condition states  <a href="#acbffb98e8f214ace1a1c5a2c2b66243a">More...</a><br /></td></tr>
<tr class="separator:acbffb98e8f214ace1a1c5a2c2b66243a inherit pro_attribs_classreflex_1_1_abstract_lexer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename M&gt;<br />
class reflex::FlexLexer&lt; M &gt;</h3>

<p>&lt; </p>
<p>Flex-compatible <a class="el" href="classreflex_1_1_flex_lexer.html" title="< ">FlexLexer</a> abstract base class template derived from <a class="el" href="classreflex_1_1_abstract_matcher.html">reflex::AbstractMatcher</a> for the reflex-generated yyFlexLexer scanner class.</p>
<p>TODO </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">&lt;M&gt;</td><td>matcher class derived from <a class="el" href="classreflex_1_1_abstract_matcher.html">reflex::AbstractMatcher</a> </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a823a6c12df298eef586dcad894d9132f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::<a class="el" href="classreflex_1_1_flex_lexer.html">FlexLexer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em> = <code>stdin</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>os</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct Flex-compatible lexer to read from a std::istream (and echo the text matches to a std::ostream). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>std::istream (stdin by default) to read a character sequence from </td></tr>
    <tr><td class="paramname">os</td><td>echo the text matches to this std::ostream (std::cout by default) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="af07591a8f965daa9f40844675b94f67e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::input </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read one character, returns zero when EOF. </p><dl class="section return"><dt>Returns</dt><dd>the character read. </dd></dl>

</div>
</div>
<a class="anchor" id="a8feb64a8dd9afd88fb80fd539a81b74f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::LexerError </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoked by reflex-generated yyFlexLexer when an error occurs. </p>

</div>
</div>
<a class="anchor" id="a2b2600310dd893711df5b357b4c79d9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::LexerInput </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Invoked by <a class="el" href="classreflex_1_1_flex_lexer_1_1_matcher.html" title="Extends reflex::AbstractLexer::Matcher for Flex-compatibility. ">FlexLexer::Matcher</a> to read input character sequence. </p><dl class="section return"><dt>Returns</dt><dd>the nonzero number of (less or equal to n) 8-bit characters added to buffer s from the current input, or zero when EOF. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>points to the string buffer to fill with input </td></tr>
    <tr><td class="paramname">n</td><td>size of buffer pointed to by s </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab7240a5020fb06c2548e26017e77dfed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::LexerOutput </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoked by ECHO and <a class="el" href="classreflex_1_1_flex_lexer.html#a70353b2ef20bec00e1e3ca724fef4652" title="Output one character. ">FlexLexer::output</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>points to text to output </td></tr>
    <tr><td class="paramname">n</td><td>length of text to output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3eff9117a4141109af82e5120475851b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::lineno </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Line number of matched text. </p>

</div>
</div>
<a class="anchor" id="a70353b2ef20bec00e1e3ca724fef4652"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::output </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output one character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>char to output via LexerOutput </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa935aad1c7a62649fa07d282c04fd95b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::switch_streams </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em> = <code>stdin</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>os</em> = <code>&amp;std::cout</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Switch input and output streams. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>input to read from </td></tr>
    <tr><td class="paramname">os</td><td>echo the text matches to this std::ostream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad57000b46a829b37ba94caf87ac252c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::unput </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put one character back onto the input stream to be read again. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>char to put back onto the input stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a70d556677ed3e7318ee888f0b1c50d76"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_flex_lexer_1_1_matcher.html">Matcher</a>* <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::yy_create_buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Instantiate a new <a class="el" href="classreflex_1_1_flex_lexer_1_1_matcher.html" title="Extends reflex::AbstractLexer::Matcher for Flex-compatibility. ">FlexLexer::Matcher</a> and buffer. </p><dl class="section return"><dt>Returns</dt><dd>pointer to new <a class="el" href="classreflex_1_1_flex_lexer_1_1_matcher.html" title="Extends reflex::AbstractLexer::Matcher for Flex-compatibility. ">FlexLexer::Matcher</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>read from an input source </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abc88111b874e23118a5df506bcff7a32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::yy_delete_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classreflex_1_1_flex_lexer_1_1_matcher.html">Matcher</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete a matcher. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>victim to delete </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad8b3f4b4bf32198a114ddf544310063c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::yy_pop_state </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>self</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop the stack start condition state and transition to that state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>reentrant or self </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adfb63d84f3823f151b85dc6a559d9e9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::yy_push_state </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>self</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push the current start condition state on the stack and transition to the given start condition state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>start condition state to transition to </td></tr>
    <tr><td class="paramname">self</td><td>reentrant or self </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2f699221df0470369b1795848afdf497"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::yy_switch_to_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classreflex_1_1_flex_lexer_1_1_matcher.html">Matcher</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Switch to another matcher (and use its buffer). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the matcher to switch to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a31a5b9eba28f4b57be94920bcd019107"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::yy_top_state </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the stack top start condition state. </p><dl class="section return"><dt>Returns</dt><dd>start condition (integer). </dd></dl>

</div>
</div>
<a class="anchor" id="a2ecebbd18526fbb541bbfb674f56c880"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::yyinput </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read one character, returns zero when EOF. </p><dl class="section return"><dt>Returns</dt><dd>the character read. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b207bcf406a4f33a369d50c978bb459"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::YYLeng </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The matched text length. </p><dl class="section return"><dt>Returns</dt><dd>matched text length. </dd></dl>

</div>
</div>
<a class="anchor" id="aad9d7f330a5addd3dd7bf1ac6c6630bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::yyless </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Truncate the yytext length of the match to n characters in length and reposition for next match. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>truncated string length </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1183b74ec1e006cdad3e35166bb1d183"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::yylex </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pure virtual lexer (implemented by a reflex-generated yyFlexLexer). </p>

</div>
</div>
<a class="anchor" id="a1d9c5ef8f8df188aa1fd24f750d690d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::yymore </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append the next matched text to the currently matched text. </p>

</div>
</div>
<a class="anchor" id="aba46b4e22223903847b5578993bb43c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::yypop_buffer_state </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop matcher from the stack and delete the current matcher. </p>

</div>
</div>
<a class="anchor" id="a3cb472fd47b15feb0b7a6b92ab838ab7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::yypush_buffer_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classreflex_1_1_flex_lexer_1_1_matcher.html">Matcher</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push the current matcher on the stack and use a new matcher for scanning. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>new <a class="el" href="classreflex_1_1_flex_lexer_1_1_matcher.html" title="Extends reflex::AbstractLexer::Matcher for Flex-compatibility. ">FlexLexer::Matcher</a> for scanning </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a805071ff3872a3125bc4e2b00bd5900e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::yyrestart </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restart reading from a stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>read from an input source </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0fa90e226549b3e7686a88365d29dc8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::YYText </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The matched text. </p><dl class="section return"><dt>Returns</dt><dd>NUL-terminated string. </dd></dl>

</div>
</div>
<a class="anchor" id="a26d58a65212d371fe5f0881d23f41c63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::yywrap </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default yywrap operation at EOF: do not wrap input. </p><dl class="section return"><dt>Returns</dt><dd>1 (0 indicates that new input was set and wrap after EOF is OK). </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ac98e322a100ad3faf2a1bb5efabd6c4d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="flexlexer_8h.html#a26938d921de835f6183c02e54cf08828">YY_EXTRA_TYPE</a> <a class="el" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer</a>&lt; M &gt;::yyextra</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flex-compatible reentrant YY_EXTRA_TYPE yyextra. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="flexlexer_8h.html">flexlexer.h</a></li>
</ul>
</div><!-- contents -->
<hr class="footer">
<address class="footer"><small>
Converted on Tue Nov 15 2016 15:45:35 by <a target="_blank" href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.10</small></address>
<br>
<div style="height: 246px; background: #DBDBDB;">
</body>
</html>
