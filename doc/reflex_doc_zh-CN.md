RE/flex中文文档                                                      {#mainpage}
                                                                @tableofcontents

# RE/flex简介                                                           {#intro}

RE/flex是一个基于正则表达式的，快速词法分析器生成器，具有完整的Unicode支持，
缩进匹配，惰性匹配，单词边界匹配和很多其他的现代特性。

RE/flex还包括一个用C++编写的快速正则表达式引擎，可以选择生成有限状态机表或者
直接代码，以便于更有效的匹配输入。

RE/flex包括一个智能的输入类，用于规范来自文件、流、字符串和内存的输入。

RE/flex与Bison/Yacc兼容，并且支持Flex分析器规范。

## RE/flex特点

+ 对于标记化等典型应用，比Flex++更快；
+ 支持Flex/Lex分析器规范，并且扩展支持Unicode；
+ 符合IEEE POSIX P1003.2标准（像Lex和Flex一样）；
+ 完全支持Unicode，通过智能输入处理自动检测UTF-8/16/32编码；
+ 支持旧文件编码格式，例如CP 1250，EBCDIC；
+ 提供用于lex或语法错误报告和恢复的方法；
+ 易于与Bison可重入、C++、桥接、位置解析器集成；
+ 生成的代码易于理解；
+ 生成线程安全的扫描器；
+ 生成有限状态机图形可视化（graphviz）文件；
+ 用于词法分析器源代码输出的直观输出的自定义选项；
+ 在直接代码或者有限状态机表中的高效匹配；
+ 可选的“自由空间模式”以提高分析器语法规范的可读性；
+ 正则表达式可以包含惰性匹配；
+ 正则表达式可以包含单词边界匹配；
+ 正则表达式可以包含缩进匹配；
+ 可以选择其他正则表达式引擎，比如PCRE2和Boost.Regex；
+ 在一个宽松的开源许可证（BSD-3）下发布。

RE/flex提供很多对Flex++的实用改进，比如：

+ 没有输入缓冲区长度限制（Flex缓冲区有16KB的限制）；
+ `yypush_buffer_state`保存扫描器的状态（行，列，以及缩进位置），不仅仅输入
缓冲区；
+ 新方法分析ASCII和Unicode输入，比如`str()`和`wstr()`获得（宽）字符串匹配，
`line()`和`wline()`获得当前（宽）行号以便于进行错误报告。

词法分析器规则中的规则模式由`reflex`工具转换为直接代码（--fast选项）或者
操作码表（--full选项）中的高效确定的有限状态机。其他的正则表达式引擎可以
选择用于Perl和POSIX匹配模式的PCRE2和Boost.Regex。UTF-8/16/32文件输入规范化
可以自动的为Unicode模式匹配执行。其他编码可以通过用最少的代码编程指定。
因此，RE/flex扫描器可以处理任意类型编码输入。

RE/flex结合适当的面向对象设计原则，并且不像Flex那样依赖于宏和全局变量。
宏和全局变量由`reflex`生成添加到源代码中，仅当设置`--flex`选项时。
一个RE/flex扫描器是一个从基础词法分析类模板继承而来的生成类，其匹配引擎
定义为一个模板参数。

RE/flex与Lex/Flex和Bison/Yacc兼容，通过使用`--flex`和`--bison`选项。
选项`−−yy`强制基本的、简洁的POSIX Lex兼容。RE/flex还提供了与Bison无缝
集成的特定选项，包括Bison桥接、Bison定位、Bison C++、完整Bison以及
可重入解析器。

本文中用*regex*作为正则表达式的简称。但是“正则表达式”指*正则语言*的形式概念，
而*regex*通常指Perl中所介绍的基于回溯的正则匹配。两个概念都适用于RE/flex模式。

总而言之，RE/flex实际上是多个东西组成的一个包：

- 一个更快的，功能丰富的[Flex++ and Flex](dinosaur.compilertools.net/#flex)
替代品；
- 一个独立的正则表达式库，用于在C++中进行快速正则匹配；
- 一个[Boost.Regex](www.boost.org/libs/regex)和[PCRE2](www.pcre.org)
库的C++正则表达式API增强，用于匹配、搜索、分隔和扫描输入，输入可以来自
（宽）字符串、文件、以及长度可能无限的流。

本文采用的排版约定是：

* `Courier` 表示C或C++源代码

* <i>`Courier`</i>表示词法规范和文件名称

* <b>`Courier`</b>表示在终端窗口显示的命令或者程序输出

@note 一个澄清技术问题的说明。

@warning 注意警告！

🔝 [Back to table of contents](#)

## 又是另一个扫描器生成器                                            {#intro1}

Lex，Flex和变体是强大的*扫描器生成器*（也称为*词法分析器*），根据词法分析器规则
生成扫描器。词法分析器规则定义带有用户自定义操作的模式，在输入流中匹配到模式时，
对应的操作将被执行。扫描器重复的匹配模式和触发对应的操作直到输入流结束。

Lex和Flex都是流行的用于开发*分词器（tokenizers）*的工具，当匹配到对应的模式时，
分词器里用户定义的操作会返回一个*标记（token）*。这些分词器通常被用于为编程语言
的编译器或解释器实现扫描源代码并分割成标记。分词器中的正则表达式用于定义扫描的
源代码中的标识符、常量、关键字、符号的组成，以及需要跳过的空白。

例如，下述考虑在词法分析器规则中定义的模式以及对应的操作：

<div class="alt">
~~~{.cpp}
    %%
    /* 模式 */              /* 操作 */
    "if"                    return KEYWORD_IF;
    "*"                     return OP_MUL;
    "="                     return OP_ASSIGN;
    [a-zA-Z_][a-zA-Z0-9_]*  return ASCII_IDENTIFIER;
    [0-9]+                  return CONST_NUMBER;
    \"([^\\"]|\\")*\"       return CONST_STRING;
    [ \t\r\n]               /* 没有操作: 忽略所有的空白 */
    %%
~~~
</div>

当分词器匹配一个模式时，对应的操作将被执行。上述示例返回标记给编译器的解析器，
编译器的解析器重复调用分词器获得更多的标记，直到达到输入的尾部。当达到输入数据
的尾部的时候，分词器返回0。

Lex和Flex工具一直保持相对稳定，但是对Unicode文本编码分词的需求却在增加，比如
UTF-8、UCS/UTF-16、和UTF-32等常用宽字符格式。还有，Flex/Lex中的正则表达式语法
与现代正则表达式语法相比也是受到限制的。FLex不支持Unicode模式、没有惰性重复，
没有单词边界匹配，没有缩进匹配，还有一个限制非常大的可供选择的元数据转义集合。
为了让事情变得更有趣，写一个可以避免POSIX匹配的“贪婪陷阱”的词法分析器规则是一个
挑战。

Flex/Lex扫描器使用POSIX模式匹配，意味着对同一个输入匹配时，在一组模式中，从左侧
匹配最长的模式将被返回。因为POSIX匹配器对任意给定的输入文本生成最长的匹配，
在使用“贪婪”重复的模式（`X*`、`X+`等）我们应该小心，因为我们的模式可能会吞噬比
预期更多的输入。我们最终陷入“贪婪陷阱”。

为了说明这个陷阱，考虑匹配HTML注释`<!−− ... −−>`使用模式`<!−−.*−−>`。问题是重复
模式`X*`是贪婪的，而`.*−−>`模式匹配所有的内容，直到最后一个`−−>`，并且跳过 
`<!−−`和最后一个`−−>`之间的`−−>`。

@note 在Flex/Lex模式里，点`.`通常不匹配换行符号`\n`，除非我们使用*dot-all mode*。

我们可以使用更多复杂的模式，比如：`<!−−([^−]|−[^−]|−−+[^−>])*−*−−>`仅仅用于匹配
HTML中的注释，通过确定模式在第一个匹配到`−−>`时结束。

RE/flex用一个正则表达式`<!−−.*?−−>`足以匹配HTML注释，使用*惰性重复* `X*?`构造， 也被称为*非贪婪重复*。问号`?`是一个*惰性记号*，`X*?`模式的重复方式被修改为：当这
个模式的后边部分（-->）不匹配时，仅重复`X`。因此，正则表达式`<!−−.*?−−>`在
RE/flex中就可以匹配HTML注释，而不会匹配更多的内容。
但是Flex/Lex不允许我们使用惰性。

所以，毫不奇怪，即使Flex手册也使用临时代码而不是模式扫描C/C++源代码输入以匹配
在`/*`和`*/`之间的多行注释。Flex手册推荐：

<div class="alt">
~~~{.cpp}
    "/*"    {  /* 跳过多行注释 */
      int c;
      while ((c = yyinput()) != 0)
      {
        if (c == '\n')
          ++mylineno;
        else if (c == '*')
        {
          if ((c = yyinput()) == '/')
            break;
          unput(c);
        }
      }
    }
~~~
</div>

使用Flex代码的另一个争论是Flex内部缓冲区被限制为16KB。相反的，RE/flex的缓冲区
是动态变化的并且将永远不会用完缓冲空间，以接收更长的匹配。

在RE/flex中不需要诸如此类的解决方法。RE/flex扫描器使用具有表达模式语法的正则
表达式库。我们可以使用惰性重复为多行注释编写正则表达式模式，如下：

<div class="alt">
~~~{.cpp}
    "/*"(.|\n)*?"*/"  /* 无操作: 忽略多行注释 */
~~~
</div>

大多数正则表达式库都支持被模式匹配所依赖的语法和功能。拥有惰性标记的正则表达式
可以更加容易阅读和理解。大多数支持惰性标记的正则表达式库在Perl模式下运行，在输
入上使用回溯。扫描器使用POSIX模式匹配，意味着找到左侧最长匹配。正如我们之前看到
的，差异非常重要，当我们考虑在Perl模式下匹配指定模式去解析输入的问题更是如此，
我们接下来会解释。

考虑之前展示的词法分析器规则示例。假定输入的文本是`iflag = 1`。在Perl模式下，
我们为`iflag`返回`ASCII_IDENTIFIER`，为`=`返回`OP_ASSIGN`，并且为`1`返回
`NUMBER`。在POSIX模式下，我们发现`iflag`匹配`if`，单词的后半部分没有被匹配，
`if`被返回`KEYWORD_IF`，`lag`被返回`ASCII_IDENTIFIER`，`=`被返回`OP_ASSIGN`，
并且`1`被返回`NUMBER`。Perl模式贪婪的匹配，返回左侧最长匹配。

在一个扫描器中使用Perl模式需要在词法分析器规则中定义所有的重复的模式，以便首先
定义最长的匹配模式以确保最长匹配。相比之下，POSIX模式时*声明式的*，并且允许在
规则定义中用任意顺序定义模式。也许唯一的顺序限制是匹配相同的输入，比如：匹配
关键字`if`，`KEYWORD_IF`必须在`ASCII_IDENTIFIER`之前被匹配。

为此原因，RE/flex扫描器使用正则表达式库默认在POSIX模式。

总之：

- RE/flex规则和使用与Lex/Flex和Bison/Yacc是兼容的。

- RE/flex扫描器生成器接受[Flex](dinosaur.compilertools.net/#flex)兼容的规则，
  并有额外的选项用于选择匹配引擎，以及用于指定C++类生成器的名称和选项
  
- RE/flex扫描器生成器选项`−−bison`生成与[Bison](dinosaur.compilertools.net/#bison)
  兼容的扫描器。RE/flex还提供和Bison桥接、Bison定位、Bison完整、以及重定位解析器
  集成的选项。

- Flex和Lex规则中的正则表达式语法被限制为POSIX ERE。相对而言，RE/flex规则语法
  是正则表达式中心的，被设计并提供一个更加丰富的模式语法，包括惰性标记。

- 词法分析类的匹配引擎有一个通用的API接口，被声明为抽象的基础匹配类模板。

- RE/flex扫描器没有被实现为一组全局函数和表。RE/flex扫描器是生成词法分析器类的
  实例，它确保扫描器是线程安全的（相比之下，Flex和Flex++不是线程安全的）。
  一个词法分析器类是继承自一个抽象基词法分析器类模板的，它实例化时，带着一个
  正则表达式匹配引擎作为模板参数。

- Lex和Flex扫描器被限在ASCII编码或者8位字符集，没有对Unicode的充分支持。
  RE/flex规则被扩展为支持Unicode，比如RE/flex扫描器生成器生成的扫描器
  可以自动的处理UTF-8/16/32编码输入文件。

- 匹配引擎和扫描器的输入被实现为一个类，它支持流输入，并且自动的解码UTF编码文件。

- RE/flex扫描器可以是独立的应用，类似于Flex扫描器。

\ref reflex章节有RE/flex扫描器生成工具的更多细节。

在本手册的下一个章节，我们将快速的浏览一下RE/flex正则表达式API，它可以被作为
一个独立的库，用于常规C++应用中来自字符串、文件和流输入的匹配、搜索、扫描和拆分。 （即应用程序不一定是编译器的分词器）。

🔝 [Back to table of contents](#)